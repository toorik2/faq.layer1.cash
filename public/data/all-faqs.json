{
  "title": "BCH FAQ - Comprehensive Technical Guide",
  "description": "A searchable collection of technical Q&A from BCH Devs & Builders, CashScript, CashTokens, and BCH Compilers communities",
  "total_faqs": 644,
  "categories": [
    {
      "name": "Standards & Specifications",
      "description": "Protocol specifications, standards, BIPs, address formats, and technical references",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "What is this FAQ and how was it created?",
          "answer": "This is a comprehensive technical FAQ database for Bitcoin Cash development, containing 643+ questions and answers across 54 categories. The content was extracted from technical Telegram group discussions (BCH Devs & Builders, CashScript, CashTokens, and BCH Compilers communities) using AI analysis. Each Q&A captures real developer conversations, technical insights, and community knowledge about BCH protocol development, smart contracts, token standards, wallets, and infrastructure."
        },
        {
          "question": "Can read-only inputs be spent in the same block as a full spend of the same UTXO?",
          "answer": "It depends on specification. If spent in the same block, it could be defined either way as long as clearly specified. Once a UTXO is spent in a previous block, it cannot be referenced read-only anymore. However, mempool and reorg complexity increases - if a block spending A is reorged, it must include A plus all dependent transactions."
        },
        {
          "question": "How does P2S address standardness issues?",
          "answer": "P2S (Pay to Script) addresses 2 of 5 standardness issues: output standardness and max script size. Doesn't touch dust, opreturn or max tx size. See bitcoincashresearch.org/t/non-standard-transactions-out-of-band-miner-submission/1257/10 for discussion."
        },
        {
          "question": "How should exchanges store BCH addresses in database?",
          "answer": "BCA: Personally would store hashes and then generate address for user UX on-the-fly, especially since you may want to support multiple types (BTC legacy, BCH cashaddress, BCH token cashaddress). Addresses work too, just moves encoding/decoding to elsewhere."
        },
        {
          "question": "How would faster block times affect exchange confirmation requirements?",
          "answer": "If BCH magically had 2min blocks before gaining respect/market share, exchanges would likely 5x the number of required confirmations (from 6 to 30). You don't get respect by changing yourself - in business you get respect by being profitable for them. Need to become bigger part of their income first."
        },
        {
          "question": "What are the key SEO factors for improving website rankings?",
          "answer": "Main SEO factors: 1) Avoid AI-generated content (can be detected and downranked). 2) Get organic backlinks, especially from high-authority sites. 3) Consistently update with fresh content (blog section, news). 4) Domain name should match target keywords (e.g., 'BCHEcosystem' vs 'minisatoshi' for 'Bitcoin Cash Ecosystem'). 5) Align metadata tags with content. 6) Distribute links across platforms (Twitter, Telegram, Reddit, Bitcoin Cash Research)."
        },
        {
          "question": "What is BCH reference spec purpose vs howtos?",
          "answer": "BCA/Tom: Reference specification just tells data formats (tx, block, network messages) and consensus & network rules. Implementing or using software that satisfies spec is not part of spec. Reference spec is to be read by implementers of software, not by end users."
        },
        {
          "question": "What is BCH specification repo structure issue?",
          "answer": "Tom: Git repo was made by some people, inherited by other people, copied by several projects to show on their own sites, then maintained by random people sometimes copying between repos. Not ideal, has structure that is in many ways flawed."
        },
        {
          "question": "Which BCH specification repos are actively maintained?",
          "answer": "Dustin: BU accepted PRs (reference.cash) and Flowee took input to update their copy (flowee.org/docs/spec/). Tom's codeberg.org/bitcoincash/specification is most consistently maintained version - tries to find changes others make and pull them in as well as make fixes."
        },
        {
          "question": "Why is assurance contract aspect critical for Flipstarter?",
          "answer": "Key aspect (along with focused window of opportunity) that gives people confidence to pledge large amounts. It all funds or not - prevents falling back to sporadic donations which historically result in very little. Reason for doing this pain in the ass novel thing (copy of lighthouse)."
        },
        {
          "question": "Why use pseudonymity for BCH development?",
          "answer": "You should not use your real name here IMHO, especially if you plan to become a dev. Anonymity or pseudonymity is very useful when doing groundbreaking controversial stuff. Government names created by state - legal fiction they can tax and regulate."
        },
        {
          "question": "How does Ethereum global state pricing work?",
          "answer": "Pat/Jonathan: Ethereum global state is huge RocksDB-based KV database. Storage reads and writes cost extra gas accounted for in tx fees. You can choose what to store and read, don't need to pay for part of global state you don't care about. Individual read/writes don't need to touch rest of it."
        },
        {
          "question": "What is \"perfect is enemy of good\" in BCH context?",
          "answer": "Response to argument that faster blocks don't solve double spend problem in exact logical maxwellian sense - like saying 'bitcoin doesn't solve the double spend problem'. Point is that improvements don't need to be perfect to be valuable. This is true in exact logical maxwellian sense."
        },
        {
          "question": "What is BCH mentorship program for developers?",
          "answer": "Bitcoin Cash University mentorship program at bitcoincashuniversity.com/mentors helps people get involved in coding on BCH. Sign up to help developers new to BCH or veterans."
        }
      ]
    },
    {
      "name": "Protocol Development & Opcodes",
      "description": "Core protocol features, opcodes, CHIPs, and consensus-level improvements including OP_EVAL, loops, VM limits, and network upgrades",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Are sidechains possible on BCH with current tools?",
          "answer": "Yes possible - SPV 2-way peg via OP_CAT (gist.github.com/A60AB5450353F40E/59eee82c5d6e3d989166bb8eaf7826e9). But nobody cares to build them. OP_CHECKSPVPROOF could simplify checking process. Industry moved to ZKPs for sidechains. Unpopular opinion: concept introduced by Core to stop on-chain innovation, always dead-on-arrival. ETH can't scale account-based architecture so L2s devouring L1. BCH doesn't need them yet - base chain power barely put to use."
        },
        {
          "question": "Big math opcodes vs native EC arithmetic for BCH?",
          "answer": "Big math may make EC primitives unnecessary, but native opcodes more efficient. Loops could emulate EC operations but very costly in time and computation. With eval, routine defined once at contract start and reused many times. Can turn loop into chain of 256 TXs with mutable NFT commitment going 255 to 0."
        },
        {
          "question": "Can BCH verify zero-knowledge proofs without a specialized ZKP verifier opcode?",
          "answer": "Yes, BCH can already verify ZKPs using existing opcodes, but it's highly impractical. You'd need to use many different contract inputs to perform the verification. Loops and optimization CHIPs (like OP_EVAL) would make it more practical. However, even with improvements, porting a zkVM's verification might cost ~10,000x typical transaction fees with limited wallet support."
        },
        {
          "question": "Can OP_DEFINE use script from neighboring input as function?",
          "answer": "Yes, BCH Functions CHIP allows defining script pushed as data in neighboring input as function and executing it in context of current script. Can use specially formed OP_RETURN-defined functions as read-only inputs, but that's not in scope - would be future extension."
        },
        {
          "question": "Can SHA256 collision in function identifier cause fork?",
          "answer": "It can cause fork if you don't specify hashing algo used. If you spec it it's fine. Hash collision just turns UTXO with 1 spending path into UTXO with 2 spending paths - whichever preimage spender uses, all nodes see same preimage and evaluate same."
        },
        {
          "question": "Can executable bit requirement be sunset later?",
          "answer": "If we change our mind: can stop caring about bit and just let eval exec whatever. Bit can be sunset. OP_PUSHSCRIPT would become NOP (or OP_PUSHDATA). Just NOP prefix to existing pushes. Once you add function tables etc, you're stuck with that. Best argument so far: if there's path to soft-fork sunset, 'cost' would just be some consumed code points."
        },
        {
          "question": "Do BCH Script opcodes need to be extended to support zero-knowledge proofs?",
          "answer": "No specialized ZKP opcode is strictly necessary. ZK proofs ultimately reduce to polynomial arithmetic which can be implemented using existing BCH Script math operations after the BigInt upgrade. However, a specialized opcode could offer performance advantages. The tradeoff is consensus layer complexity versus efficiency - building with existing opcodes first validates the use case before proposing consensus changes."
        },
        {
          "question": "Does OP_EVAL expand attack surface of BCH VM?",
          "answer": "Not adding anything new VM can't already do - just changing how you can express things. VM not supposed to be designed to protect developers from themselves. Only people who interact with VM are already highly skilled, smart enough to avoid tinkering with things they don't understand with large amounts of money. Attack surface = developers writing bugs, which they can and will do with or without OP_EVAL."
        },
        {
          "question": "Does OP_RUNSUB2 violate the principle that locking code must be known at lock time?",
          "answer": "Yes, in a sense. A P2SH redeem script containing `<0> <0> OP_RUNSUB2` doesn't know what the first input's first subroutine contains when locking funds. However, because code doesn't mix with data in the Subroutines CHIP, you're certain the executed code was present in the transaction you signed when locking the funds on-chain - it's just from a different input."
        },
        {
          "question": "Does the dust limit change with the new VM limits?",
          "answer": "No, dust limit doesn't change with the VM limits. The formula remains: dust limit = 444 + output_size * 3. Some implementations use higher values (800-1332 sats) to allow for worst-case scenarios like old school p2ms."
        },
        {
          "question": "How are BitCANN TLDs and multiple competing registries handled?",
          "answer": "One contract instance per TLD (e.g., .bch has one categoryId, .xyz another). Multiple people could launch competing instances claiming authority over the same TLD, but this is resolved off-chain through reputation. Everyone picks the instance with better reputation and it dominates/snowballs. Similar to how DNS root zones work - technical protocol allows duplicates, social consensus picks the authoritative one."
        },
        {
          "question": "How can BCH scripts have runtime-determined code?",
          "answer": "OP_INPUTINDEX OP_1ADD OP_UTXOBYTECODE OP_EQUAL - code to be ran determined after UTXO creation. Code runs on another input, but that input can spend UTXO created AFTER original input, just to provide correct bytecode in same TX context. UTXO with required locking script created after 'this' input for sole purpose of unlocking it."
        },
        {
          "question": "How can DEX micro-LPs prevent UTXO contention without consensus changes?",
          "answer": "Each micro-LP requires signature from node managing it - prevents competing transactions without requiring same server/entity/contract. Doesn't stop aggregator service combining liquidity, just ensures only valid transactions reach mempool. Can be done today with no CHIP. Pool operator gives you TX, fills in sig, makes sure doesn't sign same UTXO twice - otherwise everyone can do what they want."
        },
        {
          "question": "How can OP_EVAL enable code compression using hash verification?",
          "answer": "Pattern: `<push bytecode from stack> OP_DUP OP_HASH256 <hardcoded hash> OP_EQUALVERIFY OP_EVAL`. This compresses code to a hash in the redeem script, fetching actual bytecode from arbitrary sources (inputs, NFT commitments, etc). The code is kept off-chain until use but can be audited beforehand by revealing the code and verifying it against the hash. This is more flexible than OP_RUNSUB2's fixed subroutine tables."
        },
        {
          "question": "How can custom VMs circumvent OP_EVAL guardrails?",
          "answer": "Convoluted series of OP_IFs is custom VM just for that input, can 'execute' any data as bytecode just as Eval could. Any guardrail on op_eval circumvented by those convoluted ifs since that code wouldn't implement guardrails. Wastes blockspace on custom VM implementations when BCH VM available. Most viable: pure op_eval or nothing."
        },
        {
          "question": "How can users verify complex OP_EVAL optimized bytecode is safe?",
          "answer": "Reproducible builds solve this. If bytecode claims to be compiled from audited CashScript, you can verify: 1) audit the high-level CashScript source, 2) compile it yourself using the same compiler version, 3) compare the resulting bytecode hash to the on-chain hash. If someone provides unauditable complex bytecode - simply don't use it. The Unspent PHI vulnerability shows contracts can break regardless of OP_EVAL."
        },
        {
          "question": "How can web push notifications handle BCH recurring payments?",
          "answer": "Use browser PUSH protocol with bidirectional communication - wallet shows monthly subscription list marked green/yellow/red based on USD/EUR value match. User clicks \"Confirm and Pay All\" once verified. No oracles, NFTs, opcodes, or contracts needed. Just communication protocol + UI + send coins."
        },
        {
          "question": "How do MAST merkle proofs work for Functions CHIP?",
          "answer": "If have 20 functions in balanced tree and want to use one for define/invoke need: root hash and 4-5 additional hashes to prove leaf within tree. If redeem script using ten functions: 1 root hash and 40-50 additional hashes. Would have specific merkle root for functions your utxo uses."
        },
        {
          "question": "How do VM Limits prevent DoS attacks with OP_EVAL?",
          "answer": "VM Limits maintain an execution budget that tracks every operation executed. When the budget is depleted, the transaction becomes invalid. EVAL'd scripts are verified and evaluated the same way as normal scripts, bounded by the parent program's VM limits. This prevents scripts from running continuously or consuming excessive resources, whether they use OP_EVAL or not."
        },
        {
          "question": "How do relay rules relate to consensus in BCH?",
          "answer": "Relay rules and standardness are not technically consensus, but pseudo-consensus. Nobody can just assert what network will do, and some changes have real impact. Deserve as much thought as consensus CHIP. Can either move into consensus (like transaction version CHIP) or move out (remove rule, like P2S proposal)."
        },
        {
          "question": "How do you manually connect to a BCH node and send messages via p2p protocol?",
          "answer": "P2P handshake sequence: A sends 'version', B sends 'verack', B sends 'version', A sends 'verack'. Example version message hex: 'e3e1f3e876657273696f6e00000000005f00000020e7d3e4...'. Can use tools like nc (netcat) but requires proper message formatting. The protocol is more than just version message."
        },
        {
          "question": "How do you monitor BCH address balance changes using the Electrum protocol?",
          "answer": "Use blockchain.scripthash.subscribe to be notified about state changes (gives current state, then updates for new 0-conf payments and first confirmation). The notification doesn't include balance details, so call blockchain.scripthash.get_balance after notification. You must also understand and use server.ping to maintain the connection. See electrum-cash-protocol.readthedocs.io for Protocol Methods and Protocol Basics."
        },
        {
          "question": "How does 10^x exponentiation work in BCH Script?",
          "answer": "Jonathan/Mathieu: With loops exponentiation will get trivial! Just <10> OP_MUL then reduce counter or some such until done. BCA optimized version saves 30 bytes using binary decomposition approach. Can't believe getting so much power is only 8 months away (May 2026 upgrade)."
        },
        {
          "question": "How does BCH VM limits prevent infinite loops?",
          "answer": "Mathieu/BCA/Tom: VM limits CHIP already set hard limit to ops per input - loops can't exceed it, if they try tx will be invalid. Each byte gets 800 compute budget, different opcodes have unique opcost. Loop terminates with failure when script runs out of compute budget. Loops don't need exits, not BASIC-style GOTO."
        },
        {
          "question": "How does Electrum protocol status hash work for BCH?",
          "answer": "Used for blockchain.address.subscribe - returns status hash and emits on each update. Can cache with history + unspents to avoid refreshing each subscribe. Confirmed TXs come back with CTOR, unconfirmed sorted by height/increasing value/ascending hash. Status based on that order. State hash super expensive on server side - room for optimization if clients don't use it. Just compare to previous hash to check for update."
        },
        {
          "question": "How does executable bit add extra dimension to stack?",
          "answer": "Instead of 'OP_EVAL pops top item and executes as bytecode' you have 'OP_EVAL pops top item and executes as bytecode UNLESS top item has been result of OP_ADD, OP_SUB, OP_MOD...'. Adding extra dimension to stack - all complexity has been squared. It's just 1 bit: stack opcodes preserve it/pass it on, all other opcodes clear it. Same how OP_VERIFY cares about value of item, doesn't care HOW it got value."
        },
        {
          "question": "How does stack overflow relate to OP_EVAL safety concerns?",
          "answer": "Stack overflow bugs break code/data separation by making data executable, causing millions of security vulnerabilities historically. Critics argue OP_EVAL creates similar risks by mixing code and data. However, BCH Script already allows 'dangerous' contracts, and OP_EVAL can be implemented consensus-safely with no undefined behaviors. Individual contracts can be broken by misuse of any opcode - OP_EVAL doesn't fundamentally change this risk profile."
        },
        {
          "question": "How should OP_DEFINE and OP_INVOKE count as hashing operations?",
          "answer": "From VM Limits chip: Hashing operations add 1 + ((message_length + 8) / 64) to nHashDigestIterations, and nOpCost += 192 * iterations. Might need to salt identifier for each transaction input to avoid anyone ever finding arbitrary SHA256 collision that could cause fork."
        },
        {
          "question": "How to track BCH contract TVL and transactions like tokenaut.cash?",
          "answer": "Depends on particular contract - some have OP_RETURN markers, some have constant address, some can be tracked by NFTs that they emit. FBCH 'savings club' tracker is open source with protocols using OP_RETURNs listed at github.com/2qx/future-bitcoin-cash/blob/main/packages/lib/src/extra.ts."
        },
        {
          "question": "Is OP_DEFINE_VERIFY wasteful for saving 3 bytes?",
          "answer": "Jonas thinks wasteful to reserve opcode for saving 3 bytes for some use cases. Validating unknown code with hash is just one way of trusting external code - another might be validating specific NFT is used as input or code is signed by known pubkey."
        },
        {
          "question": "Is OP_EVAL dangerous for BCH contracts?",
          "answer": "The danger of OP_EVAL is debated. Critics cite 'mixing code and data' concerns from other contexts. Proponents argue: 1) BCH Script already allows writing dangerous contracts without OP_EVAL, 2) nobody is forced to lock funds in risky contracts, 3) OP_EVAL won't affect existing contracts that don't use it, and 4) it's analogous to subroutines in scientific calculators. Compiler complexity increases but doesn't inherently create consensus-level risk."
        },
        {
          "question": "Is the deterministic tiebreaker H(A||B) proposal a consensus change?",
          "answer": "Not a consensus change - blocks satisfy all the same consensus rules. It's like a soft fork but unusual: normally takes HF to undo SF, but here miners insisting on 1st-seen could still have blocks included if they get lucky. Following the 'wrong' policy would lose money, so miners need to know which policy everyone else follows."
        },
        {
          "question": "Should documentation.cash OP_DATA description be updated?",
          "answer": "documentation.cash/protocol/blockchain/script/op-codes/op-data-x.html says 'two's complement integer' for 1-75 byte push. Technically correct (C++ int type is 2s complement in C++20) but confusing since doesn't matter for those numbers. Should say 'unsigned int'. OP_X similar issue. Script numbers are sign-magnitude per wikipedia.org/wiki/Signed_number_representations#Sign-magnitude"
        },
        {
          "question": "What BCHD v0.21.0 updates for May 2025 upgrade?",
          "answer": "BCHD and associated tools (dnsseeder, meep, bchwallet, bchutil) updated and compatible with upgrade on 15th. Added chipnet DNS seeder at chipnet-seed.bchd.cash. meep v0.6.1 fixed Moria v1 TX inspection - just needed quick one liner fix to update flag. See github.com/gcash/bchd/releases/tag/v0.21.0"
        },
        {
          "question": "What CHIPs are planned for BCH's 2026 upgrade?",
          "answer": "The 2026 upgrade plans include Loops, OP_EVAL, and P2S CHIPs. These are still in debate stage. Jason confirmed these make ZK verification and advanced covenants smaller and way cheaper compared to current implementations. The goal is to reduce transaction fees and improve smart contract expressiveness beyond the current state."
        },
        {
          "question": "What Lokad IDs are used by Permissionless Software Foundation protocols?",
          "answer": "PSF uses several Lokad IDs: 0x00504d00 for PS008 Pin Claims (very active) and PS006 Simple Store Protocol (less active, maybe deprecated); 0x00510000 for PS010 IPFS File Pinning Protocol (very active). These protocols enable on-chain claims, data storage, and decentralized file pinning using OP_RETURN markers for protocol identification."
        },
        {
          "question": "What are MCP Servers and how do they improve LLM workflows?",
          "answer": "MCP (Model Context Protocol) Servers integrate tools like firecrawler (AI web crawler) and Brave Browser with LLMs to provide more context in requests rather than crazy chain of prompts. The MCP Server list GitHub repo (github.com/modelcontextprotocol/servers) has 20k stars and offers many integrations for dev workflows."
        },
        {
          "question": "What are alternatives to OP_DEFINE_VERIFY for code verification?",
          "answer": "Calin's take 2 and take 3 alternatives solve GP issue. Can validate external code by checking hash, verifying specific NFT used as input, or confirming code signed by known pubkey. OP_DEFINE_VERIFY is addition not replacement."
        },
        {
          "question": "What are current BCH OP_RETURN limits and restrictions?",
          "answer": "BCH moved OP_RETURN to 220 bytes. Multiple op_returns allowed in single transaction (restriction removed), but total for all must still be 220 bytes or less. See flowee.org/docs/spec/forks/multiple-op-returns-for-bitcoin-cash/"
        },
        {
          "question": "What are read-only inputs and why controversial?",
          "answer": "Read-only inputs: script reads bytecode/data from UTXO without spending it (OP_LIBRARY concept). More controversial than OP_EVAL. Peter Rizun suggested scripts could have read access to whole UTXO state (global read) while writes/modifications TX-local. Concern: write/modification could mess up all readers."
        },
        {
          "question": "What are the bytecode limits after the VM Limits CHIP?",
          "answer": "After VM Limits CHIP, bytecode and stack item length limits are no longer relevant to worst-case validation performance. Standard transactions can reach MAX_STANDARD_TX_SIZE (100,000 bytes). The increased limits on Maximum Bytecode Length and Maximum Stack Element Length apply equally to both locking and unlocking bytecode. Lower per-item limits offer no additional network safety while inconveniencing applications with larger data requirements."
        },
        {
          "question": "What are the concerns about TXv5 increasing locking bytecode limits?",
          "answer": "TXv5 proposes increasing locking bytecode from 201 bytes (P2SH limit) to 100,000 bytes. This data is stored in the UTXO set, raising concerns about UTXO bloat and node resource requirements. However, the 201-byte locking bytecode limit may not be affected - the discussion likely refers to P2SH scriptsig size standardization (10,000 bytes after P2S CHIP removes the 1,650-byte input limit)."
        },
        {
          "question": "What are the concerns with deferred TXID assignment?",
          "answer": "Kills block explorers - can't track TX before mining. 0-conf may not work without TXIDs assigned on spot. Would require consensus change and even then, not 100% sure 0-conf would work. Cannot just get rid of TXIDs and assign when miners mine them - not Nakamoto Consensus anymore."
        },
        {
          "question": "What are the ecosystem costs of consensus changes like block time?",
          "answer": "Consensus changes costly to everyone - lots of hours debugging, writing code, updating servers. Bigger upgrade = harder for companies to start building. Looming massive upgrade causes them to reconsider: 'If we can change this, what else will be changed?'"
        },
        {
          "question": "What are the focus areas for BCHD's 2025 network upgrade implementation?",
          "answer": "BCHD is implementing VM Limits and Big Int CHIPs to ensure full support and compatibility with the May 2025 network upgrade. These consensus changes expand Bitcoin Cash's smart contract capabilities by removing previous VM operation limits and enabling arbitrary-precision integer arithmetic in scripts."
        },
        {
          "question": "What are the main use cases for OP_EVAL according to BCH developers?",
          "answer": "Multiple use cases exist: 1) Jonas: optimize stack manipulation by implementing custom opcodes like OP_UNROLL, 2) MathieuG: compile CashScript functions into executable bytecode with compiler-managed calling conventions, 3) bitjson: compress bytecode by detecting repeating patterns and using CAT/SPLIT to reuse common bytes, 4) bitcoincashautist: commit hashes of code and only provide preimages when needed, saving space."
        },
        {
          "question": "What changed in BCH transaction version 2?",
          "answer": "2qx/Tom: Only change was treatment of nSequence numbers in BIP68. Version 2 was started by soft fork, didn't actually change format but changed interpretation of one field. To use opcode with sequence data in output, you were required to set version number to 2."
        },
        {
          "question": "What content strategy improves SEO for cryptocurrency websites?",
          "answer": "Combine evergreen static content with regular fresh updates. Evergreen examples: fork history maps, ecosystem links pages (get tweaked but persist). Fresh content: blog section with BCH news, commentary on developments, links to foundation/podcast content. Successful sites have both: stable resources that build authority over time, plus semi-regular new content that signals active maintenance to search engines."
        },
        {
          "question": "What documentation sources recommended for BCH developer chatbot training?",
          "answer": "CashScript docs, libauth docs, Electron-Cash protocol, SoftwareVerde bitcoin-cash-specification, BCHN announcements, documentation.cash, all CHIPs, bitcoincashresearch.org, cashtokens.org, mainnet.cash, flowee.org/docs/spec/, upgradespecs.bitcoincashnode.org, BitcoinCashPodcast.com/faqs. Mastering Bitcoin and Mastering Bitcoin Cash already added."
        },
        {
          "question": "What does 'safety' mean in the context of BCH Script contracts?",
          "answer": "Two levels exist: 1) Consensus/VM safety: code can't damage the VM (like making your computer 'go up in flames'). This is handled by VM Limits. 2) Fund safety: preventing people from spending your money without your intent. Critics argue OP_EVAL compromises fund safety by allowing runtime code generation. Both levels are important, but they address different concerns."
        },
        {
          "question": "What does emergence of AlbaVM say about BCH development?",
          "answer": "Amazing thing about BCH peacefully and consistently putting out good work: we have no visibility on continually emerging set of new things bubbling in background. Both from existing and new teams. Every specific topic in BCH has its own active channel and active community. There aren't many crypto projects with so many different channels - BCH is serious business, unlike many cryptos."
        },
        {
          "question": "What is 95% alternative to OP_EVAL proposal?",
          "answer": "Locally defined immutable OP_EVAL - can only operate on input-defined blobs, blob can't be mutated if going to get op_eval'ed. Literal op_eval but must be defined locally and can't be mutated. Going to more pro tool like eval easy moving forward, basically impossible to move back. Gray area preference."
        },
        {
          "question": "What is BCH script number encoding vs C++ encoding?",
          "answer": "Stack items use script numbers (sign+magnitude encoding). OP_X and OP_DATA_X documentation says 2s complement but numbers 1-75 work with any signing method. Numbers never put on stack - that's at different layer of script bytecode interpretation. In other places it's C++ numbers (uint/int) or custom unsigned varint encoding. C++20 requires 2s complement for signed integers."
        },
        {
          "question": "What is BitVM challenge setup for BCH ZK-rollups?",
          "answer": "BitVM provides native level of verification for commitment proofs with far less trust setup required. Challenges to commitments could come in as late as 1 week or more per Ekrem Bal's OP_Next talk. Current staking models assume there isn't an equivalent on BCH yet."
        },
        {
          "question": "What is Jerry's native elliptic curve arithmetic CHIP?",
          "answer": "Proposal for ECADD and ECMUL opcodes (bitcoincashresearch.org/t/1570). Enables native ZKP verification rather than relying on OP_CHECKDATASIG attestation. Needed for Bulletproofs, Groth16, SNARKS/BLS verification, field inversion, curve equation checks. Emulating with loops computationally expensive - must verify points lie on y2=x3+7 (mod p) secp256k1."
        },
        {
          "question": "What is OP_DEFINE_VERIFY shorthand proposal?",
          "answer": "OP_DEFINE works on any stack element no matter where it came from. Adding extra <hash> <index> OP_DEFINE_VERIFY is shorthand for OP_DUP OP_HASH256 <hash> OP_EQUALVERIFY <index> OP_DEFINE. Allows verification with hash while keeping normal OP_DEFINE for other use cases."
        },
        {
          "question": "What is OP_PUSH_EXECUTABLE proposal for static analyzability?",
          "answer": "Stack items marked executable only if pushed verbatim with OP_PUSH_EXECUTABLE. If modified (OP_ADD etc.) item loses executable bit, becomes data blob. OP_EVAL can only execute items with executable bit. Keeps static analyzability while allowing unverified code execution if script author chooses. However can be circumvented by implementing VM within VM."
        },
        {
          "question": "What is Tom's subroutines CHIP approach to OP_EVAL?",
          "answer": "Alternative to OP_EVAL using OP_RUNSUB2 and OP_DEFINESUB. Transaction creates multiple outputs that work together if spent in one transaction later - they share same prev txid. Separates code from data. Locking script requires certain unlocking script by hash - code executed in VM known at time output was mined. See bitcoincashcode.org/bitcoincash/CHIP-subroutines"
        },
        {
          "question": "What is a Turing tarpit and how does it relate to Bitcoin Script?",
          "answer": "A Turing tarpit is a system that is theoretically Turing-complete but practically useless due to extreme inefficiency. The original Bitcoin Script VM inherited by BCH was essentially a tarpit - not even Turing complete and missing basic operations like MUL, forcing repeated ADD operations instead. It's like a calculator without multiplication. BCH has been progressively escaping this tarpit with VM upgrades."
        },
        {
          "question": "What is central bank confiscation concern with OP_EVAL?",
          "answer": "Oracles today have power over funds, but only select from 2+ possible outputs pre-designed in output script when mined. Master key signature for arbitrary bytecode makes central bank style confiscation possible. If code being signed is malicious, writer has huge advantage - days to adapt to unmoving target to get script to say 'yes' for sending to themselves."
        },
        {
          "question": "What is chipnet anyone-can-spend faucet address?",
          "answer": "2qx/Kallisti: P2sh20 base58 address for <42> OP_NUMEQUAL is 2N28ZR5MgBoKq6sBceEoGvTuGs1wfZeXvFF. Kallisti mining chipnet to this address so anyone can claim coins after 100 blocks. Put coins there and took them from playground with require(answer==42) spending script."
        },
        {
          "question": "What is compromise approach with OP_EVAL and executable bit?",
          "answer": "EVAL + special push as compromise doesn't close off any future paths, still gives all nice benefits of Eval while mitigating 'we don't know what gets executed' problem. If declare some NOP as OP_PUSH_EXEC, then if one day wiser and decide to just allow Eval to run anything - can make that decision without much technical debt. Lose some benefits like cross-input compression, but if blobs all explicit then can do compression on another layer."
        },
        {
          "question": "What is covenant recursion path for AMM without consensus change?",
          "answer": "Covenant recursion could be path forward for AMM without changing consensus. Plus 2026 upgrades help even more with looping. See github.com/bastiancarmy/bitcoin-cash-trustless-defi-recursion. Needs solid peer review. Basic problem still there regarding mempool transactions pre-mine."
        },
        {
          "question": "What is debate about OP_EVAL code verification?",
          "answer": "OP_EVAL executes stack items as code. Locking script can verify with OP_DUP OP_SHA256 <hash> OP_EQUALVERIFY OP_EVAL but not required - script author's choice. Concern: allows anyone-can-spend if just OP_EVAL without verification. Counter: people can write anyone-can-sweep P2S/P2SH anyway. Separation of code/data vs primitives debate."
        },
        {
          "question": "What is locally defined immutable compression requirement?",
          "answer": "Code/data package locally defined and immutable - 'code was known at time money was locked in'. Serves local code compression use case. Tom's subroutines CHIP achieves this using P2SH principles. Prevents someone seeing locking script from writing matching code to unlock. Some argue guardrails could be circumvented (VM within VM) making them obstacles."
        },
        {
          "question": "What is master key signature pattern for OP_EVAL?",
          "answer": "Lock funds into: OP_TUCK <pubkey> OP_CHECKDATASIGVERIFY OP_EVAL. Unlock with: [...data] <sig> <bytecode> <redeem>. Executes script if signed by certain key. Change multisig logic, add oracle requirements, need script signed as master key. This type of system possible TODAY with VM limits activated. Can let admin approve alternative spending methods after UTXOs created."
        },
        {
          "question": "What is real benefit of OP_EVAL beyond bytecode compression?",
          "answer": "Not just 'less bytes on blockchain' - enables new category of applications: cryptography on stack and ZKPs in script which wouldn't be possible to express within VM limits without 100x to 1000x compression enabled by EVAL. These complex contracts simply would not be possible without compression."
        },
        {
          "question": "What is real use case for OP_EVAL modularity?",
          "answer": "Oracle multi-input contract sometimes needs checks, sometimes doesn't. If does need checks, require extra checks done by another input (authed by hash) - lot of overhead verifying other input checks same data as *this* input, plenty footguns. Way simpler if provide module as *this* input's push only when needed, easier to secure."
        },
        {
          "question": "What is relay vs consensus rules gap issue?",
          "answer": "Standardness rules (relay) vs consensus creates complexity. CashScript docs have 5 occurrences of 'standardness': max contract size, max tx size, max opreturn size, dust threshold, output standardness. Proposal: 'great standardness cleanup' - make relay limits consensus or remove gap. Risk-averse approach: make relay limits consensus. Case-by-case convergence needed."
        },
        {
          "question": "What is risk tolerance difference in OP_EVAL debate?",
          "answer": "Different risk analysis: one side says 'realistically, is this creating fresh pitfalls likely to cause large issues' = no, because most usage by experts or abstracted, time/experience helps develop templates. Other side: even with tooling, look at exploits/0-days in mature C++ ecosystem - why create additional risk when 80-90% achievable without it? Last 10% effectively free if ever comes to that."
        },
        {
          "question": "What is sharp knives argument for OP_EVAL?",
          "answer": "OP_EVAL doesn't let you do anything outside BCH VM instructions - just compression. Cryptocurrency can't avoid scams from growth. If bad dev, can always lose money through misconfiguration. Devs choosing OP_EVAL volunteer for risk. ETH blow-ups from Solidity bugs, not EVM itself. Can't prevent incompetent devs."
        },
        {
          "question": "What is sharp knives philosophy for OP_EVAL?",
          "answer": "OP_EVAL doesn't let you do anything outside BCH VM instructions - just about compressing bytes. Bad devs can always lose money through misconfiguration. Can't prevent that. Devs choosing OP_EVAL do so knowingly - if not confident, don't use it. Compilers/tools handle complexity, not humans hand-coding hex. All about byte compression, not new capabilities."
        },
        {
          "question": "What is static analyzability debate with OP_EVAL?",
          "answer": "Processing code to create 'complete' code requires execution or sophisticated analysis due to: loops, mutable code/data blobs (eval executes from stack), recursion, combinations. Nothing prevents VM implementation inside VM that reads blob and interprets as opcodes. OP_PUSH_EXECUTABLE doesn't prevent this - guardrails become obstacles if circumventable."
        },
        {
          "question": "What is the Merkle Header Commitment (MHC) CHIP?",
          "answer": "MHC CHIP (gitlab.com/0353F40E/mhc, bitcoincashresearch.org/t/chip-2025-03-merkle-header-commitment-for-enhanced-spv-scalability/1518) adds merkle commitments to block headers for enhanced SPV scalability. Computational cost is negligible: ~20 hashes per block, because leaves are added to a sorted list so only the right edge branch needs recomputing. Placement options discussed: last output for compact proofs vs OP_RETURN prefix for future extensibility."
        },
        {
          "question": "What is the OP_RETURN scanner and how does it work?",
          "answer": "The OP_RETURN scanner (opreturn-scanner.netlify.app, github.com/mr-zwets/opreturn-scanner) finds all occurrences of specific opreturn markers (lokad-ids) on-chain. For example, searching for 'BCMR' finds 3417 txids. The tool promotes using markers for on-chain protocol/smart contract apps as a great place to store contract details, enabling discoverability without centralized indexers."
        },
        {
          "question": "What is the difference between soft forks and hard forks from a practical perspective?",
          "answer": "The soft/hard fork distinction was arguably an excuse to create a nonexistent problem. In some situations, hard forks are far better - less headache, cleaner, and less complicated than soft forks. The key is ensuring everyone is aboard through a reasonable process like CHIPs, which can continuously improve through discussion. BCH has demonstrated that coordinated hard fork upgrades work well when properly managed."
        },
        {
          "question": "What is the op_1 UTXO sweeping attack vector?",
          "answer": "UTXOs at address prdpw30fk4ym6zl6rftfjuw806arpn26fv8cp7wyl3 can be spent with input script 0x81. If miners automatically swept these and ignored user TXs spending them, it gives anyone a way to set up double-spend: send to op_1 address then race miner's sweep against your own spend to victim."
        },
        {
          "question": "What is the purpose of bytecode compression with OP_EVAL?",
          "answer": "Compilers can use heuristics to detect repeating executable byte patterns and maximally compress Script when compiling from high-level languages. CAT/SPLIT operations on eval'd bytecode enable reusing common bytes and appending bytes to match non-optimized code. All eval-scripts are 'trusted' and hard-coded as data pushes in locking bytecode. The Subroutines CHIP focuses on IDE/NPM-like repositories for importing third-party bytecode."
        },
        {
          "question": "What is the relationship between nSequence and OP_CHECKSEQUENCEVERIFY (CSV)?",
          "answer": "Setting nSequence in a transaction input enforces relative locktime at consensus level - the input must age before the transaction can be mined. However, without additional restrictions, a spender can set any valid nSequence value up to the UTXO's age. CSV (or introspection) restricts what nSequence value can be used in the spending transaction, enforcing minimum locktime requirements. CSV essentially creates 'timelocked covenants' that existed before introspection opcodes."
        },
        {
          "question": "What is the timeline and adoption requirement for TXv5 on BCH?",
          "answer": "Jason stated TXv5 won't happen in 2027 and he won't push for it unless BCH becomes a Top 10 coin. At that ranking, BCH can justify forcing integrated services to upgrade rather than drop support. The CHIP will be ready if BCH reaches that position. If not, TXv5 can wait. Meanwhile, 2026 upgrade plans include Loops, OP_EVAL, and P2S CHIPs."
        },
        {
          "question": "What is user protection strategy for OP_EVAL contracts?",
          "answer": "Users protected same way as from dodgy code - by avoiding niche services, devs they don't trust, or projects that lost user money. Users second-order effect of devs (or third-order after compiler devs). Wallets can have default 'never trust OP_EVAL' or 'only if local compression' policies. Script devs downstream of compiler devs."
        },
        {
          "question": "What is vegabch daemon mode and what are MoriaV0 commands?",
          "answer": "Vegabch beta introduced daemon/server mode to improve performance by maintaining program state for minimal-delay command responses. MoriaV0 commands enable interaction with the Moria lending protocol: mint (create loans), repay (pay back loans), liquidate (close undercollateralized positions), and redeem (withdraw collateral). This CLI tool provides programmatic access to BCH DeFi protocols."
        },
        {
          "question": "What malleability did BCH fix vs what remains?",
          "answer": "BCA: We fixed 3rd party malleability when we implemented BIP-62 stuff in consensus. But 1st/2nd party malleability is still possible. Recipient can't do it - he'd be 3rd party without one of privkeys. XMR doesn't even have script multisig, so nothing to malleate."
        },
        {
          "question": "What prevents rigorous testing and formal verification with OP_EVAL?",
          "answer": "OP_EVAL allows code pushed in unlocking scripts to execute without being committed to in advance. This means: 1) code isn't known when money is locked, 2) the same contract call can execute different code based on runtime data, and 3) test cases can't exhaustively verify all possible code paths. Traditional opcodes have well-documented behavior with testable inputs/outputs. OP_EVAL breaks this model by allowing runtime code generation."
        },
        {
          "question": "What standard for BCH consensus changes regarding benefits vs risks?",
          "answer": "Benefits must be concrete, risks allowed to be hypothetical. Reverse NOT acceptable. This approach for BCH consensus where it's one-way street, changes only come on order of years, mistakes can be very costly. Very high value + very low risk = high bar for consensus changes."
        },
        {
          "question": "When did BCH get covenant capabilities and how have they evolved?",
          "answer": "BCH has had covenants since 2018, became easy to use in 2022. In 2023, CashTokens brought persistent state to covenants, enabling them to communicate with each other and provide compact proofs. The 2025 upgrade (BigInt/VM Limits) enables more advanced crypto in single inputs, with Lamport signatures as a starting point. Loops and optimization CHIPs in 2026 will make advanced cryptography more practical."
        },
        {
          "question": "Why is BCH not big enough for payment protocol adoption?",
          "answer": "If BCH made perfect protocol it would be ignored - just not big enough. Some big ones (MS/FB/Google/Coinbase) needed to sponsor these things before it happens. Unfortunate problem in today's world. Sad BCH not the one to design x402 protocol - would bring PR for Money for the Internet."
        },
        {
          "question": "Why is OP_CAT considered essential for Bitcoin VMs?",
          "answer": "CAT and SPLIT are super useful features in concatenative languages like BCH Script (a Forth dialect). A Bitcoin VM without OP_CAT is like Unix without cat command, or a farm with a mouse problem - tough to take seriously. These operations are fundamental to the concatenative programming paradigm that BCH Script is built on."
        },
        {
          "question": "Why is SLP on BTC risky despite relaxed OP_RETURN?",
          "answer": "Platform risk: BTC changed OP_RETURN limit before, killing token protocols. Not first time - used to be bigger. Most token use-cases impractical once TX fees over $0.10 USD. Better to stick with BCH for network effects (Paypal & Thorchain) and lower platform risk. See cashstack.info/docs/global-back-end/slp-indexer/why-slp"
        },
        {
          "question": "Why is cross-network compatibility limiting for BCH?",
          "answer": "Multicoin world exists but blockchain-agnostic = adapted to lowest common denominator of BTC forks. Limits using BCH-specific features. Being latecomer to BCH features means lagging knowledge when BCH takes off - fewer opportunities while others racing ahead."
        },
        {
          "question": "Why is risk model different for BCH VM than generic programming?",
          "answer": "Risk model of generic programming language vs BCH VM that handles trillions of ounces of gold in value are different at practical level. Like telecoms use Erlang - average developer doesn't use that, but reason specialists use different tools. Yes Javascript probably already handles trillions in value, but through custodial databases that get rolled back/edited all the time. Our risk context is different."
        },
        {
          "question": "Why is unhashed eval code fundamentally safe?",
          "answer": "It's all just sequence of bytes that unlocks UTXO. A script OP_ADD OP_EQUAL can already be unlocked with OP_0 OP_0 OP_0. Contract either is or isn't secure - can either be unlocked by unpredicted bytes in unintended manner or can't. Function eval changes nothing in that regard. Extreme hand holding would remove whole script system and only allow P2PKH."
        },
        {
          "question": "Why is zkVM verification currently impractical on BCH?",
          "answer": "Porting zkVM on-chain verification to 2025 BCH VM requires extensive workarounds. Even if implemented, every protocol interaction might cost ~10,000x typical BCH fees with extremely limited wallet support. Additionally, constraint differences encourage sub-optimal ZK constructions versus systems designed without program length concerns. This makes even non-workaround work potentially a technical dead end for production use."
        },
        {
          "question": "Why local-only OP_EVAL creates bugs and hurts scalability?",
          "answer": "Input local means define function inside transaction you're using it in. Creates bugs: 1) Used space against TX VM limits wish could have outsourced, 2) Might have made mistake copying it in, 3) Same data duplicated over and over is huge efficiency loss against blockchain as a whole, which hurts scalability. Compiler selecting code from library vs local contract compression - but local has major downsides."
        },
        {
          "question": "Why was OP_EVAL originally rejected in Bitcoin in 2011?",
          "answer": "Mike Hearn argued OP_EVAL invalidated security assurances and put Bitcoin 'back at square one' without clear benefits. However, this argument has weaknesses: Bitcoin had critical bugs after 2011 (duplicate TXIDs, DB migration, supply cap bug), yet later additions (P2SH, CHECKLOCKTIMEVERIFY, BCH upgrades) had no issues. Transaction compression saves bandwidth (not just disk), and infrastructure operators care about efficiency even if lightweight clients don't."
        }
      ]
    },
    {
      "name": "Smart Contracts & Covenants",
      "description": "Contract development, covenant patterns, introspection, CashScript, and contract architecture best practices",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can BCH Script be considered Turing complete and what does that mean for ZK implementations?",
          "answer": "If a scripting language is complete, it can express any program. BCH Script can be seen as another Forth dialect. The issue with zkVM on BCH isn't whether it's possible (theoretically it is), but practicality: incredible inefficiencies in contract code requiring workarounds for input limits. Implementation without deep ZK knowledge risks subtle errors like nonce reuse in ECDSA. Simply mirroring Solidity functions isn't enough."
        },
        {
          "question": "Generic vs specific contract discovery for BCH wallets?",
          "answer": "Generic approach (works for any contract) has privacy impacts, stores more on-chain, limited by complexity. Tom's take: won't get nice UX as long as generic. Best approach: actual products appear, contract devs work with front-end devs in specific wallets. GUI and code for one/two contracts together can find TXs easily. Some systems want to be discoverable - SORTS gives standard."
        },
        {
          "question": "How can you broadcast a raw transaction directly to a BCH node?",
          "answer": "Use Bash script with p2p protocol handshake (github.com/A60AB5450353F40E/f408a7cc0df4ee2a609dd2229e14557c). Complete the version/verack handshake, then send TX message. AI tools like Grok can help generate the bulk of the script but require some tinkering to work correctly."
        },
        {
          "question": "How can you use raw transactions with CashScript ecosystem?",
          "answer": "Can manually create contract artifact (without CashScript language/compiler) to use TransactionBuilder and mocknet environment integrated with BitAuth IDE. Cashlab (github.com/hosseinzoda/cashlab) uses straight bitauth templates and has tests. See next.cashscript.org/docs/guides/optimization#overwriting-the-artifact for overwriting artifact details."
        },
        {
          "question": "How do MEV contracts work on BCH?",
          "answer": "Hundreds of users with unspent.cash perpetuity get paid monthly - contract stipulates minimum payment but leaves small gas fee for anyone to claim. Monthly installment transactions built by anyone, not authenticated with signatures, only introspection logic. Dozens of contracts like that with hundreds of permutations. bitcoincashresearch.org/t/a-cataloge-of-miner-extractable-value-mev-on-bitcoin-cash/1616"
        },
        {
          "question": "How do NFT-controlled subscription pulls address price changes?",
          "answer": "Jonas's design: NFT controls amount corpo can pull - they need approval to raise rate by requiring new NFT issuance. Individual contract per subscription also addresses this, but bag of subscriptions is less manual."
        },
        {
          "question": "How do ZK proofs prevent miners from stealing withdrawals?",
          "answer": "The recipient address is used as input into the proof generation, effectively hardcoding the withdrawal destination. When the proof, recipient address, nullifier hash, and merkle root are sent to the contract, changing any of these makes proof verification fail. The verification process uses all these inputs together with the proof, preventing address substitution."
        },
        {
          "question": "How do anyone-can-spend subscription contracts enable MEV?",
          "answer": "Anyone with phone can make little money executing regular payments from public anyone-can-spend subscription contract. Hyper-redundant non-guaranteed method works because if one of 5B+ people with phones can make few thousand sats submitting transaction, chances are good few people might try."
        },
        {
          "question": "How do pull-based BCH subscription vaults work?",
          "answer": "User locks funds in vault and issues NFTs allowing service to pull certain amount at interval. NFT revoke is like revoking debit card, insufficient vault funds like insufficient bank balance. Analogous to current subscription flow but with cryptographic controls."
        },
        {
          "question": "How do wallets find UTXOs spendable by NFTs they own?",
          "answer": "Wallets scan for hash of script bytecode using Electrum. If you have tokenid=x with commitment=y, wallet generates standard script, hashes it, queries Electrum server to find whatever is spendable with tokens in wallet. Scan for P2SH that uses that script. Same principle as querying P2PKH and P2SH multisig for bunch of HD addresses. Wallet needs code to know fingerprint and how to generate hash from key or NFT."
        },
        {
          "question": "How do you debug P2SH script failures in BitAuth IDE?",
          "answer": "For complex scripts with evaluation errors, need to cross-check against authentication-template-v0.schema.json. Naming convention and structure leads to failure. Common issue: stack evaluating to empty instead of 1 (or non-0). Can manually create contract artifact without CashScript compiler to use TransactionBuilder."
        },
        {
          "question": "How do you handle the NULLFAIL rule with OR operators in CashScript checkSig?",
          "answer": "The NULLFAIL rule (BIP-146) makes failed checkSig fail the entire script rather than returning 0. For 'require(checkSig(userSig, seller) || checkSig(userSig, refere))', the first checkSig with wrong signature errors instead of continuing. Solution: use two signature parameters - 'function release(sig sellerSig, sig userSig)' then pass '0x' for the unused sig (e.g., '0x, userSig' when user sweeps; 'sellerSig, 0x' when seller sweeps)."
        },
        {
          "question": "How does Anyhedge contract fingerprinting work?",
          "answer": "BCA: Each anyhedge contract has different address due to specific contract parameters, but they all have same fingerprint because executable part of bytecode is same for all. If Bob knows exact contract he can look it up on electrum using script hashes."
        },
        {
          "question": "How does BitCANN's domain registration system work on BCH?",
          "answer": "BitCANN implements an Unstoppable Domains/ENS-like protocol using BCH covenants. It represents one of the most complex BCH Script systems built, using nSequence, CSV, and introspection to manage decentralized domain ownership and renewals. The system enforces registration periods through relative locktimes, allowing trustless domain management without centralized control."
        },
        {
          "question": "How does executable bit proposal enable static analyzability?",
          "answer": "Explicit executable push (and inheritance rules so can't be mutated but can be shuffled/dup'd/dropped) means script author can't hide that script is more complex than it seems. Parse script, extract all executable pushes, count number of evals - that'll tell you max complexity of contract. Authors could write exotic contracts with lots of small blobs shuffled and executed in combinations, but you'd immediately know something is sus."
        },
        {
          "question": "How does function visibility work in BCH Script contracts?",
          "answer": "BCH Script has no concept of public/private functions - all functions can be called by anyone. Unlike Solidity's access modifiers, you must explicitly lock down function capabilities within the contract logic itself. Use require statements and signature checks to restrict who can execute specific contract paths. This is a fundamental difference from account-based smart contract platforms."
        },
        {
          "question": "How does nSequence enforcement work with signatures vs covenants?",
          "answer": "Three scenarios: 1) Pre-signed transactions: the signer chooses nSequence, signature covers it, recipient can't change it. 2) Full control (P2PKH): user can set any valid nSequence (0 to UTXO age), field is enforced but value isn't fixed. 3) Partial control (covenants): script enforces minimum nSequence via CSV or introspection (require(tx.inputs[N].sequenceNumber == minWaitTime)). Consensus always enforces whatever nSequence value is present; script limits what can be set."
        },
        {
          "question": "How does state management differ between BCH Script and Solidity?",
          "answer": "BCH uses UTXO architecture instead of account-based state. There's no equivalent to Solidity's receive() function that triggers on payment. Contracts don't maintain internal state like structs. Instead, state is 'sharded' using NFTs - each state element becomes a separate UTXO. To track deposits, contracts mint NFTs with user data stored in the NFT commitment field. Listen to indexers for receiving events rather than contract-internal triggers."
        },
        {
          "question": "How does the Subroutines CHIP ensure code safety compared to OP_EVAL?",
          "answer": "Subroutines separate code from data by: 1) requiring exact code to be known when transaction is mined, 2) only executing unlocking script code after formal verification by locking script (like P2SH hashes), and 3) allowing rigorous testing with defined inputs/outputs like opcodes. OP_RUNSUB2 can call code from other inputs, but because code doesn't mix with data, you're certain it's code from the transaction you signed when locking funds."
        },
        {
          "question": "How should contract safety be evaluated in BCH Script?",
          "answer": "Low-level languages (assembly, C, BCH Script) are inherently 'dangerous' in that bugs can cause fund loss. High-level languages like CashScript provide safer abstractions. Contract risk assessment should focus on: 1) specific attack vectors rather than general 'danger' claims, 2) compiler and testing rigor, and 3) recognizing users choose to lock funds in contracts. New opcodes like OP_EVAL don't inherently make safe contracts unsafe."
        },
        {
          "question": "How should introspection opcodes handle read-only inputs to maintain backward compatibility?",
          "answer": "Current introspection opcodes should be made to fail if they try to read a read-only input. A new set of opcodes would be needed to access read-only input data. Otherwise, old contracts could be fooled by unexpected read-only inputs they weren't designed to handle. This prevents security issues with existing contracts when read-only inputs are introduced."
        },
        {
          "question": "How should untested BCH contracts be shared?",
          "answer": "Write contracts as // comment, // op_code, CashScript triples for more folks to review. Easy to correct mistakes and track reasoning on BCR. If you leave mistake in contract, you'll start seeing it copied elsewhere by people and AI. Contracts are meant to find directional bearings on paths to take."
        },
        {
          "question": "How to fund CashScript contract initially?",
          "answer": "Contract.address gives address to fund. Send to that address on correct network (chipnet vs testnet4 vs mainnet). Use Contract.address will give you the address you need to fund. Note you are on chipnet so make sure sending with chipnet funds rather than mainnet. Can call contract.getBalance() and getAddressUtxos() to check."
        },
        {
          "question": "How to get MTP-corrected current time for BCH contracts?",
          "answer": "Get 13 most current headers, decode and calculate value according to spec. MTP is not meant to relate to current time - by definition it lags behind real time for ~1hr. OP_TXLOCKTIME in contract uses nLocktime set on transaction level, checked against MTP per STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE | LOCKTIME_MEDIAN_TIME_PAST."
        },
        {
          "question": "What BCH development patterns emerge from AlbaVM release?",
          "answer": "Developer had no history, joined 3 days ago, initial drop was an hour ago. Makes you wonder how long this has been in works, when it started. Love it when people come out of nowhere to just drop cool work like this. Asked at last years BLISS if CashScript could be made to create formal validation work - this provides way to do things on much more strict way."
        },
        {
          "question": "What CashScript version fixes and network issues?",
          "answer": "Use cashscript@next (npm install cashscript@next) for updated default chipnet server and ElectrumNetworkProvider fixes. Chipnet vs testnet4 confusion: chipnet for CHIP proposals, testnet4 general purpose. Use chipnet by default for less issues. ElectrumNetworkProvider certificate expired - need @next version or custom server. Contract address is hash160/hash256 of unlocking script (P2SH20/P2SH32)."
        },
        {
          "question": "What JavaScript type coercion issues should developers watch for?",
          "answer": "In JavaScript, 'for...in' constructions make the iterator variable a string until converted, which can cause dramatic performance differences. Additionally, 'string + number' can produce unexpected results - \"1\" + 0.5 might become \"10.5\" (string concatenation) instead of 1.5. These type coercion behaviors can prevent JIT compiler optimizations and cause bugs."
        },
        {
          "question": "What are Dutch Auctions and how are they implemented on BCH?",
          "answer": "Dutch Auctions start at a high price that decreases over time until someone buys. Implementation uses timelocking with token-aware contracts (bitcoincashresearch.org/t/unspent-phi-v3-timelocking-token-aware-contracts/1501/3). For cancellation, instead of a separate cancel function (which could race with sales), the seller can trivially 'buy back' many UTXOs in succession through the UI. BIP68 512s units can be used for time restrictions."
        },
        {
          "question": "What are LLM limitations for BCH contract development?",
          "answer": "LLMs really bad at stuff not done thousands of times by others. Also bad when thousands of conflicting ways exist (e.g. Android APIs changing over time). They're language models not world models - can translate ideas to code but get lost with logical structure. Need to give good info first to anchor them, and context fades from beginning."
        },
        {
          "question": "What are P2SH scriptsig size limits after the P2S CHIP?",
          "answer": "The P2S CHIP removes the 1,650-byte input limit. The standardization limit for full P2SH scriptsig becomes 10,000 bytes. This is the effective practical limit after the change. The locking bytecode length limit of 201 bytes for standard transactions remains unchanged - the increased limits apply to unlocking scripts (scriptsig), not locking scripts (scriptPubKey)."
        },
        {
          "question": "What are common mistakes when creating CashToken transaction preimages?",
          "answer": "Common error: forgetting to update 'transaction outputs hash' to include token data in outputs. The token prefix (including PREFIX_TOKEN byte) must be included before the modified locking script. Error 'mandatory-script-verify-flag-failed (Signature must be zero for failed CHECK(MULTI)SIG operation)' often means preimage construction is wrong. The 'modified locking script length' should include both token data and lockscript when present."
        },
        {
          "question": "What are concerns with read-only inputs TXv5 design?",
          "answer": "Current assumption that transaction where any NFT is spent as input and not in output is burnt no longer holds. This might cause serious issues in some current contracts. The idea is half-cooked and design is flawed."
        },
        {
          "question": "What are concerns with untrusted code injection in contracts?",
          "answer": "Introspection fetching code in unlocking transaction means code not guaranteed to come from you. If don't know unlocking code at time of locking, very likely doing it wrong - open to code injection. Locking script visible for all can be brute forced with any unlocking script to find one that unlocks it."
        },
        {
          "question": "What are contract UTXO constraint best practices?",
          "answer": "P2PKH constraint: bill must 'see' signature for hash covering TX contents, signing key hash must match hash in program. With introspection: can codify '50% to address A, 50% to address B'. But if only constrain 50% to A, remaining 50% goes wherever TX creator decides - not constrained means allowed. See bitcoincashresearch.org/t/exploit-and-solutions-for-calculated-outputs/1423"
        },
        {
          "question": "What are problems with centralized AMM serial provider approach?",
          "answer": "Contract using introspection for different input where server adds tagging input/output and client signs their own funds, then server signs after ensuring no split. Problem: central entity could simply not sign and effectively lock up users funds. Withdrawal could still conflict with trade. Not permissionless if permission in form of signature is needed."
        },
        {
          "question": "What are subscription vault funding options?",
          "answer": "Two approaches: 1) One big bag named \"subscriptions\" for all services (semi-manual, risk of corpos pulling too much), or 2) Multiple subscription bags, one per service (basically full manual). Option 1 risks mismanaging money if you don't verify amounts each period."
        },
        {
          "question": "What are the key design considerations for OP_EXEC in BCH Script?",
          "answer": "OP_EXEC should avoid stack pollution by isolating subroutine arguments. A proposed design uses: 1) OP_EXEC1 to execute scripts in the same output by index, 2) OP_EXEC2 to execute scripts from earlier outputs in the same transaction, and 3) OP_SUB_PUSH to define subroutines with argument counts. Subroutines see only their expected arguments on stack. MAST integration allows unlocking scripts to push subroutines to a temp sub-stack that locking scripts can verify and migrate."
        },
        {
          "question": "What are the security risks of mixing code and data in BCH Script?",
          "answer": "Mixing code and data enables: 1) calling functions with identical arguments yielding different results, 2) self-modifying code (exploited in viruses/malware historically), 3) impossible-to-test code paths, and 4) bypassing formal verification. With OP_EVAL, code from unlocking scripts can execute without being verified by locking script hashes (unlike P2SH). This makes contracts 'impossible to keep free from bugs or exploits' according to critics."
        },
        {
          "question": "What are the three scenarios for nSequence enforcement in Bitcoin transactions?",
          "answer": "1) Pre-signed transactions: If given a pre-signed TX with relative locktime, the chosen timelock is enforced (signature covers nSequence). 2) Full control: Using your own P2PKH, you can pick any valid relative locktime (nSequence is enforced but value isn't fixed). 3) Covenant partial control (e.g., inheritance): Script enforces minimum nSequence field. In scenario 2 you had full control so no specific timelock was enforced; in scenario 3 the script limits what you can do."
        },
        {
          "question": "What challenges exist when regex validating file paths in JavaScript?",
          "answer": "Pattern like '^([A-Za-z]:|[A-Za-z0-9_-]+(.[A-Za-z0-9_-]+)*)((\\/[A-Za-z0-9_.-]+)+)$' may validate shorter paths but fail on longer strings. Issues often relate to catastrophic backtracking or quantifier nesting. Testing with tools like regex101.com helps, but JavaScript's RegExp implementation can behave differently than other regex engines."
        },
        {
          "question": "What development tools are available for CashScript?",
          "answer": "An official VS Code extension for CashScript was released in January 2025, replacing the old unofficial extension. It supports all latest CashScript functionality including syntax highlighting, code completion, and integration with the CashScript compiler. This provides a significant productivity boost for BCH smart contract development."
        },
        {
          "question": "What is 2nd-party multisig malleability in BCH?",
          "answer": "BCA: Either of the 2 parties in multisig could re-roll their sig to change txid and disable any descendant tx that requires parent to have exact txid. With BCH covenants child won't depend on exact txid so problem is avoided. P2PKH can only be malleated by whoever has private key."
        },
        {
          "question": "What is 8-byte script number limitation in BCH?",
          "answer": "Numeric opcodes restricted to 8-byte signed 'Script Number' integers (HF-20220515). Excludes value -9223372036854775808 that fits in 8-byte 2s complement encoding but not in 8-byte Script Number (sign-magnitude) encoding. Because we use sign bit, can't represent that 1 value that can usually be represented with 8-byte 2s complement. With '25 upgrade now can operate on that value with bigger integers."
        },
        {
          "question": "What is AlbaDSL/AlbaVM for BCH contracts?",
          "answer": "Haskell-based DSL and VM for Bitcoin Cash 2025 contract programming. Developer joined BCR 3 days ago and dropped cool work. Forked haskoin-core specifically for contracts - might be first Haskell-specific contract system. Provides way to do things in much more 'strict' way. Amazing work that came out of nowhere."
        },
        {
          "question": "What is BCH contract fingerprinting approach?",
          "answer": "gitlab.com/0353F40E/smart-contract-fingerprinting - extracts executable/data segments, generates bytecode patterns, provides confidence scoring. BCHN patterns RPC addition will populate dataElements field for contract type identification. TapSwap example: fingerprint indexed, parameters in OP_RETURN, bytecodePatternAsm from RPC, contractType field available."
        },
        {
          "question": "What is BCHN P2S contract pattern tracking?",
          "answer": "BCA: BCHN merged feature to track P2S contracts. Contract 'pattern' is obtained by stripping data pushes and replacing with number of pushes, 'fingerprint' is hash of pattern. Will find all contracts between different people using same pattern but different keys - very useful to track P2S contracts."
        },
        {
          "question": "What is BitCANN and how does it use BCH smart contracts?",
          "answer": "BitCANN (github.com/BitCANN/contracts) is an Unstoppable Domains/ENS-like protocol for decentralized domain registration on BCH. It represents one of the most complex BCH Script systems built so far, using sophisticated covenant patterns with nSequence, CSV, and introspection to manage domain ownership and renewals. The system uses relative locktimes to enforce registration periods."
        },
        {
          "question": "What is CashScript Arena learning group?",
          "answer": "Telegram group for challenging each other with 'broken' or exploitable smart contracts. Complete beginners welcome - helps with questions of getting started. First challenge only requires setting up programming environment to interact with given smart contract. Experienced people welcome to help create challenges and answer newcomer questions. t.me/CashScript_Arena"
        },
        {
          "question": "What is CashScript bitauthURI method for debugging?",
          "answer": "Create contract and use bitauthURI method of Transaction builder - gives URL to paste in browser and inspect. Use latest 0.11.0-next.3 of CashScript - has scenario generation and multi contract debugging. Use private key you don't use in production."
        },
        {
          "question": "What is DEX contract anyone-can-spend risk?",
          "answer": "BCA: DEX contracts are anyone-can-spend and sometimes contentious spends can happen by accident if multiple users try to interact with same UTXO. Need to be watchful for p2sh in dependency graph when batching user withdrawals."
        },
        {
          "question": "What is OP_DEFINE_VERIFY proposal for code injection?",
          "answer": "OP_DEFINE_VERIFY is shorthand for OP_DUP OP_HASH256 <hash> OP_EQUALVERIFY <index> OP_DEFINE. Makes transition from P2SH simple: unlocking script pushes code, locking script has code-hash and OP_DEFINE_VERIFY. Prevents brute forcing unlocking script that steals funds."
        },
        {
          "question": "What is SORTS standard for BCH contract discoverability?",
          "answer": "Simple Op Return Text Standard - parsing data for Bitcann and similar contract systems. Records include profile, social, crypto, DNS. Example: contracts.anyhedge.artifacts=<url>, contracts.anyhedge.params.0=\"parameters\". Wallet uses getRecords('alice.bch') to construct contracts and show info. Optional - user chooses to attach contracts to identity."
        },
        {
          "question": "What is Tom's verified code proposal for OP_DEFINE?",
          "answer": "Provide OP_DEFINE variant to verify function matches hash - like P2SH today only executes provided code if matches hash. Unlocking script pushes [code], locking script has: push 32-bytes-hash, push index, DEFINE_VERIFY. Hash can come from anywhere as stack item. This usecase is what P2SH does in more convoluted way."
        },
        {
          "question": "What is UTXO model explained as bills analogy for BCH?",
          "answer": "UTXO is like individual cash bill - transaction destroys bill and creates new bills, amounts must add up (difference claimed by miners as fee). Each bill has locking script - codified checklist enforcing conditions to spend. Different from EVM - code encodes constraints not actions. Most important: **anything that's not constrained is allowed** - root of footguns."
        },
        {
          "question": "What is ZCE Bag covenant specification requirement?",
          "answer": "Need to specify ZCE Bag covenant - central to design but no mention of how supposed to work. Opcode for just one contract type has very bad smell. Attention is scarce resource so not priority now."
        },
        {
          "question": "What is ZK-rollup state-root updater contract structure for BCH?",
          "answer": "Contract stores oldRoot and verifier pubkey. To spend: provide signature (proofSig) over (oldRoot || batchHash || newRoot), verify with OP_CHECKDATASIG, enforce single output preserving value, ensure next UTXO locks to new contract script via P2SH32(newScriptHash). Off-chain compiles fresh contract with newRoot."
        },
        {
          "question": "What is big footgun with BCH contract UTXOs?",
          "answer": "If not constrained, all bills for contract can be spent at once, and value for one of them can satisfy constraints of ALL of them. Example: contract says 'any bill spent by anyone but 1000 sats must go to address A' - with 10 inputs only one needs to satisfy constraint for all. Bills can be spent as single input thread or highly multi-threaded input - must be considered."
        },
        {
          "question": "What is debate on OP_DEFINE_VERIFY necessity?",
          "answer": "Tom proposes as safety valve for code injection - prevents brute forcing unlocking scripts. BCA, Jonas, Jason, Calin see no problem in the issue. Debate centers on whether bytes unlocking UTXO being executed by input's VM vs parsed as data matters. Many consider it unnecessary complexity."
        },
        {
          "question": "What is immutable code argument for OP_EVAL?",
          "answer": "Want to state as fact when sending transaction to lock money, know for fact which scripts will run to unlock. Even if stupid mistake in code, ONLY thing people mess with is data. Can't provide new code to unlock. Code is locked. This is 'trusted code' or 'immutable'. How it works today via push-only rule for unlocking scripts."
        },
        {
          "question": "What is local execution context for BCH scripts?",
          "answer": "Whole TX+prevouts already is local execution context. Eval loading from stack is just loading static data from rest of TX. Script can require other script passes in another transaction, brings proof through token. Even with eval, stacks can't interact between inputs."
        },
        {
          "question": "What is main concern with enabling powerful VM for complex contracts?",
          "answer": "Main point against: Do we want BCH script so powerful that certain contracts will blow up because they were too complex? ZK-contracts will be extremely complex, only very select few would have ability to review cryptography. If ZK-contract catches on and blows up, it won't be due to specifics of any opcode or missing security guardrail."
        },
        {
          "question": "What is the challenge with multiple inputs when receiving payments in UTXO contracts?",
          "answer": "A single transaction can have 10+ inputs from different addresses, making it ambiguous which sender to record. UTXO architecture requires thinking differently than account-based systems. Rather than a single 'sender' variable, use NFTs to create separate state UTXOs per user, or implement contract patterns like Cauldron's per-user contract addresses where each depositor gets a unique contract address containing their pubkey."
        },
        {
          "question": "What is the key difference between OP_EVAL and the Subroutines CHIP?",
          "answer": "Subroutines CHIP forces designers to introduce subroutine code in the locking script via fixed subroutine tables. OP_EVAL/OP_EXEC takes executable bytecode from the stack, allowing it to come from: the locking script, unlocking script, another input/output's script (via introspection), or constructed dynamically by code. OP_EVAL provides flexibility; subroutines provide structured safety by restricting where executable code can originate."
        },
        {
          "question": "What is use case for executing functions from other UTXOs?",
          "answer": "When scripts too large for limits. With P2S binding limit 10kb vs 1650 byte standardness limit. Is 10kb enough for ZKP functions? Could see UTXO exporting specific function. Well-known script constructions integrated into BitAuth IDE and CashScript instead of copy-pasting."
        },
        {
          "question": "When should you download full blocks instead of using Fulcrum subscriptions?",
          "answer": "For monitoring >1 million script hashes, downloading full blocks and filtering locally is more efficient than subscriptions. Subscribing to 1M addresses = 50MB network traffic + 50MB local storage just for subscriptions. If behind a full node, filtering blocks is safe and cheap. Remember which blocks you've processed to catch up after downtime. Fulcrum max_subs limit (10M) is generous DoS prevention, but downloading blocks scales better."
        },
        {
          "question": "When should you use CSV vs introspection for enforcing relative locktimes?",
          "answer": "CSV is better for simple cases like `require(tx.age >= <expression>)` as it automatically enforces TX version 2. For variable age scenarios (e.g., longer staking = more rewards), use introspection: `require(tx.version == 2); int nSeqInput = tx.inputs[3].sequenceNumber; require(nSeqInput > 0);`. This allows using nSequenceInput in other calculations while still enforcing the timelock."
        },
        {
          "question": "Where to find advanced CashScript examples for BCH?",
          "answer": "0353f40e.gitlab.io/emerald-dao/ has advanced examples. awesomebitcoin.cash/#script lists published documented scripts (libauth templates and op_code fine too). youtube.com/@bitcoincashuniversity has badgers and fundme contract tutorial vids. PurelyPeer.cash uses CashScript for cashdrops (microads) and vaults (digital coupons). cashscript.org/docs/showcase for project showcase."
        },
        {
          "question": "Why do anyone-can-spend contracts need faster confirmations?",
          "answer": "Any kind of anyone-can-use UTXO contract - multiple users could accidentally try interact with same UTXO at same time, and until block is mined they won't know which user's tx will go through. If anyone-can-spend tx has conflict, rather know in 1-9 minutes than 10-90. Can't control app logic of 3rd parties to whom BCH is just another coin, only to be hit by 20-30min waits 1 in 10 times."
        },
        {
          "question": "Why does CashScript use signed magnitude not two's complement?",
          "answer": "Emergent/Mathieu: BCH VM works natively with signed magnitude, not two's complement. Therefore any tools around script and VM will also use signed magnitude. Script numbers don't use twos complement, they use signed magnitude. CashScript must follow same since it compiles to BCH VM bytecode."
        },
        {
          "question": "Why is Flipstarter not true assurance contract?",
          "answer": "Tom: While advertised as 'assurance contract' it is not actually any contract because moment money is sent, obligation on receiver drops to zero. There literally is only one thing that can be applied: social pressure. This is opposite of a contract."
        },
        {
          "question": "Why is hash validation important for executable code?",
          "answer": "Practical difference based on cryptography. Script with just OP_EQUAL not very useful. Hashes hide actual data that unlocks it, avoid brute forcing. With code you don't validate, massively easier to find script to unlock money. Locking script that uses eval without hash validation allows experimenting until unlocked."
        },
        {
          "question": "Why is zero-conf vs faster blocks a false dichotomy?",
          "answer": "Zero-conf will always be the way forward for in-person transactions and low-value payments. However, improving UX for cases where 0-conf doesn't work (high-value, untrusted parties, or p2sh ancestor chains) is also important. Faster blocks and zero-conf are complementary, not competing solutions. More TPS (enabled by both) drives price."
        }
      ]
    },
    {
      "name": "CashTokens & NFTs",
      "description": "CashTokens implementation, NFT usage, token standards, BCMR, and token-based contract patterns",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can read-only inputs be implemented without the TXv5 transaction format?",
          "answer": "Yes. Read-only inputs could be added by including just 1 optional byte to input encoding, similar to how CashTokens were added to output encoding. This avoids requiring a full transaction format version change. However, no one is currently championing this approach separate from TXv5."
        },
        {
          "question": "How can NFT on/off switch solve AMM withdrawal conflicts?",
          "answer": "NFT can be used for withdrawal, second contract as on/off switch for LP. If LP contract requires NFT held by on/off switch contract (or <1 confirmation movement from it) for trades to occur, and withdrawal path requires NFT included with 1 confirmation, then trade transactions and withdrawal transactions should no longer have risk of conflict."
        },
        {
          "question": "How can NFTs be used to store contract state on BCH?",
          "answer": "NFTs act like mini-structs in UTXO architecture. When a user deposits into a contract, an NFT is created with the user's address and data stored in the NFT commitment field. The BCH amount is held on that same NFT UTXO. NFTs contain: satoshi amount, token category, token capability, and custom fields in the commitment (user address, flags, etc). Each NFT represents one piece of contract state, owned by the contract itself or users."
        },
        {
          "question": "How can you verify that a CashToken transaction succeeded?",
          "answer": "Check multiple sources: 1) Verify txId was returned from wallet.send(), 2) Use decodeTransaction() to inspect the raw transaction outputs, 3) Check token-aware explorers like explorer.electroncash.de or Electron Cash wallet which display tokenData in outputs. Some explorers (like melroy.org) may not show token amounts even if the transaction succeeded."
        },
        {
          "question": "How do CashTokens enable subscription payment model?",
          "answer": "BCA: Can all be done with CashTokens. Service would hold NFT which it could use to trigger pull. When you want to cancel you just burn their NFT. Could have multiple services pull from same pool of funds if they have authorization via NFTs."
        },
        {
          "question": "How do you monitor token balance changes in real-time with mainnet-js?",
          "answer": "Use wallet.watchTokenBalance() which accepts a callback that fires when balances change. Example: `const cancelWatch = wallet.watchTokenBalance(undefined, (updatedBalances) => { setTokenBalances(prevBalances => ({...prevBalances, ...updatedBalances})) });`. Get initial balances with getAllTokenBalances(). Remember to call cancelWatch() when unmounting the component to prevent memory leaks."
        },
        {
          "question": "How do you send CashTokens using mainnet-js TokenSendRequest?",
          "answer": "Use `new TokenSendRequest({ cashaddr: recipientAddress, amount: 100n, tokenId: 'your_token_id', value: 1500 })`. The `amount` is the token quantity (BigInt), `value` is the satoshi amount on that output (minimum 1000 sats for token outputs). Send via `await wallet.send([tokenRequest])`. Verify with `await Wallet.util.decodeTransaction(sendResponse.txId, true)` to see full transaction details."
        },
        {
          "question": "How does BitCANN handle domain name uniqueness without global state?",
          "answer": "BitCANN doesn't 'remember' claimed domains on-chain. Instead, the real name UTXO can terminate anyone's UTXO trying to add the same name. State management is delegated to external agents (users/services tracking existing names). The DomainOwnershipGuard uses an NFT ('ExternalAuthNFT') from the Domain contract - its mere existence proves domain ownership. Users wanting to use the incentive system penalize invalid auctions."
        },
        {
          "question": "How to use OP_DEFINE with external data from NFT commitments?",
          "answer": "Example: <0> OP_OUTPUTTOKENCOMMITMENT to get NFT commitment at Output 0, then <0> OP_DEFINE to define program from it, then <0> OP_INVOKE. Safety caveat: program has access to full stack (no stack isolation). Must ensure stack empty before invoking and returns expected items. Otherwise callback could mutate Stack items to get truthy result."
        },
        {
          "question": "How would BCMR verification work for OP_EVAL contracts?",
          "answer": "Like CashTokens where anyone can create scam tokens but BCMR verifies most used ones integrated into wallets. Same with smart contracts - BCMR of vetted bytecode locations on-chain for functions like 'quantum resistance check', 'ZKP verification'. Naive users use defaults (kiddy playground of vetted things). Audited OP_EVAL functions reach users via BCMR verified system."
        },
        {
          "question": "How would freeze/seize functionality work on BCH CashTokens?",
          "answer": "Tokens would need to be contained in smart contract rather than sent to user's wallet. Users wouldn't have exclusive ownership like with p2pkh - just privilege to transfer their part of ownership in the big contract. This privilege could be revoked with an admin key. By default, CashTokens in user's wallet cannot be seized."
        },
        {
          "question": "What BCMR API issues exist with NFT flagging?",
          "answer": "Paytaca BCMR server has 'is_nft' boolean flag that should really be changed to 'has_commitment' because that's what it means. Paytaca doesn't use this flag anymore. Can create issue at github.com/paytaca/bcmr-indexer to track change. Flag is actually object with NFT info, not just boolean."
        },
        {
          "question": "What NFTs do FundMe.cash pledgers receive?",
          "answer": "Pledging gives pledgeNFT which you keep. It records campaignID and how much BCH pledged. Can be refunded before campaign completes. Wallet tab shows pledgeNFTs for refundable pledges - could expand to show all campaigns funded and BCH amounts for tax tracking."
        },
        {
          "question": "What are current BCH BCMR registries and resources?",
          "answer": "BCMR repos: Paytaca at bcmr.paytaca.com (metadata indexer, not true token registry per BCMR spec), otr.cash, PTR at github.com/zapit-io/ptr, Flowee BCMR server (added HTML way to get BCMR details on tokens/auth-chains for human viewing, was purely JSON before). Also minisatoshi.cash/ecosystem lists all with BCMR tags."
        },
        {
          "question": "What are security footguns with NFT-owned UTXOs?",
          "answer": "NFT can't be on same input as UTXO it locks - spender specifies which input has NFT. Footgun: NFT UTXO itself needs to verify whole TX. If it doesn't (suppose NFT spent with SIGHASH_ONE), then 3rd party could just add more inputs owned by NFT and do what it wants with them. Locking script defines ownership, unlocking just satisfies predicate requesting signature or NFT."
        },
        {
          "question": "What are the Wyoming Stable Coin blockchain selection criteria?",
          "answer": "Wyoming stable token (WYST) requires 'Freeze and Seize' capabilities as a criteria. Liquid network gained qualification because AMP's APIs facilitate freeze/seize via whitelisting addresses. Blockchains without freeze/seize functionality would be disqualified. For BCH, it's technically possible to implement via covenant for a token but requires keeping tokens in smart contract rather than user's p2pkh wallet."
        },
        {
          "question": "What are the key concerns about iBCH as an additional incentive token?",
          "answer": "Main concern is circular dependency: incentive mechanism depends on DEXs existing, which rely on consensus tools, which require the token. Can't have an incentive securing the chain that's reliant on services built on the chain. Additional issues: either iBCH value is low (proposal falls apart) or has value (arguably alters 21M cap), and no other network has implemented similar scheme to observe real-world behavior."
        },
        {
          "question": "What are use cases for mutable NFT code in contracts?",
          "answer": "Vault where you can update spending paths without moving funds - new spending funds validated with tokens or pubkey/signatures. Code compression: if (program in NFT1) else (program in NFT2). Contract could keep benefactor in commitment and let current benefactor mutate state with signature to set new benefactor. Exotic but can be very useful."
        },
        {
          "question": "What evidence shows CashTokens spurring BCH project growth?",
          "answer": "CashTokens integrated into Zapit, Paytaca, Cashonize, Selene, rumored for Bitcoin.com. Projects: TapSwap, BCH Pump, Badgers, BLISS, BCH Guru FURU, AFoG token, Fiendish spaces token, Cauldron, CashTokens studio, MUSD, FundMe. Number of projects seriously rising since CashTokens added. Transaction volume not yet up but projects and infrastructure growing."
        },
        {
          "question": "What is Bitcart and what cryptocurrencies does it support?",
          "answer": "Bitcart (bitcart.ai) is an open-source, self-hosted payment processor written in Python. It supports BTC, LTC, BCH, XMR and more. BCH has been supported for 4+ years (6th birthday in March 2025). Work is ongoing for CashTokens support via Electron Cash API. It's a viable alternative to custodial payment processors for merchants wanting full control."
        },
        {
          "question": "What is BitcoinCashClient C# library for BCH integration?",
          "answer": "Nuget library to abstract away complexity from integrating BCH into C# .net application. AFoG uses it for all BCH tasks except address monitoring. Uses NBitcoin as base layer to handle bits and bytes of transaction construction. github.com/david-shattuck/BitcoinCashClient. Todo: fully remove NBitcoin dependency for total control over transaction construction for CashTokens stuff."
        },
        {
          "question": "What is Blockbook indexer and why for BCH CashTokens?",
          "answer": "Trezor's indexer for BCH - wraps node RPC, has WebSocket subscriptions. Pat's fundme.cash campaign/39 for CashTokens support aims for hardware wallet level support. Blockbook pretty much wrapping node rpc, no UTXO chain token balance support currently (only EVM, looks awkward). Fast performance."
        },
        {
          "question": "What is Thorchain CashTokens support status?",
          "answer": "Thorchain considering adding support to CashTokens but need SMEs. Tyler (9R): BCH devs interested in getting CashTokens supported by TC. BCH very important to us - only DEX that really supports BCH. thorchain.net/pool/BCH.BCH. Fees to pool depth ratio is 30% for year - very productive pool. Want to add MUSD/RUNE."
        },
        {
          "question": "What is camping lottery BCH NFT use case?",
          "answer": "Island with 6 campsites, dates May 15-Sept. Simplify lottery processing: sign up with BCH address, receive NFT with unique commitment (date + sequence), transfer NFT to camp (admission slip). Can trade NFT on marketplace in meantime. Similar to concert ticket usecase. Just assets, no smart contracts needed - send to someone else's wallet, could use poster with phone number to meet in real life."
        },
        {
          "question": "What is standard script pattern for NFT-owned UTXOs (P2NFT)?",
          "answer": "Standard script for NFT ownership: `OP_DUP OP_UTXOTOKENCATEGORY OP_SWAP OP_UTXOTOKENCOMMITMENT OP_CAT OP_HASH160 <x> OP_EQUALVERIFY` where x is hash. Compressed version: input script pushes index where NFT is placed. Wallet discovery: take what wallet has (pubkeys, NFTs) -> generate assumed UTXO locking scripts they could unlock -> query Electrum for UTXOs locked with those scripts."
        },
        {
          "question": "What is the BCH dust limit formula and what is the recommended safe amount for CashTokens?",
          "answer": "Dust limit formula is: 444 + output_size * 3. For safety after CashTokens it's best to use 1000 sats as dust amount. Electron Cash uses 800, some dapps use 1000 and others use 800. The exact calculation per UTXO is available in libauth, but using a fixed amount (800-1332) is simpler than perfect calculation."
        },
        {
          "question": "What is the computational cost for miners to add MHC commitments to coinbase?",
          "answer": "Negligible: ~20 hashes per block. Because leaves are added at the end of a sorted list, you only need to compute the right edge branch of the merkle tree. With UTXOs this wouldn't work (added/removed randomly), but for header commitments the append-only pattern makes it extremely cheap. If placed as last output, compact proofs can be created via SHA256 midstate without needing the full coinbase tx."
        },
        {
          "question": "What is the difference between token inputs showing 'tokenData: undefined' and actual token data?",
          "answer": "In mainnet-js transaction decoding, inputs from previous transactions may show 'tokenData: undefined' in the vin array even when the transaction successfully creates token outputs. The vout array is what matters for new outputs. Inputs only need enough BCH value and token authority - the tokenData in outputs determines what was actually sent."
        },
        {
          "question": "What is the original BCMR verification model vs how it's commonly used today?",
          "answer": "BCMR was designed so the payer provides the JSON to you, then you cheaply verify truth via the auth-chain (maybe 10KB total including merkle proofs). DNS-based verification via webserver files was also core to the spec. Today, most implementations use trusted indexers that provide the JSON (turning the model upside down), which works but means nobody validates ownership, IPFS is needed wallet-side, DNS-based is ignored, and a central database would work better."
        },
        {
          "question": "What is vox.cash and how does it differ from unspent.app?",
          "answer": "Vox.cash is 2025 update of unspent.app (2022) that includes integrated wallet, state and tokens - much more powerful with CashTokens. Features 10 market-making contracts including super easy Dutch Auction (26 bytes unlocking code). Each contract designed to make some kind of market in as few bytes as possible."
        },
        {
          "question": "When can you use reduced entropy for NFT category IDs?",
          "answer": "If you generate category/NFT yourself, 2^128 is fine (half of category ID via OP_SPLIT). If you're given NFT, not fine - someone could have rolled colliding pair - you'd want 2^256 there. Reduced entropy donation address: `<0> OP_UTXOTOKENCATEGORY <16> OP_SPLIT OP_DROP <half_of_NFT_categoryID> OP_EQUAL` - total input size 64 bytes, sweep 1000s of UTXOs with just 1 signature."
        },
        {
          "question": "Why do many developers and communities hate 'crypto'?",
          "answer": "The crypto space is overwhelmed by scams - furries, musicians, artists, and gamers all hate 'crypto' due to perception damage. Those trying to fulfill Bitcoin's original purpose are drowned out 1000:1 by scam tokens. The damage to crypto's perception is probably much higher than people imagine. Recruiting good C++ devs to the space is nearly impossible - asking means you're considered 'dirty'. This makes developer recruitment extremely challenging."
        },
        {
          "question": "Why do some developers avoid BCH-specific features like CashTokens?",
          "answer": "Blockchain-agnostic approach allows exit if BCH fails to be best chain. Multiple OP_RETURN and CashTokens not compatible with BCH forks (eCash, Nexa). Two main reasons to stay: network effects (Paypal, Thorchain availability) and backward compatibility maintained in recent years without breaking changes."
        },
        {
          "question": "Why do wallets use BCMR indexers instead of the original verification model?",
          "answer": "For NFTs with thousands of images, BCMR files become megabytes in size and lack core features (requiring extensions). Airdrops and DEXes don't have payment protocols to support the original model. Trusted indexers solve this by providing JSON, but it's essentially standardized data storage on someone else's computer. The tradeoff: easier implementation but centralization and loss of the trustless verification design."
        },
        {
          "question": "Why does Cashonize show 0 tokens sent when sending tokens to yourself?",
          "answer": "This is not a bug - wallet history displays the net balance change. When you send tokens from your address back to your address, the balance doesn't change (0 net change). Contract interactions require this calculation method. Use block explorers like explorer.electroncash.de or Electron Cash to see the actual token outputs and amounts in the transaction."
        },
        {
          "question": "Why don't developers calculate exact dust limits per CashToken UTXO?",
          "answer": "It's not clear how to divide up funds in a wallet (do CashToken UTXO sats count to your cash balance?). Managing UTXOs with large amounts or multiple token types is complex. Also, the amounts are too small to bother optimizing at this stage. Eventually someone will make a library/method and everyone will use that."
        },
        {
          "question": "Why is wrapped asset integration important for BCH DeFi?",
          "answer": "Need WBTC, WETH and standard derivatives for DeFi. Real killer likely stablecoin (MUSD or possibly Tether return). If BCH had wrapped CashToken versions of other UTXO projects, those ecosystems could get fast low-fee DeFi on BCH. FBCH currently largest TLV CashToken project."
        },
        {
          "question": "Why was CashToken signing serialization designed to prevent old software from creating token transactions?",
          "answer": "For transaction encoding, token data precedes the locking script. But for signature preimage, token stuff is intentionally moved 'outside' (before the script length). This design ensures unupgraded software can't generate valid token signatures and accidentally burn tokens. Old software lacking token awareness will create invalid signatures, preventing catastrophic token loss."
        }
      ]
    },
    {
      "name": "Development Libraries & Tools",
      "description": "Software libraries, SDKs, development tools, and frameworks including libauth, mainnet-js, and language-specific tooling",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How do you set up mainnet-js with React and Next.js?",
          "answer": "Mainnet-js provides a React/Next.js demo with proper configuration at github.com/mainnet-cash/mainnet-js/tree/master/demo/react-next. The key is configuring next.config.mjs correctly to handle polyfills for Node.js modules that don't exist in browser environments. Clone the demo repository and examine the configuration rather than starting from scratch to avoid common polyfill errors."
        },
        {
          "question": "How does NPM supply chain attack work?",
          "answer": "Farooq: For many packages on npm, the domains used for Email has expired. Someone else can register domain, launch mail server, then use reset password mechanism to get control of packages. Major supply chain attack vector."
        },
        {
          "question": "How does Telegram mute functionality work for community management?",
          "answer": "Telegram doesn't have per-user mute like Nostr. If could globally mute people adding noise, would be decentralized version of banning - quickly muted by anyone adding signal, unpopular to reply giving fuel, faster with mute-replies feature. Without this tool, needs willingness to not be everyone's best friend."
        },
        {
          "question": "How does vox wallet modularize DeFi protocols?",
          "answer": "Each vox module is just libauth template and page of helper functions to build transactions. Libauth doing all heavy lifting constructing/validating transactions (no cashscript sdk). When libauth library available elsewhere easier to port modules to Flowee or EC. Drip was BCA's idea, WBCH was Dagur's, BlockPoints based on Badgers."
        },
        {
          "question": "What BCH development library recommendations for different needs?",
          "answer": "mainnet-js: automatic UTXO selection, change outputs, simple sends. libauth + cashscript combo: preferred by Jerry for SDK. libauth alone: nice if don't need wallet or electrumX. mainnet-js has bloat and workarounds with webpack/bundlers per some. npm concept doesn't make sense to Tom. Python: wait for cashscript-py. Rust: rust-bitcoincash supports CashTokens. 2qx working on libauth examples."
        },
        {
          "question": "What Node.js version should be used with mainnet-js and Next.js?",
          "answer": "The mainnet-js React/Next.js demo works with Node 22.13.0. Use yarn as the package manager (the repo includes yarn.lock). While npm can work, mixing package managers causes lock file inconsistencies. The repo's next.config.mjs handles polyfills for browser environments, eliminating manual webpack configuration."
        },
        {
          "question": "What Rust libraries available for BCH development?",
          "answer": "gitlab.com/rust-bitcoincash/rust-bitcoincash/ - supports CashTokens. Rust forces write out every return type and possible state - library usually done or not done. Very common to see well written rust libraries go for years without release - they're not unmaintained, they're just done. 'electrum-client-netagnostic' crate for electrum API access. libauth-rs replacement for libauth.org would be cool."
        },
        {
          "question": "What Rust tooling exists for BCH development?",
          "answer": "Riften Labs (gitlab.com/riftenlabs) has Rust BCH tooling including a Rust indexer. rust-bitcoincash (gitlab.com/rust-bitcoincash/rust-bitcoincash) provides core Bitcoin Cash libraries. Libauth also has Rust components (compiled to WASM for hashing functions at github.com/bitauth/libauth/tree/master/wasm/hashes). Java and C++ are the most mature compiled languages for BCH, with Go standalone libraries also available."
        },
        {
          "question": "What are Vox apps built with?",
          "answer": "2qx: Every vox app is libauth template, builder function and UI page. There are 4 examples now but will be like 12 soon. Mainnet and Selene also do this. Short general audience READMEs in each app, more technical breakdowns in libauth templates."
        },
        {
          "question": "What are mainnet-js and CashScript SDK compatibility options?",
          "answer": "Kallisti: Short answer is yes. Long answer - you'll probably need to write some of your own glue code to make two libraries talk to each other. 2qx: There are three type formats for unspent outputs - each library has its own format and common format (electrum-cash) underneath."
        },
        {
          "question": "What are vegabch MoriaV1 BCH libraries release?",
          "answer": "npm packages: vegabch@0.2.0 @cashlab/common@1.0.4 @cashlab/moria@1.1.1. MoriaV1 now available in vegabch. Docs for devs: github.com/hosseinzoda/cashlab#documentation. vegabch cli readme for power users: github.com/hosseinzoda/vegabch."
        },
        {
          "question": "What frontend libraries recommended for BCH development?",
          "answer": "Libauth for working with BCH frontends - has validation for CashAddr function for typescript/javascript. mainnet-js if find libauth tricky to work with. Use tsx instead of ts-node for ESM - tsx 'just works' vs ts-node has many ESM problems. Latest LibAuth might require Node >= V22. V23 might have non-ESM with ESM mixing support but can't use top-level await which LibAuth needs for libsecp256 WASM initialization."
        },
        {
          "question": "What is NPM domain expiration password reset vulnerability?",
          "answer": "Farooq: For many packages on npm, the domains used for Email has expired. Someone else can register domain, launch mail server, then use reset password mechanism to get control of packages. This is major supply chain attack vector."
        },
        {
          "question": "What is benefit of OP_EVAL pulling functions from old transactions?",
          "answer": "Titanic efficiency and bug-reduction gain. People write needed thing once, everyone refers to it. Otherwise copy-pasting everywhere which is bug risk itself. Widely used functions get audited once, patched version released if bugs found (like npm packages). MORE bugs if everyone rewrites own or copy-pastes."
        },
        {
          "question": "What is community ownership problem with BCH documentation?",
          "answer": "Mathieu/emergent: Maintaining high quality docs is lot of work and for no personal benefit. At least code has personal benefits like github stars, npm downloads, showcase. Each copy owned by repo owner - if owner isn't committed to updates, no reasonable expectation for them to happen."
        },
        {
          "question": "What is mainnet.cash 2.7.0 update?",
          "answer": "Big update tackling many recent issues and modernizing the lib. github.com/mainnet-cash/mainnet-js/releases/tag/2.7.0. These changes will have positive impact on Cashonize and other integrations."
        },
        {
          "question": "What mainnet-js improvements for bundle size and features?",
          "answer": "Bundle size 737 kB -> 270 kB (gzip) - got lot slimmer by externalizing SBCH functionality and storage providers. Great for automatic UTXO selection and automatic change outputs - easiest solution in TS/JS for simple BCH/token sends. Example apps using different frameworks in github.com/mainnet-cash/mainnet-js/tree/master/demo. Fee handling abstracted away as feature."
        },
        {
          "question": "When should you use mainnet-js versus libauth for BCH dapp development?",
          "answer": "Mainnet-js is a high-level library best for most use cases - it's easier and internally powered by libauth. Use it if the functionality covers your needs. Libauth is low-level and provides more advanced control when you need fine-grained transaction construction or operations mainnet-js doesn't expose. Mainnet-js also allows extending the base wallet class for application-specific functionality."
        },
        {
          "question": "Why does Next.js show topLevelAwait warnings when using mainnet-js with libauth?",
          "answer": "Webpack generates warnings about async/await and topLevelAwait when Next.js doesn't fully understand the build configuration. These are usually safe to ignore if the mainnet-js demo's next.config.mjs is used correctly - the warnings don't prevent the code from working. Verify functionality by checking if wallet addresses generate correctly rather than focusing on build warnings."
        },
        {
          "question": "What are effective AI prompting strategies for deep analysis?",
          "answer": "Using deep think mode then deep search asking 'are you really sure?', then ignoring answer and presenting problem gives AI really good understanding. Second answer can be worse (overcomplicated) - by third reiteration things get out of whack. Best method: establish base with first question then provide complex details in second turn."
        },
        {
          "question": "What is Trezor Blockbook BCH naming and cosmetics approach?",
          "answer": "Implemented throughout Trezor code including coin name as 'bcash'. Attempt to change would only aggravate them. Not a hill worth dying on. Pat could apply cosmetics on top of contributed code for own deployments but would not push to upstream. Blockbook is maintained, well taken care of with no critical fixes - should be in healthier state now than 2020."
        }
      ]
    },
    {
      "name": "Wallets & User Experience",
      "description": "Wallet development, user interfaces, WalletConnect, payment UX, and end-user application integration",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How can BCH work without internet using merkle proofs?",
          "answer": "Wallets pass around merkle proofs to verify TX inputs are valid. Can't verify double spends without miners, but acceptable for small payments. TX chains get longer with no unconfirmed TX verifiability. Need regular chain sync to verify TXs actually valid. However, IMO lot of work for dwindling use-case - better solution is higher connection reliability."
        },
        {
          "question": "How do SPV wallets verify without being lied to?",
          "answer": "Tom: Any SPV wallet that wants to verify proofs needs headers - if they don't do that they're not verifying they're not being lied to. Electron Cash uses search indexers and does checks thus needs headers. Can query electrum server for checkpoint at any height N which will be root of all headers from 0 to N-1."
        },
        {
          "question": "How do you troubleshoot WalletConnect2 connection issues with BCH dapps like tapswap?",
          "answer": "If WalletConnect2 shows a persistent connection without wallet selection options, first try ending all sessions in the dapp's settings. If the disconnect button doesn't work, manually remove all localStorage items mentioning 'wc2' in your browser's developer tools. Clearing site-specific cache and data can also resolve stuck sessions between the dapp and wallet."
        },
        {
          "question": "How does BCH wallet with Nostr integration work?",
          "answer": "Web wallet generates 12-word mnemonic for user on first login. Auto-generate private key and BCH address at index 0 on 245 derivation path (standard for SLP-token aware wallets). From that private key can generate nsec and npub for Nostr account. In future, allow import of nsec from elsewhere to generate BCH address and hydrate web wallet."
        },
        {
          "question": "How does BitPay handle JSON Payment Protocol vs BIP70?",
          "answer": "Tom: While it does JSON-PP, it ALSO does protocol buffers PP. What your wallet handles depends on what your wallet asks BitPay to provide. Jim: They got Electron Cash to implement JPPv2 specifically for their service and UI uses Select Wallet dropdown now before you pay."
        },
        {
          "question": "How does SPV merkle block sync work?",
          "answer": "Tom: Wallet needs to ask any full node all merkle blocks once. If started 24 hours ago need to send 144 requests (some 40 bytes each). If ran 6 hours ago only ask 36 blocks. Benefit of merkle is network activity stable regardless size of wallet - doesn't matter if you used million addresses."
        },
        {
          "question": "How does StableHedge compare to Tether in terms of design goals?",
          "answer": "StableHedge is not designed as a Tether competitor for massive holdings. The bonus of not having millions in one entity is avoiding disproportionate threats against people (like $5 wrench attacks against team members or loved ones). No multisig helps against physical coercion. It's better to treat Paytaca team as precious people who shouldn't become big targets by holding excessive funds."
        },
        {
          "question": "How should wallet template verification work?",
          "answer": "Tom: Normal users won't be able to tell if template is going to rug them. Best approach is wallet will trust templates approved and verified by company and refuse to use any other templates. You move trust to wallet makers who have reputation."
        },
        {
          "question": "What Go libraries are available for BCH wallet development?",
          "answer": "For Go wallet development, bchwallet (github.com/gcash/bchwallet) provides the core wallet functionality. The BCHD project also includes wallet libs/utils and GRPC API. Neutrino wallet was implemented in Go with full functionality. Backends options include Fulcrum (Electrum protocol), BCHD GRPC, Chaingraph, or the BCHC indexer - all accessible from Go code."
        },
        {
          "question": "What are different wallet template security policies?",
          "answer": "Jonathan: High-security focused wallets will refuse to let users add new templates they haven't audited and signed for. High-versatility wallets let you add any template with nothing but stern warning between you and imminent loss of funds. Most wallets fall in between."
        },
        {
          "question": "What browser compatibility issues exist with WalletConnect2 on BCH?",
          "answer": "Brave browser has known issues with WalletConnect. If WalletConnect2 shows a persistent connection without wallet selection, remove all localStorage items mentioning 'wc2' via browser developer tools. Safari and Firefox have better compatibility. Edge lacks per-site cache clearing which complicates debugging connection issues."
        },
        {
          "question": "What is CashConnect vs WalletConnect for BCH?",
          "answer": "CashConnect used by BCH Guru, only implemented in one wallet. Supposed to solve for HD wallets. WalletConnect has relay servers to integrate apps and wallets. CashConnect promising but couldn't find much information or reference implementation anywhere."
        },
        {
          "question": "What is CashRPC protocol for BCH wallet-app communication?",
          "answer": "BCH Guru docs link to bitcoincashresearch.org/t/cashrpc-protocol-to-attempt-to-unify-wallet-app-comms/1201 but definitely early. CashConnect also uses WalletConnect currently as transport layer. Ideas to move to libp2p but big gap between end goal vs currently realistic."
        },
        {
          "question": "What is Flowee Pay module system for DApps?",
          "answer": "Flowee Pay mobile has modules that can be developed mostly separate from app. Gives developer power to make custom interface for specific purpose as screen in wallet. Full access to wallet and transaction builder. Great UI/UX pretty easy with Qt/QML tech. Plugin concept like Satoshi's core features."
        },
        {
          "question": "What is LibP2P for BCH wallet communication?",
          "answer": "BCA: LibP2P allows WalletConnect-like functionality - run web-accessible Fulcrum/backends from home, encrypts everything. If both app & wallet have same IP they could establish direct connection instead of sending data to centralized server only for it to come back to same machine."
        },
        {
          "question": "What is Nostr coordination layer for BCH wallets?",
          "answer": "Kallisti: Nostr as coordination layer for wallets is something very interesting to explore. Could implement wallet-app communication inside BCH client. Maybe Alice needs to tell Bob how many tokens to transfer without using centralized service like email or telegram."
        },
        {
          "question": "What is Paytaca's StableHedge stablecoin solution?",
          "answer": "StableHedge (bitcoincashresearch.org/t/stablehedge/1504) uses a centralized peg mechanism but with fully transparent treasury and permissionless minting/redemption. Treasury backing is 50% in BCH (from which anyone can 'pull' by calling the redeem function) and 50% in 2x AnyHedge shorts. Users trust Paytaca to maintain treasury correctly, but unlike centralized entities, they can't lie about the state - if they rug or lose backing, everyone will see on-chain."
        },
        {
          "question": "What is WalletConnect 2.0 complexity assessment?",
          "answer": "Shadow reviewed specs.walletconnect.com/2.0 - there are 5 types of different servers with damn high complexity! Zero chance this can be easily replicated with any generic open source replacement. Any replacement will require lot of work whether generic relay tech exists or not."
        },
        {
          "question": "What is cashaddress.org paper wallet feature request?",
          "answer": "Request for 6 paper wallets per page with about 0.11 inch margin. Would make it easier to cut and save paper. Currently generates single wallet per page."
        },
        {
          "question": "What is seedless wallet approach for BCH onboarding?",
          "answer": "Designated trusted party helps with recovery - requested quite often. May be good for heavy onboarding as stepping stone for people not comfortable with 100% self custody. Example: sideshift.ai uses random unique string (username) + another string (password) to deterministically determine deposit addresses so account can be rebuilt."
        },
        {
          "question": "What is status of WalletConnect BCH integration?",
          "answer": "Integration in limbo (github.com/WalletConnect/walletconnect-monorepo/issues/5672). Submitted but didn't know proper format. Registering chain with Explorer doesn't impact/improve wallet and dapp support ability - simply way for users to discover wallets and dapps supporting chain. Fuzzy on how integration actually works."
        },
        {
          "question": "What is template system approach for BCH dApp security?",
          "answer": "Jonathan: move complexity out from dapps into templating system. If wallet adds generalized templating system powerful enough to understand on-chain actions, dapps no longer need signatures. They ask what you want to do, you verify locally it matches, then you do it yourself. Moves trust from apps to templates."
        },
        {
          "question": "What is the WalletConnect official integration status for Bitcoin Cash?",
          "answer": "BCH was officially added to WalletConnect/Reown documentation (github.com/WalletConnect/walletconnect-monorepo/issues/5672). The correct CAIP-2 chainIDs are: 'bch:bitcoincash' for mainnet, 'bch:bchtest' for testnet, 'bch:bchreg' for regtest. This is defined in Pat's WalletConnect spec and differs from BIP122-based identifiers used for BTC."
        },
        {
          "question": "What paper wallet generators are available for BCH?",
          "answer": "Chris Troutner's latest paper wallet apps are at opensourcemetalwallet.com. The wallet.fullstack.cash can sweep BCH and SLP tokens from these paper wallets. For custom designs, generate an image and use HTML to float generated QR codes over the image. CashStamps also has best support for paper wallets with two QR codes: one to the stamps site (redirecting to app stores), another with bch-wif for claiming."
        },
        {
          "question": "What security warnings should paper wallets include to protect private keys?",
          "answer": "Paper wallets should warn users not to expose private keys to cameras, videos, or other people. The warning text should be comprehensive: 'Do not let any camera, video or person see this' rather than just 'no photos'. This protects against Google Glass, smartphones, and other recording devices. Users often don't realize that taking photos/videos stores data elsewhere with high probability of eventual third-party access."
        },
        {
          "question": "Why build separate BCH wallets instead of collaborating?",
          "answer": "Tom: biggest problem is not tech but trust and opportunity. People don't build on existing wallets, they start their own and after 2 years maybe release something years behind. Realized it's case of wanting control and maybe being unable to work together. If integrated they'd instantly gain users and profit from fees."
        },
        {
          "question": "Why do cold wallets with carved seeds have security risk?",
          "answer": "Jonathan: This kind of cold wallet moves all complexity for signing to user who commonly makes mistakes. Great for power users who are careful, bad for any user that is not. Even well-educated power users sometimes not careful when drunk, high, or under stress."
        },
        {
          "question": "Why hasn't Satoshi's SPV been more widely implemented in wallets?",
          "answer": "Implementing full cryptographically secure SPV (with all hash verification from the whitepaper) is a lot of work and not strictly necessary so far. Most light wallets check on a server, which is easier. Users have never requested \"totally cryptographically secure SPV\" - they prioritize other features. It's a global-scale \"nice to have\" rather than an essential feature for everyday end users given the massive wallet development backlog."
        },
        {
          "question": "Why use browser wallet plugin instead of WalletConnect?",
          "answer": "Tom argues WalletConnect super overkill - just want wallet in browser plugin or browser that ships with wallet. Web browser needs to add support for code 402 which is what we want. Don't want web protocols to make browser on phone talk to wallet on same phone."
        }
      ]
    },
    {
      "name": "Infrastructure & Nodes",
      "description": "Node implementations, indexers, network infrastructure, SPV, Fulcrum, Chaingraph, and backend services",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Do current BCH wallets implement SPV exactly as specified in the whitepaper?",
          "answer": "Both Electron Cash and Flowee Pay fulfill the description given in section 8 of the whitepaper regarding SPV (Simplified Payment Verification). They verify merkle proofs against headers as specified. The confusion often stems from whitepaper pruning - no node implements the pruning scheme from the whitepaper, but clients do implement SPV merkle proof verification against headers."
        },
        {
          "question": "How can Fulcrum and nginx be configured to prevent bandwidth abuse?",
          "answer": "Fulcrum has built-in rate limiting features that should be enabled. Nginx supports rate limiting via the `limit_rate` directive (e.g., `limit_rate 100k;` to limit connections to 100KB/s). For P2P bandwidth monitoring, create a cron job that checks BCHN RPC every 15 minutes to ban nodes consuming excessive data. OS-level tools typically don't track specific remote connections well."
        },
        {
          "question": "How does Chaingraph handle double spends vs Electrum?",
          "answer": "Richard/Jonathan: Electrum provides consistent view (changes mind between consistent views). Chaingraph will remember and serve double spends - if you want consistent view of chain need to write queries carefully to exclude double spends. Electrum won't give two UTXOs from conflicting transactions."
        },
        {
          "question": "How to fix LibAuth ESM compatibility issues with ts-node?",
          "answer": "LibAuth v3.0.0 has ESM compatibility issues with ts-node. Solutions: 1) Modify tsconfig.json settings, 2) Use tsx instead of ts-node - tsx 'just works' for ESM while ts-node has many problems, 3) Use Node V22 or higher (LibAuth requires >= V22), 4) Consider Deno or Bun as Node getting old architecturally. tsx is wrapper around NodeJS that runs TypeScript."
        },
        {
          "question": "What are Bloom filters and do they grow over time?",
          "answer": "Bloom filters (CBloomFilter in BCHN) are fixed-size data structures. At construction, a fixed-length bytearray is created. Inserting items toggles individual bits but doesn't change the size. They never grow - this is fundamental to how Bloom filters work as probabilistic set membership structures."
        },
        {
          "question": "What are realistic latency numbers for cross-continental block propagation?",
          "answer": "Tokyo-Paris ping shows ~593ms round-trip (300ms one-way for header delivery). However, most mining nodes have <100ms latency (US-China). Header is only ~100 bytes so bandwidth isn't relevant. Decentralization helps: miner only needs to reach 1-2 nodes quickly, those then forward the header, eliminating edge cases."
        },
        {
          "question": "What backend infrastructure should Go developers use for BCH applications?",
          "answer": "If using Go, BCHD is likely much easier to use as a backend than Fulcrum. While Fulcrum is great for Electrum protocol support, BCHD provides native Go libraries and APIs designed for Go development. The Knuth node had Go-specific features but has been obsoleted. BCHD represents the best-maintained Go-friendly BCH node implementation."
        },
        {
          "question": "What hardware and software optimizations enable fast BCH full node synchronization?",
          "answer": "BCHN can sync from 0-100% in 2-4 hours with: NVMe SSD storage, moderately fast CPU (Intel Xeon or equivalent), and fiber/1Gbit network connection. Bitcoin Verde offers a fast sync mode that can further speed up initial blockchain download. If syncing takes 24+ hours (like 24hrs for 50%), hardware bottlenecks or network issues are likely the cause."
        },
        {
          "question": "What infrastructure does chipnet.imaginary.cash run and what bandwidth challenges does it face?",
          "answer": "Chipnet runs BCHN (full node), Fulcrum (electrum indexer), and nginx (web server) exposed to the public. With a 3TB/month bandwidth allocation, normal chipnet usage is under 10GB/month. Bandwidth hogs can exhaust the monthly limit in days, requiring sophisticated OS or application-level rate limiting and IP tracking to prevent abuse."
        },
        {
          "question": "What is Electrum protocol header sync process?",
          "answer": "Tom/Kallisti/Bastian: Getting headers quite cheap and one-time thing. On p2p network any full node answers request with up to 2000 headers per request. Fulcrum has blockchain.block.headers method returning all headers between start_height and start_height+count. Header sync basically instantaneous."
        },
        {
          "question": "What is Infrastructure Blocks iBCH tail emission proposal?",
          "answer": "Possible solution to diminishing block reward problem is to use iBCH block reward when/if Infrastructure Blocks get implemented. They can have small tail emission, unlike BCH. Could be used for gigahashcoin pricing instead of BCH block reward which goes to zero."
        },
        {
          "question": "What is Python Telegram bot BCH payment integration stack?",
          "answer": "Use pybitcash (bitcash.dev well maintained by reputable person) to import/generate keys and create payment addresses with required amount. Run Fulcrum as SPV server connected to external full node. Scan mempool using blockchain.address.get_mempool for fast 0-conf detection. Fulcrum best in class indexer. Long-term: libauth may have rust implementation with python bindings."
        },
        {
          "question": "What is Schnorr signature size issue on BCH tempnet?",
          "answer": "Jonathan/Bastian: Signature is only 64 bytes but should be 65 bytes I think. Node keeps thinking it's ECDSA and rejects with 'Non-canonical DER signature' error. Working with signatures and hashes is always fun - any error turns into entirely invalid result."
        },
        {
          "question": "What is debate about increasing BCH OP_RETURN limits?",
          "answer": "Current 220 byte limit considered perfect by some. Proposed compromise for higher limits: increasing cost per byte above current limit to disincentivize but not prevent. Concern: higher limits cause chain growth with data, makes running full node harder, could crowd out money use case. Data bloat forces drastic infrastructure changes to scale (similar to EVM node challenges)."
        },
        {
          "question": "What is double-spend network topology research technique?",
          "answer": "2025 replication of 2015 CoinScope paper - send conflicting TXs to different nodes, see which gets mined, identifies influential nodes. Found 200 nodes close to 50% hashrate. mempool.space partitioned 91% of time. Uses first-seen policy: nodes respect first-seen, conflicts rejected by those who got alternative first. DSProofs would detect method for P2PKH but not P2SH. Differential measurement technique."
        },
        {
          "question": "What is the E2EE messaging web app for BCH?",
          "answer": "Message.psfoundation.info - web app that lets you send and receive E2EE encrypted messages to any BCH address. Uses Bitcoin Cash for addressing and encryption infrastructure."
        },
        {
          "question": "What is the recommended approach for implementing BCMR on-chain authchain resolution?",
          "answer": "Basing lookups on Fulcrum is super slow and creates excessive server burden. Nothing beats dedicated indexers: Chaingraph, Paytaca indexer (github.com/paytaca/bcmr-indexer), or Cauldron's rust indexer (indexer.cauldron.quest/bcmr). If using Rostrum electrum server, blockchain.utxo.get can help. Mainnet-js also has built-in BCMR support. Avoid implementing from scratch with Fulcrum."
        },
        {
          "question": "What is whitepaper pruning and why isn't it implemented?",
          "answer": "Whitepaper pruning would allow pruned nodes to serve historyless SPV wallets - keeping all transactions with UTXOs and creating SPV proofs for those transactions, while discarding spent transaction history. No node currently implements this. However, clients do implement SPV merkle proof verification against headers, which is the key security feature for light wallets."
        },
        {
          "question": "Which chipnet explorers and infrastructure are currently operational?",
          "answer": "Chipnet infrastructure status varies. loping.net (cbch.loping.net) runs its own servers and shows contract addresses correctly. bch.ninja and chaingraph.cash also run independent servers. Some explorers depended on im_uname's Fulcrum server which went down due to bandwidth abuse (3TB/month exceeded). Jason's chaingraph explorer likely has its own infrastructure since he mines chipnet blocks."
        },
        {
          "question": "Why use merkle blocks instead of indexer layers for wallets?",
          "answer": "Full nodes with merkle blocks already solve wallet sync in extremely cheap and scalable way. Problem: most wallets don't use this, instead use new layers which create new problems. Merkle blocks provide best user experience - so much more consistently fast and private updating when opening wallet. Rethinking SPV proposal moves cost from indexers to nodes, centralizing responsibility. Adding more layers possible but not optimal."
        }
      ]
    },
    {
      "name": "Payment Systems & Subscriptions",
      "description": "Payment protocols, recurring payments, subscription models, invoicing, and payment processing solutions",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Are payment channels used on BCH?",
          "answer": "Emergent/Chris/Tom: Payment channels possible on BCH since 2009. Nobody actively using standard libraries though. There is at least one party making thousands of payment channels on BCH regularly but they aren't using standard libraries. Double-spend proof feature is perfect for this use-case."
        },
        {
          "question": "How do BCH subscription payments with xpub work?",
          "answer": "Future idea: repeat payment request includes xpub instead of single address - allowing privacy friendly flow. Example: I have patreon, you're my customer. I sent you payment request. Instead of Bitcoin address I sent you xpub. You pay me every month from next address on that xpub. Without xpub you'd have to send something every month making man in middle needed."
        },
        {
          "question": "How do Mecenas-style recurring payment contracts work on BCH?",
          "answer": "Recurring payment contracts allow pre-funding a specific amount upfront - no further user actions needed. The recipient, another user, or a server can spend the pre-set amount at pre-set intervals by 'pulling' from the contract. This exists as an Electron Cash plugin (github.com/KarolTrzeszczkowski/Mecenas-recurring-payment-EC-plugin) but a WalletConnect version would enable Zapit, Paytaca, and Cashonize users to easily use it."
        },
        {
          "question": "How does x402 compare to payment channels for web browsing?",
          "answer": "When browsing website you'd pay once per page with x402. Single transaction for all pages would make more sense - Bitcoin related chains could open payment channel. Criticism: paying per page vs payment channel for whole session efficiency."
        },
        {
          "question": "How does x402 enable web payments ecosystem?",
          "answer": "Main way forward is more browser support for crypto. Ecosystem non-existent - if webserver returns 402 today browser says illegal state. Need something that works so ecosystem can start building. Wonderful to see progress for payments in webbrowsers."
        },
        {
          "question": "How does x402 protocol architecture work?",
          "answer": "Chris: Three entities - Server, Client, Facilitator. Facilitator is middleware server handling payment and settlement. Server can be normal API without blockchain-specific code. To adapt to BCH, Facilitator would have HD wallet, assign address to each user, accept batch payment and debit against it."
        },
        {
          "question": "What is ARCC and how does it relate to recurring payments?",
          "answer": "ARCC (github.com/kiok46/arcc) is an advanced recurring contract structure, more sophisticated than basic Mecenas-style contracts. Zapit was considering integrating it into their services. It would be a perfect integration for the BitCANN platform and represents more advanced smart contract patterns for recurring payments on BCH."
        },
        {
          "question": "What is Coinbase x402 protocol for crypto payments?",
          "answer": "Chain-agnostic protocol using HTTP 402 code for browser-based crypto payments. Simple scheme can build BCH economy around it. Prime example of cryptocurrency as money of the internet. Could replace dumb paywalls on websites and only be done with crypto."
        },
        {
          "question": "What is Flowee Pay serverless recurring payments approach?",
          "answer": "User doesn't manually resubmit each month. Wallet handles serverless repeated payments with auto-renewal by default unless user specifies not to renew for next period. One payment per period. Combines tech from xpub BIP47 payment codes with privacy-friendly recurring payment protocol."
        },
        {
          "question": "What is Paytaca Payment Hub and what features does it offer?",
          "answer": "Paytaca Payment Hub is a beta solution enabling online merchants to accept Bitcoin Cash payments directly without intermediaries (payment-hub.paytaca.com). Early adopters can use both manual and programmatic invoice creation. WooCommerce and other e-commerce platform plugins are currently in development."
        },
        {
          "question": "What is the authorization token approach to recurring payments without full pre-funding?",
          "answer": "Instead of pre-funding the full subscription amount, users store funds in a large pool, then issue authorization tokens with spending restrictions and hand them out as needed. The tradeoff is privacy - this model links payments through the shared pool. Implementation requires either specific wallet code to manage or a wallet that understands templates, planned for implementation with XO (CashScript execution opcodes)."
        },
        {
          "question": "What is x402 protocol for crypto payments?",
          "answer": "Chris: Coinbase developing x402 protocol - blockchain agnostic, uses HTTP 402 code for browser crypto payments. Whitepaper mentions 'batched settlements' on page 12 but just carve out for future work - nothing implemented or refined into specification yet."
        },
        {
          "question": "What is x402-bch protocol implementation?",
          "answer": "Chris: x402 protocol created by Coinbase leverages HTTP 402 'Payment Required' error. Coinbase implementation focuses on USDC on Base L2 blockchain. Created slight variation to protocol to support Bitcoin Cash - developers can implement own x402 server that accepts BCH for payments."
        },
        {
          "question": "What market demand exists for BCH-denominated subscriptions?",
          "answer": "TMU from running largest monthly recurring payment protocol 3+ years: zero market demand for coin-denominated subscription service. Never heard user say they want it. Why BCH getting dropped as option for v3 unspent annuities (subscriptions). MUSD might change this."
        },
        {
          "question": "What use cases require confirmations despite zero-conf availability?",
          "answer": "High-value transactions (house, car, >$2000) where amounts are too risky for zero-conf. Non-anonymous transactions with named invoices where instant finality isn't required (rent, monthly bills). These typically get checked after an hour or day. Zero-conf is mainly for anonymous transactions you'd do with cash today."
        },
        {
          "question": "What was CoinText and offline payment experiments?",
          "answer": "Vin Armani created CoinText - sent different cryptos via text message, tied joint-custody wallet to phone number (shut down years ago). Tobias Ruck developed be.cash offline-payment system - load RFID card with miner-confirmed UTXOs ($1, $5, $10 denominations), merchant needs internet but payer doesn't."
        },
        {
          "question": "Why do subscription services prefer pull over push payments?",
          "answer": "Pull schemes benefit from customer indifference to cancellation - significant revenue stream. Studies show customers don't cancel subscriptions they should. If user must take action each month to keep subscription, more likely to cancel than auto-renew."
        },
        {
          "question": "Why is BCH recurring payment system unique vs EVMs?",
          "answer": "No other p2p chains with introspection and no EVM with low fees as long-term plan. Can't hardcode MEV executor fee and expect to run on EVM chain long-term. Easy one-time fire-and-forget recurring payment solution running for years is unique BCH value prop. Only new BU chain might support same."
        }
      ]
    },
    {
      "name": "DeFi & DEX",
      "description": "Decentralized finance protocols, AMMs, liquidity pools, trading, and DeFi infrastructure including Cauldron, TapSwap, and derivatives",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can L1 transactions handle high-frequency trading on DEXes?",
          "answer": "Mempool processing chained TX every 200-300ms is fine - L1 TXs aren't suitable for HFT anyway. Jay Berg claims to have solved sequencing problem with Sidepit (docs.sidepit.com). Some solutions being explored involve miners running sequencers to keep it decentralized."
        },
        {
          "question": "How do BCH trading bots work without primary DEX websites?",
          "answer": "Trading bots already exist that do NOT use primary websites. Libraries for doing DeFi that aren't using websites exist like github.com/hosseinzoda/vegabch. Having central entity needing to sign off on each transaction is catastrophe waiting to happen - entity could just not sign and lock funds."
        },
        {
          "question": "How do Cardano sequencers (batchers) work and why does BCH need them?",
          "answer": "Cardano has sequencers called 'batchers' for DeFi ordering. BCH mempool is not good enough - can only process chained transaction every 200-300ms. Sequencing job for DeFi UTXOs could be done by miners to produce extra income. Main issue is real-time synchronization - users need to know latest UTXO set state before building transaction."
        },
        {
          "question": "How do subroutines handle recursion and indexing in the Subroutines CHIP?",
          "answer": "Subroutines declare at code start, receiving an index. All calls use this index (2 bytes per call), including recursive self-calls. The compiler maps this like shortening method names to integers. Subroutines read a fixed number of stack arguments defined at declaration. For variable argument counts, use loops instead of subroutines. OP_RUNSUB calls local subroutines; OP_RUNSUB2 calls subroutines from other inputs."
        },
        {
          "question": "What BCH contracts benefit from faster block times?",
          "answer": "Faster block times improve: (1) AMM DeFi - cannot use zeroconf, need faster confirmations. unspent.cash perpetuities, Cauldron AMM, and dozens of MEV contracts use anyone-can-spend transactions. (2) PR and psychological perception as 'snappier coin' due to more confirmations in shorter timeframe. Instant transactions (zeroconf) handle all other cases."
        },
        {
          "question": "What TVL metrics show BCH DeFi growth?",
          "answer": "TVL (Total Value Locked) graphs at tokenaut.cash/defi and defillama.com/chain/Bitcoincash show growth. Cauldron, anyhedge, bchbull, Moria all showing \"up and to the right\" pattern. TVL numbers not affected by transaction count inflation (unlike TX count which can be artificially inflated on low-fee chains)."
        },
        {
          "question": "What WalletConnect dapp ideas are sought by the BCH community?",
          "answer": "Key WalletConnect app ideas include: vault management, Last-Will inheritance, Mecenas recurring payments, 'Hodl' timelock, AnyHedge integration, airdrop/dividends distribution. Also sought: AMM DEX curve visualizer/simulator, CashScript-py SDK, address analyzer for privacy leaks, double spend proof (DSP) checker website, and TypeScript BCMR indexer."
        },
        {
          "question": "What is Small Index contract and how does it help DEX discovery?",
          "answer": "Small Index (bitcoincashresearch.org/t/1471) can tag many protocols per token category. Designed for CatDex but could handle Cauldron, Tapswap, and Dutch Auctions. Solves SPV wallet pool discovery if pools advertise using this method - would increase pool volume so they have incentive to adopt."
        },
        {
          "question": "What is Squid technology and how is it used with TapSwap?",
          "answer": "Squid is a blockchain indexing/query technology integrated into TapSwap at sqd.tapswap.cash/graphql. It provides a GraphQL interface for querying blockchain data related to the DEX. The technology enables efficient data access for the TapSwap application without requiring full node queries for every operation."
        },
        {
          "question": "What is TON blockchain malleability issue?",
          "answer": "Total Commander: Recently integrated TON and malleability in UTXO coins is nothing compared to what happens there - tx hash mutates on its own upon propagation. It's total nightmare when you don't use their proprietary indexers."
        },
        {
          "question": "What is alternative to executable bit for OP_EVAL?",
          "answer": "Have OP_DEFINE, then have to have OP_RUNDEFINED, then also have OP_GETDEFINED so can get definition on stack and hash it for verification. Then have to have OP_UNDEFINE maybe. Creates whole new stack for function definitions. Executable bit approach: use same opcodes to manage function stack rather than create whole new stack for function definitions."
        },
        {
          "question": "What is the DEX UTXO contention issue on Cauldron?",
          "answer": "Mempool conflicts occur due to arb bots competing - users create valid Cauldron transactions and push simultaneously to different node sets causing split. Trade not final until no mempool conflicts exist. With faster blocks, users wait for 1 confirmation which would be much shorter (2-4min vs 10-20min). Mempool is not good enough - needs better real-time synchronization or split rules for DeFi vs non-DeFi transactions."
        },
        {
          "question": "What is the DeFi-to-commerce 0-conf transition pain point?",
          "answer": "Suppose you do DeFi actions ending with 0-conf p2sh chain, then pay merchant with p2pkh - it has 0-conf p2sh ancestors so DSP score is 0 and merchant may demand 1 conf. With 10min target only 0.5% chance DeFi chain confirms during 1min user action lag, so 17min wait in 50% cases. With 1min blocks, DeFi likely confirmed - merchant accepts 0-conf, or worst case 1-3min wait."
        },
        {
          "question": "What is the deferred TXID assignment proposal for DEX transactions?",
          "answer": "Proposal: broadcast utxo+signature (checkdatasig) enabling asynchronous TX generation. User doesn't commit to specific TX/TXID - remains undefined until miner generates and mines transaction. TXID assigned once someone mines it. Only change required is in communication so miners can build TXs with this method."
        },
        {
          "question": "What is the permissioned vs permissionless DEX tradeoff?",
          "answer": "Server can increase UX (BCMR metadata, LP statistics, faster order books, secure reorder-free TX submission) and provide APIs with stability guarantees. Not all central servers are bad - only ones that lock you in. However, third-party signing requirement means operator can comply with government regulations. Alternative: thin indexers deployable by anyone with REST APIs for getting pools - treats Cauldron as protocol not service."
        },
        {
          "question": "What vulnerability did TapSwap nearly have?",
          "answer": "Almost blew up for silly reason: checked signature against pubkey provided in input but without authenticating it via committed hash. Example of footgun that has nothing to do with OP_EVAL - demonstrates fundamental contract safety doesn't change with eval."
        },
        {
          "question": "What was Pat's tapswap contract bug and fix?",
          "answer": "Pat's tapswap had bug: had spender provide pubkey but didn't have code to auth pubkey against hash - oops, now any key can unlock it. Bug quickly fixed - he swept them all and moved to new versions using the exploit haha. Shows contracts can ask for bytes in unsafe way, whether data or code."
        },
        {
          "question": "When is 0-conf considered final enough to proceed with DEX swaps?",
          "answer": "Users need to know there are no mempool conflicts. Issue exists for DeFi users who need certainty transactions won't reverse. Common case: user has tokens A,B,C, merchant wants token Z. Wallet creates p2sh swap chain to Z then p2pkh to merchant. P2PKH not DSP compatible due to unconfirmed p2sh parent."
        },
        {
          "question": "Why can't primary market maker use AMM for instant finality?",
          "answer": "If make up random number and it gets published to blockchain in completely decentralized way or used in perfectly decentralized protocol, decentralization after the fact doesn't change that source of data was single party. Primary market maker for crypto can profit from keeping lots of markets in sync - problem is, with current AMM and blocktime, can't get instant trade finality without also mining all the blocks."
        }
      ]
    },
    {
      "name": "Oracles & External Data",
      "description": "Oracle implementations, price feeds, external data integration, and off-chain data verification",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How do fiat-denominated recurring BCH payments work with oracles?",
          "answer": "For fiat-denominated recurring payments (e.g., $30/month), payouts use a specific fungible token (FT) with an oracle message as input. The oracle provides exchange rate data so contracts can calculate the correct BCH amount. Main limitation: contracts depend on oracle availability - if the oracle ends, the contract can't determine the correct conversion amount."
        },
        {
          "question": "How to achieve decentralized oracles?",
          "answer": "Ultimate answer: computers need to scan and certify real world information in way that cannot be faked (i.e. can be verified cryptographically). In each case, there is real human that does work to collect some data and provide it. This human is the centralized element. Replace that human, and you get decentralization."
        },
        {
          "question": "Is verifiable serializing AMM with centralized entity acceptable?",
          "answer": "Argument: verifiable serializing AMM using centralized entity is no-worse than price-oracles. Not possible to get USD/EUR prices using completely decentralized system because these currencies belong to centralized entities (governments). Even for on-blockchain tokens only, still centralized entity that extracts trade fees, so completely absolutely decentralized operation is impossible anyway."
        },
        {
          "question": "What are TXv5 read-only inputs and how do they benefit oracle protocols like d3lphi?",
          "answer": "Read-only inputs allow multiple transactions to reference the same UTXO without conflicting. For oracle protocols like d3lphi, this prevents users from fighting over oracle message UTXOs. Thousands of users can spend the same oracle UTXO (UTXO_A) read-only within minutes. This saves the intermediate transaction that would otherwise create multiple copies (B, C, D, E) of the oracle data."
        },
        {
          "question": "What are best practices for LLM-assisted BCH development?",
          "answer": "Crank up context window (32K tokens), stuff as much relevant information as possible into prompt. If have ZK code or Script examples, add those. Make scope very concise, provide feedback on error logs. Feed in external documentation for AI to review. Use one AI to generate code, feed to different AI to sanity check."
        },
        {
          "question": "What is gigahashcoin stable coin oracle mechanism?",
          "answer": "Gigahashcoin is ultimate 'stable' coin - price oracle as decentralized as mining. GH/BCH = (difficulty / block reward). With ASICs already far on development s-curve, should be less inflationary than fiat, but still inflationary. Others put up BCH collateral to mint GHC at oracle price."
        },
        {
          "question": "What oracle solution recommended for BCH prediction markets?",
          "answer": "Oracle itself is trivial (week's work for backend dev). Real challenge is data - entire business in itself. Financial data providers already exist with thousands of customers. Combining existing data businesses with oracle tech makes best approach for tens of thousands of tickers and prices. See read.cash/@TomZ/oracles-7bd61bb5 for details."
        }
      ]
    },
    {
      "name": "Zero-Knowledge Proofs & Privacy",
      "description": "ZKP implementation, privacy features, CashFusion, shielded transactions, and cryptographic privacy techniques",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can shielded addresses be implemented on BCH using ZK-STARKs?",
          "answer": "Shielded addresses that hide sender/receiver (but not amounts) are theoretically possible on BCH using existing opcodes without consensus changes. The challenge is that finding your funds requires testing every output with costly EC-mul operations. While a specialized ZK-STARK verifier opcode could improve efficiency, the polynomial arithmetic needed for zero-knowledge proofs can be implemented using current BCH Script opcodes."
        },
        {
          "question": "How do you set up DNS-over-HTTPS with Unbound and nginx?",
          "answer": "Running your own DNS-over-HTTPS resolver improves privacy and avoids ISP/government MITM. Melroy van den Berg provides config examples (gitlab.melroy.org/-/snippets/620) and blog series covering Unbound setup (blog.melroy.org/2025/dns-part-1/). This allows you to control DNS resolution instead of relying on potentially compromised public resolvers or ISP DNS."
        },
        {
          "question": "How does Tornado Cash ZKP mixer work?",
          "answer": "Fixed deposit tiers (1, 10, 100, 1000 BCH for indistinguishable amounts). On deposit get receipt. On withdraw: ZKP proves you own deposit cryptographically without revealing which specific deposit. Merkle trees track deposits. When withdrawing don't submit commitment for which you redeem - proves ownership of secret with data + keys, not specific receipt."
        },
        {
          "question": "How would ZK shielded transactions work on BCH?",
          "answer": "Users send BCH to a P2SH covenant address, receiving an NFT with random-looking 32 bytes in the commitment. To transact inside the shielded pool, provide a ZK proof as input script authorizing updates to NFT commitments. The covenant calculates/verifies encrypted balance updates according to ZK system math. To exit, provide a proof showing entitlement to BCH without revealing when you entered. All transactions look like one address transacting with itself to external observers."
        },
        {
          "question": "Is Tornado Cash possible on BCH with current tools?",
          "answer": "Yes with loops - possible to do ZKP verification. Other piece is merkle trees to track deposits. Would use OP_CHECKDATASIG for proof verification. See github.com/tornadocash/tornado-core/blob/master/contracts/Verifier.sol. Industry moved to ZKPs for sidechains, SPV 2-way peg proofs never took off."
        },
        {
          "question": "Is central signer for AMM trades comparable to CashFusion coordinator?",
          "answer": "Automated signature from centralized server that one can opt to use isn't that bad. Everything still public and has to be broadcast regardless. Attempts by service to cheat likely obvious with tx to sign not adding up if transaction(s) withheld. CashFusion has coordinator that has to be trusted to some degree - not much difference here."
        },
        {
          "question": "What are mobile background task limitations for BCH wallets?",
          "answer": "Android/iOS pedantic about conserving battery. Capacitor background runner is scheduled job running every X minutes (depends on platform, ~15min delay). Alternative: Push Notifications as 'wake up app' (requires Firebase for Google, ANS for Apple). Privacy tradeoff - backend needs to know addresses wallet monitors. Flowee Pay can run background without GUI for CashFusion when charging overnight."
        },
        {
          "question": "What are the advantages of ZK shielded pools over CashFusion?",
          "answer": "The main advantage is non-interactivity. With ZK pools, you can pay in, transact inside the shielded covenant, and pay out whenever you like without needing to wait for other participants. CashFusion requires coordination with other users to create coinjoin transactions. However, ZK proofs are large, resulting in big transactions. Optimal architecture (L1 per-user TXs vs privacy L2) remains undetermined."
        },
        {
          "question": "What are the differences between ZK-SNARKs and ZK-STARKs for BCH privacy?",
          "answer": "ZK-SNARKs require a trusted setup (potential backdoor) and use smaller proofs, while ZK-STARKs have no trusted setup, are quantum-resistant, but have larger proof sizes. The ZKP math is extremely complex - 100x harder to understand than Bitcoin's whitepaper. An average programmer with 20 years experience but no math-specific PhD won't understand ZKP whitepapers. This complexity raises concerns about implementing backdoors unintentionally."
        },
        {
          "question": "What challenges exist for BCH ZK privacy implementations?",
          "answer": "For Tornado Cash-style ZKPs, BCH needs a method to loop through all previously used nullifiers to prevent withdrawal replay/double-spends. ETH has global state and hash tables making this trivial, but BCH has no equivalent. Without this, implementations require challenge periods with bonds and merkle trees, making them less user-friendly than EVM chains. Additionally, proof sizes can't shrink without cryptographic breakthroughs."
        },
        {
          "question": "What is RPA (Reusable Payment Addresses) in Bitcoin Cash and how does it relate to privacy?",
          "answer": "RPA is a stealth address implementation on BCH that enables privacy-preserving reusable addresses. It works similarly to stealth addresses where the receiver can publish a single reusable address, but each payment goes to a unique on-chain address. Electron Cash supports RPA, though it's currently in alpha stage. RPA is more efficient and compatible than some alternatives and can work alongside CashFusion."
        },
        {
          "question": "What is Shadow's ZKAM-FMT for fiat verification?",
          "answer": "Shadow: ZKAM-FMT spec verifies browser TLS data and email data to confirm fiat payments have been made to onramp from FIAT. ZKP2P guys implemented similar idea. Can be done better - custom Firefox/Chromium variant watches for certain variables in document instead of browser plugin with proxies and TLS magic."
        },
        {
          "question": "What is Tom's advice for ZKP implementation on BCH?",
          "answer": "Doesn't make sense to want opcodes enabled on chain as first step. Instead work with team to make actual ZK script work by modifying full node privately. When it works fully and isn't hacked instantly, then look at what was needed and propose changes to main chain. Avoid wishful design behavior."
        },
        {
          "question": "What is ZKP2P hooks for BCH onramping?",
          "answer": "Luke/Shadow: ZKP2P hooks could be used with cross chain swaps like THORChain. Hook acts as robot - takes USDC from ZKP2P escrow and gives to THORChain with memo to swap for BCH and send to specific address. Could tap into zkp2p for trustless on/offramping into BCH."
        },
        {
          "question": "What is the difference between ZK-SNARKs and ZK-STARKs for BCH privacy?",
          "answer": "ZK-SNARKs require a trusted setup and use smaller proofs, while ZK-STARKs have no trusted setup, are quantum-resistant, but have larger proof sizes. For BCH, the discussion centers on using ZK-STARKs to hide sender and receiver addresses without hiding amounts. Implementation doesn't necessarily require new opcodes - existing math operations can perform the polynomial arithmetic needed."
        },
        {
          "question": "What privacy features are planned for BCH's May 2025 upgrade?",
          "answer": "Shielded transactions are being discussed as a possibility after the May 2025 network upgrade. This would complement existing privacy features like CashFusion and RPA (Reusable Payment Addresses). The shielded transaction capability would represent a significant enhancement to BCH's privacy toolkit beyond the current stealth address implementations."
        },
        {
          "question": "What wallet support exists for RPA (Reusable Payment Addresses) on BCH?",
          "answer": "Electron Cash currently supports RPA functionality. However, broader wallet adoption remains limited, with RPA still being considered an alpha product. Increased awareness and wallet provider adoption is needed before RPA becomes a mainstream privacy feature. Some wallets like Cake Wallet are being approached to add RPA and CashFusion support together."
        },
        {
          "question": "Why are advanced ZK systems currently impractical on BCH?",
          "answer": "While technically possible already, ZK verification is very impractical and expensive. Porting a zkVM's on-chain verification to 2025 BCH VM would cost ~10,000x typical BCH transaction fees with extremely limited wallet support. Most work involves workarounds rather than optimal implementations. Even building from scratch, the constraint differences encourage sub-optimal ZK constructions versus systems designed without program length concerns."
        },
        {
          "question": "Why is CashFusion trustless compared to other mixers?",
          "answer": "CashFusion requires no trust - needing to trust some parties is infinitely worse than not needing to trust any parties. This contrasts with staking-based approaches which add trust assumptions about who can replace commitments."
        }
      ]
    },
    {
      "name": "Mining & Consensus",
      "description": "Mining operations, consensus mechanisms, difficulty adjustment, block time, and miner economics",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can PoW difficulty serve as price oracle for fee adjustments?",
          "answer": "Research shows correlation between PoW difficulty and USD price (bitcoincashresearch.org/t/1426). Could be used for minimum relay fee algorithm - favorite angle for auto-adjusting fees because doesn't rely on third-party. Has some edges to work out but promising approach."
        },
        {
          "question": "Can miners bypass nSequence relative locktime enforcement?",
          "answer": "If nSequence is set, miners cannot mine the transaction until the input ages - this is consensus-level enforcement, not miner policy. However, if nSequence is not locked by signature, CSV, or introspection, a miner could change the value and mine the modified transaction ahead of time. Locking the nSequence value (via signature/script) is critical for trustless locktime enforcement."
        },
        {
          "question": "Can miners manipulate block fees for oracle pricing?",
          "answer": "Miners could mine blocks with extra unpublished transactions creating fees going back to themselves - 100% gameable. But other miners could try steal those fees via reorg. Packing fee is akin to wash trade - market buy and instant sell + risk of reorg and other miner taking your donation. If pack 10%-20% extra could skew feed without reorg risk."
        },
        {
          "question": "Do read-only inputs create MEV or attack vectors for miners?",
          "answer": "A miner could ignore transactions referencing a read-only UTXO while including a transaction that fully spends it, invalidating the read-only transactions. However, this is not economically incentivized - miners would be throwing away fees for no good reason. It's the same as existing double-spend scenarios, nothing fundamentally new regarding miner behavior."
        },
        {
          "question": "Does BCH have mining documentation for newbies?",
          "answer": "Shadow: Does not seem like BCH has documentation allowing newbies to start mining quickly. Last week there was guy who wanted to mine here and he could not find any precise docs plus nobody could help him directly. Certainly lacking but not extremely important issue."
        },
        {
          "question": "How can Starlink bandwidth be increased for mining operations?",
          "answer": "Multiple Starlink dishes can be used to increase bandwidth (starlink-enterprise-guide.readme.io/docs/using-multiple-starlinks). Starlink provides ~50ms latency which is sufficient for mining. Combined with improving LEO satellite constellations over 10-20 years, could bring everyone close to speed-of-light limits for global connectivity."
        },
        {
          "question": "How do miners and relay fees interact with fee markets?",
          "answer": "Lowering relay fee shouldn't require consensus - some miners already only mine TXs above certain fee (saw 7sat/byte minimum). Miners can accept lower fee TXs to include as space allows, though may put them at orphan disadvantage. If demand exists, miners will lower min fee with prodding if it gets them more revenue."
        },
        {
          "question": "How does ASERT DAA adapt to block time changes?",
          "answer": "ASERT is time-based, invariant of target block time. Adjustment won't be faster, just smoother - done in smaller increments/decrements. If had enough power to halve or double difficulty after 2 days - continues to be case with shorter blocks, just done in greater number of smaller adjustments. Same with ABLA - same 2x/year annualized rate limit in smaller steps. gitlab.com/0353F40E/fablous#difficulty-adjustment-algorithm-daa"
        },
        {
          "question": "How does network topology affect 1-conf reorg experience with first-seen rule?",
          "answer": "1-conf reorgs happen with 1st-seen rule due to connection quality disparities. Miners with worse connection have higher chance of losing the race. Users close to slow miners have higher chance of witnessing TX reorgs. Header-first mitigates bandwidth but not ping - if 80% hash is on one side of planet and 20% on opposite, the 20% has ~300ms disadvantage (0.05% orphan rate at 10min, 0.5% at 1min blocks)."
        },
        {
          "question": "How does the H(A||B) deterministic tiebreaker affect block replacement difficulty?",
          "answer": "To flip a known block A with block B requires satisfying BOTH network difficulty AND winning H(A||B) comparison - making it 2x harder than just satisfying network difficulty. This is a tie-breaker only for same-height contention, not an override. One block can't replace two blocks even if tip's hash would win."
        },
        {
          "question": "What are the hardware constraints that make header-first mining attractive?",
          "answer": "Miners face hardware problem: can't turn off mining during validation without damage. Going from zero to 100 ampere in milliseconds creates massive power fluctuations causing hardware reboots. Options: (1) keep mining old block (risk orphan), or (2) mine empty block on new header until validation completes. Most choose option 2 (header-first)."
        },
        {
          "question": "What attack vector exists with deterministic block tiebreaker for high-fee blocks?",
          "answer": "If a block has extraordinarily high fees (like 3x usual), miners could be incentivized to keep mining at same height since there's 50/50 chance their block wins H(A||B) and all other miners would switch. This creates unknown unknowns where miners might continue mining at tip-1 to hurt another miner with little risk instead of mining on tip."
        },
        {
          "question": "What is Infrastructure Blocks (iBCH) and how does it relate to BCH?",
          "answer": "iBCH is a CashToken that enables experimental features BCH cannot have (10s block time, higher inflation, higher orphan rate). BCH serves as gas, so you always need BCH to use iBCH. It's supplementary, not superior - intentionally flawed (higher orphan rate, more inflation) but does things BCH cannot do like controversial features without burdening main chain."
        },
        {
          "question": "What is header-first mining and why do some pools not use it?",
          "answer": "Header-first allows miners to immediately start mining on new block using just the header (before full validation) but must mine empty block to avoid invalid UTXO spending. Most pools use it, but Foundry doesn't. Reasons: BTC's 1MB limit makes bandwidth impact insignificant, Foundry is majority so doesn't lose much from validation time, and as fees dominate subsidy header-first becomes less attractive (empty blocks lose fee revenue)."
        },
        {
          "question": "What is the FUD concern about block time change?",
          "answer": "Changing block time creates FUD opportunity: 'changing block time will mean inflation goes up by same factor.' Vast majority never hit problems this solves, so it's a tax. Chain hasn't grown much in 5 years - doing this now could drain chance of winning."
        },
        {
          "question": "What is the argument about faster block times being contentious?",
          "answer": "Block time isn't technically specified in whitepaper (only referenced as example). Despite practical benefits, changing it could be contentious due to ecosystem inertia. Some argue existing permissionless solutions should be implemented first before considering consensus changes."
        },
        {
          "question": "What is the argument for adjustable block time?",
          "answer": "Proposal: reduce time to 1min now, make it adjustable without breaking again so future can go to 30s, 20s, maybe 10s once LEO sats ubiquitous - by just changing number in code and activating. Pay most of cost now, reap benefits forever."
        },
        {
          "question": "What is the deterministic tiebreaker proposal for Bitcoin block selection?",
          "answer": "Proposed solution (bitcoincashresearch.org/t/1532) uses H(A||B) hash comparison as objective tiebreaker for same-height blocks instead of subjective 1st-seen rule. When two blocks have equal chainwork, nodes would switch to the block that wins H(A||B) test. Aims to enhance fairness and convergence, particularly relevant for faster block times (1min blocks would have 0.5% orphan rate from 300ms ping difference)."
        },
        {
          "question": "What motivated research into deterministic block selection tiebreakers?",
          "answer": "Research started from asking: 'Why are orphan rates a problem?' and 'How high could we tolerate?' Key insight: if everyone had equal orphan rates they wouldn't be a problem. Led to question: 'If we have to have some orphans, is there a way to equalize orphan rates across pools?' Goal is enabling faster blocks (10s blocks possible in 10-20 years with better connectivity)."
        },
        {
          "question": "Why do orphan rates matter less if they're equal across all pools?",
          "answer": "If everyone had equal orphan rates, impact would be like a price drop - everyone affected equally. The inequality is what's dangerous for the network. Actual orphan rate is less than one block per week. With 2min blocks maybe 1 every few days. Formula for max orphan rates is just a limit - actual doesn't grow proportionally."
        },
        {
          "question": "Why is BCH not a good timestamp server?",
          "answer": "Bitcoin is *not* a good timestamp server but could be - if future time limit was more tight and monotonic timestamps enforced (zawy12 github issue). Block time used as extended nonce bits to find valid PoW. As difficulty goes up, timestamp used more in lieu of new block template resulting in new merkle proof."
        },
        {
          "question": "Why is block time benefit curve considered non-linear?",
          "answer": "2.5 minutes isn't twice as good as 5 minutes - it still sucks if waiting for confirmation. Real benefits seen at sub-10s where user can watch screen and take action if TX not confirmed. But sub-10s not reasonable with today's tech."
        },
        {
          "question": "Why is dust limit necessary and how should it work?",
          "answer": "Controls state bloat - critical for scaling. Should be enforced on UTXO creation but NOT on spending. No reason to prevent cleaning up 0 or 1 sat outputs - want easy state removal. Proposal: halve every 4 years conditional on difficulty at least doubling (difficulty = proxy for coin value growth vs real world)."
        },
        {
          "question": "Why is orphan rate inequality more problematic than the absolute orphan rate?",
          "answer": "If everyone had equal orphan rates, it would have the same impact as a price drop - everyone affected equally. The inequality is what's dangerous for the network. BCH's actual orphan rate is less than one block per week. The formula for max orphan rates is simply a limit, not the actual rate."
        }
      ]
    },
    {
      "name": "Networking & P2P",
      "description": "Peer-to-peer networking, protocol messages, mempool behavior, block propagation, and network topology",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can HTTP-based p2p networks form true mesh?",
          "answer": "Tom/BCA: VAST majority of http users are behind NAT and short-lived. Yes you can replicate Satoshi's design - clients connect and share IPs of other clients etc. But individual users very unlikely to actually be part of real mesh due to NAT and connection constraints."
        },
        {
          "question": "How common are double spends on BCH?",
          "answer": "Richard/Emergent: Double spends are normal and happen more often than one might think. Easy to accidentally create them in automated/procedural systems that aren't mature yet. Network rejects double spends and over electrum you'll always see consistent view of chain."
        },
        {
          "question": "How did BCA learn BCH p2p layer?",
          "answer": "Shadow: You sent TX manually using Linux console tools? You must have been really bored. BCA: I wanted to learn how p2p layer stuff works, it was good opportunity. Like I did this just by reading the spec - sent transaction manually via console."
        },
        {
          "question": "How do block size and latency relate to propagation bottlenecks?",
          "answer": "The smaller the blocks, the more weight latency has. The larger the blocks, the more weight bandwidth has. With small blocks (like BTC's 1MB), bandwidth's impact on propagation time is insignificant - latency dominates. For larger blocks, bandwidth becomes the bottleneck."
        },
        {
          "question": "How does 0-conf p2sh ancestor affect p2pkh safety?",
          "answer": "0-conf p2sh ancestor makes p2pkh 0-conf much less reliable. Problem can spread to other non-DeFi transactions. Either needs split in rules or better real-time synchronization. If propagation meets where conflicts exist, it stops and DSP is generated instead of propagating conflict."
        },
        {
          "question": "How does Nostr achieve censorship resistance?",
          "answer": "Kallisti: Nostr is a hydra. Censorship-resistant property comes from simplicity of protocol - spinning up relay is super simple. Even if you got banned from all popular relays or all maxi clients block your relay, you and your friends/followers can still use your relay/client or some neutral relay/client."
        },
        {
          "question": "How does Nostr relay architecture work?",
          "answer": "Kallisti: Nostr relays don't sync with each other. It's just client-server where client connects to many independent servers and client does what it will with whatever data those servers serve. All glued together by pubkey crypto."
        },
        {
          "question": "How does mintxfee parameter work in BCHN?",
          "answer": "Mintxfee setting (fees in BCH/kB smaller than this considered zero fee for transaction creation, default: 0.00001). Can be set lower than 1 sat/byte using fractional BCH/kB values. Creation != relay so that setting might not make transactions propagate without corresponding relay setting."
        },
        {
          "question": "How does nakamoto-cash handle MerkleBlock fetching?",
          "answer": "Uses concurrent approach mapping new peer after every 25k block range. May receive higher height blocks before lower ones. Can tweak rescan and BloomManager for different strategy. Added get MerkleBlocks button with sliders to adjust start/stop ranges in examples/ dir. 25k is 6 months of blocks - may be bit much."
        },
        {
          "question": "What factors affect network latency besides distance?",
          "answer": "Speed of light varies by medium (faster through air than glass). Total factors: routing overheads (number of hops), total distance, interference, and medium. Fiber has less interference and fewer hops but slower light speed than air. Starlink has ~50ms latency - terrible vs fiber, great vs many less-wired countries."
        },
        {
          "question": "What is LibP2P exploration for BCH WalletConnect alternative?",
          "answer": "Jim exploring LibP2P as generalized solution. Allows WC-like functionality plus perks: run web-accessible Fulcrum/Chaingraph/backends from home, run web-accessible BCH-P2P subnet on LibP2P (encrypts everything, effective against deep-packet inspection). Still have hesitations on LibP2P libs stability."
        },
        {
          "question": "What is Starlink's satellite-to-satellite low latency capability?",
          "answer": "Normal Starlink has ~50ms latency bouncing land uplink off nearest sat. They also have capability to offer very low bandwidth ultra low latency beaming between sats on their global sat-to-sat network links. Sats are redundant and disposable - 'just make them cheap and let them fall' approach to LEO orbit loss."
        },
        {
          "question": "What is Yggdrasil mesh networking?",
          "answer": "Tom: Yggdrasil is mesh networking tech that replaces tcp/ip layer. Excellent concept, needs to be used more. Reminds of power where app and wallet on same local network can communicate directly without centralized server."
        },
        {
          "question": "What is concern about DeFi vs peer-to-peer cash focus?",
          "answer": "Goal is peer to peer cash - without healthy growth there, chain will die. DeFi/tokens filling blocks only marginally better than ordinals on BTC. Use them as advertising for real game, but never lose sight of native token being real product. Need stability - currencies stabilized with sound derivatives."
        },
        {
          "question": "What is network effect strategy for BCH development?",
          "answer": "Focus on BCH first - don't prioritize retaining builders with foot out door or maintaining compatibility with other chains. Network effect comes from unique features others want to copy. Thriving BCH motivates others to integrate. Catering to integrators gets neither BCH improvements nor integration. Weighted network nodes (100% BCH focused) exponentially more impactful."
        },
        {
          "question": "What is the Rust nakamoto package p2p client example?",
          "answer": "A light p2p client example app (github.com/samrock5000/p2p-client/tree/master/examples) using rust nakamoto package. Toy app lets you update bloom filter from input form and send 'loadfilter' message to peers. Detects BCH addresses and hex encoded data. Future plans include merkleblock fetching and inclusion proof validation. Builds on Linux and macOS."
        },
        {
          "question": "What is the history of FindBitcoin.cash / GeoDrop.cash?",
          "answer": "FindBitcoin.cash (later GeoDrop.cash) was a proof-of-concept built during a hackathon by Chris Troutner, Daniel Humgon, Lightswarm, and architect/erik (devpost.com/software/purelypeer). It used SLP and was maintained by Chris afterward. The idea evolved to PurelyPeer.cash with a new team. It was a webapp inherently prone to geospoofing; PurelyPeer mobile-only execution helps prevent geospoofing."
        },
        {
          "question": "Why doesn't DSProof catch all double-spends?",
          "answer": "DSP won't catch nuked parent p2sh. Requirements: transaction must contain all P2PKH, must either spend only from confirmed UTXOs OR all mempool ancestors must also be all-P2PKH transactions. All inputs and mempool ancestor chain must be SIGHASH_ALL without ANYONECANPAY. P2sh ancestor means DSP score of 0 - NOT COVERED by DSPs."
        },
        {
          "question": "Why introduce sub-satoshi (millisat) precision and how does it affect miners?",
          "answer": "At $100M/BCH, 1 sat/byte fees would be $219 USD per transaction - too high for BCH's low-fee goal. Millisats allow 1 msat/byte ($0.219 USD) fees. The minrelayfee exists for network health (UTXO set size, economic value), not miner compensation. It doesn't change with subsats unless needed. Miners already control fee acceptance - they can mine empty blocks or accept below-minrelay fees via direct submission."
        }
      ]
    },
    {
      "name": "Scalability & Performance",
      "description": "Scaling solutions, transaction throughput, UTXO management, optimization techniques, and performance considerations",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How are UTXOs stored and managed?",
          "answer": "UTXO stored on disk, only loaded to memory when spending. Optimization of keeping old UTXOs on disk vs memory already implemented. Taking UTXOs not moved in years and keeping on disk reduces cost significantly, slightly more costly to load when needed (plus IBD with UTXO commitments)."
        },
        {
          "question": "How can multiple users use same DEX UTXOs without conflicts?",
          "answer": "Core question: multiple users want to use same set of UTXOs at same time - how without leading to ignored transactions? Could use blind limit orders so miners/platforms match them. Opens MEV opportunities but from user POV pays with MEV for execution success. Risk: user makes trades thinking profit only to have it removed."
        },
        {
          "question": "How to get UTXO composition info with mainnet-js?",
          "answer": "await wallet.getAddressUtxos() to see UTXO info directly. Fee handling abstracted away - this is feature. Depending on whether balance is 5 $100 bills or 100 $5 bills, bitcoin fee will be different. Need to know what fee to pay to know if have enough. JS library and REST service should have identical API to extent possible. Frontend supports watch wallets."
        },
        {
          "question": "Is UTXO contention a problem for BCH?",
          "answer": "Emergent/Tom: UTXO contention is real issue BCH going to need to face. Not clear yet exactly what tradeoffs are in various solutions. Wallet or app can create more UTXOs for nearly free. Worst case is regular mempool divergences, best case nothing burger."
        },
        {
          "question": "What are read-only UTXOs from TXv5 proposal?",
          "answer": "Jason's TXv5 idea: input that doesn't get spent. Any input can be marked as RO in transaction which causes UTXO to not be removed from UTXO set. Neat idea but many details to iron out before feasible."
        },
        {
          "question": "What mempool management challenges do read-only inputs create?",
          "answer": "Nodes must keep spent UTXOs in memory until mined because new valid transactions might reference them read-only. Example: UTXO_A has thousands of read-only spends plus one non-read-only spend creating UTXO_B (new oracle message). Before mining, miners are incentivized to accept more transactions spending UTXO_A since they don't conflict and all pay fees. This complicates mempool eviction and resource management."
        },
        {
          "question": "Why can't read-only UTXOs work with global state?",
          "answer": "Read-only UTXOs would be special: indestructible and non-contentious (many txs can spend same one). But it's hacky way to get global function table. Without ownership they can't be burnt, leading to UTXO set pollution. Can't make well-scaling coin with global state."
        }
      ]
    },
    {
      "name": "Security & Best Practices",
      "description": "Security considerations, common vulnerabilities, footguns, auditing, and contract safety patterns",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "What are the security tradeoffs of StableHedge's centralized treasury?",
          "answer": "A rug is possible with multisig treasury control, and hack/loss of controlling keys is also a risk. Improvements could include partial withdrawal with renewed timelocks (e.g., max 10% every 10 days) to slow down potential rugs. The risk is mostly taken by hedgers. Paytaca is expected to limit funds to what's needed for merchant onboarding, avoiding disproportionate $5 wrench attack risks to team members."
        },
        {
          "question": "What is Distrust chain of trust concept?",
          "answer": "Farooq reviews codebase and declares it good. Then Benjamin trusts Farooq and any code Farooq marked as reviewed, Benjamin also considers good. So if Simon trusts Benjamin, he automatically trusts Farooq too. Hierarchical web of trust for supply chain security."
        },
        {
          "question": "What was Kaspa state bloat attack and solution?",
          "answer": "Kaspa attacked by intentional state bloat. KIP-0009 introduced transaction mass function to limit state bloat. Previously had compute cost, added storage cost. BCH has generic per-byte fee (friction). See github.com/kaspanet/kips/blob/master/kip-0009.md"
        },
        {
          "question": "Why is not having OP_EVAL worse for security?",
          "answer": "People wanting eval functionality will emulate in convoluted ways harder to analyze than plain eval, with more footgunning opportunities. Same exotic uses already possible with introspection. Safety guardrails require convoluted methods to achieve simple things."
        },
        {
          "question": "Why was BCH targeted in npm supply chain attack?",
          "answer": "Scammers perceive BCH as big and important enough to attack. Good news in a way - no BCH wallets or services affected AFAIR. Jim: phishing mails comp'd so many projects past months becoming big problem. Sticky even patch versions of dev libraries now and run dev envs using docker-compose containers."
        }
      ]
    },
    {
      "name": "Testing & Debugging",
      "description": "Testing strategies, debugging tools, chipnet, testnet, and development workflows",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How do you run the mainnet-js REST API server?",
          "answer": "The mainnet-js REST API server setup is documented at mainnet.cash/tutorial/running-rest.html. By default it tries to use regtest, which requires running a local node. To use a public node instead for initial testing, you need to configure the network settings. For production, you should learn how to run a node and connect it to regtest or mainnet."
        },
        {
          "question": "How does testnet usage relate to formal proposal analysis?",
          "answer": "Have perfectly good testnet environment for formal analysis. With crowdfunding, wouldn't be hard to present findings in more academic way than chatting. Arguments better presented when accompanied by peer-reviewable hard data - sandbox testing feasible for proposals evaluation."
        },
        {
          "question": "How to use Electron Cash on chipnet?",
          "answer": "Start from command line with --chipnet flag. Example: electron-cash --chipnet. No GUI option - must use command line. Chipnet vs testnet4: chipnet for CHIP testing, testnet4 general purpose, chipnet upgrades 6mo before mainnet. Use chipnet by default for less issues with CashScript and other tools."
        },
        {
          "question": "What Blockbook fundraising proposal controversy?",
          "answer": "10 BCH for research codebase/database/build/test - Jeremy questioned if 15 minutes with Cursor. 5 BCH for QA - debate if bugs should fall under feature cost. Counter: understanding codebase can take week to build mental model, answering 'how to best architect this' takes time. AI iterations still needed."
        },
        {
          "question": "What are CashScript v0.11.0 major features?",
          "answer": "Debugging capabilities for new transaction builder - allows transaction builder to work with local testing/debugging using mocknet and inside Bitauth IDE. Half year in works with multiple pre-releases to iron out edge cases. Migration notes on docs website help deal with breaking changes."
        },
        {
          "question": "What is txvulcano and when is it useful?",
          "answer": "txvulcano (ships with Flowee) is tool for generating transactions - useful for new chains/regtest chains. Not as useful for newer chains since included wallet is too simplistic. Can fill blockchain with test transactions."
        },
        {
          "question": "What network should BCH contracts testing use?",
          "answer": "Use chipnet by default for less issues. Chipnet upgrades 6mo before mainnet. For time-based contracts use --regtest - can mine blocks in batches to regression test scripts in time automatically. mainnet-js, unspent.app, futurebitcoin.cash all use same docker-compose setup. Tom tests on mainnet or testnet4. Electron Cash: start with --chipnet flag."
        }
      ]
    },
    {
      "name": "Integration & Interoperability",
      "description": "Cross-platform integration, Nostr, other blockchain bridges, and external service connections",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How can BCH addresses be derived from Nostr pubkeys for tipping services?",
          "answer": "A server-side approach combines the Nostr pubkey with a secret to auto-generate a master BCH private key per pubkey. This master node then generates additional key pairs on demand for tracking content and tippers. This allows tracking UTXOs tied to each receiver's content, creating 'top lists' based on tips received, and posting signed Nostr reply messages showing the tip."
        },
        {
          "question": "How can BCH receive addresses be added to Nostr profile metadata?",
          "answer": "Nostr metadata already supports custom fields that can store BCH addresses. Add a 'bchAddr' or 'bitcoincash' tag to the profile's event 0 metadata JSON containing the BCH address. The infrastructure exists, but broad adoption requires Nostr clients to display and allow editing these fields. A coin-agnostic NIP using a 'tips' field with comma-separated addresses would enable multi-chain support."
        },
        {
          "question": "How to convert Nostr npub to BCH address?",
          "answer": "Nostr nsec are compatible with any secp256k1 chain. Draft NIP allows conversion of npub (addresses identifying Nostr users) to BCH address - enables direct payments and tipping between Nostr users with BCH. Example code: github.com/christroutner/nostr-sandbox/blob/master/16-npub-to-BCH-addr/npub-to-bch.js. Long term: wallets like Cashonize could add Nostr feature to social media directly and receive value on chain."
        },
        {
          "question": "How to generate BCH address from Nostr npub?",
          "answer": "Figured out how to generate BCH address directly from Nostr npub. Don't even need user to add BCH address to Kind 0 post. Can derive directly from npub and know they can spend using private key (nsec) used to generate npub. github.com/christroutner/nostr-sandbox/blob/master/16-npub-to-BCH-addr/npub-to-bch.js"
        },
        {
          "question": "Is Nostr protocol permissionless for BCH usage?",
          "answer": "Kallisti: You're not dependent on any BTC infrastructure at all and doesn't matter if they don't accept your NIPs. Just steal an event ID and do whatever you want lol it's just software. Nostr is permissionless."
        },
        {
          "question": "What are the adoption challenges for BCH integration in Nostr clients?",
          "answer": "Most native Android and iOS Nostr clients are managed by BTC maximalists unlikely to adopt BCH solutions. Beyond technical implementation, there are significant political and community hurdles. Building initial proof-of-concept custodial solutions that work across all clients can help demonstrate use cases before tackling the harder problem of convincing individual client developers to add wallet functionality."
        },
        {
          "question": "What are the challenges of integrating BCH wallets into Nostr clients?",
          "answer": "The main challenges are: 1) convincing Nostr client developers to add wallet library features when full wallet integration is a much larger project than typical clients, 2) receivers need to configure BCH addresses in advance before receiving funds, and 3) achieving adoption across multiple popular clients. A simpler approach uses custodial third-party services requiring minimal client-side integration work, similar to Lightning's model in Nostr."
        },
        {
          "question": "What are the tradeoffs between custodial and non-custodial BCH tipping on Nostr?",
          "answer": "Custodial solutions are simpler to implement and work out-of-the-box with all existing Nostr clients with minimal integration (just adding a link per note). Non-custodial solutions require extensive work integrating wallet functionality and node connectivity into multiple Nostr clients. While custodial approaches sacrifice trustlessness, they enable testing use cases and building userbase before tackling complex non-custodial implementations."
        },
        {
          "question": "What is Nostr Pumps and how does it integrate BCH with Nostr?",
          "answer": "Nostr Pumps (pump.coinmachin.es and pumpstr.coinmachin.es) is the first Nostr client with BCH tipping embedded, including a developer's guide for integration. It supports nsec/secret key login for mobile phones (iOS/Android) until better Nostr plugins are available. The client enables BCH-based 'pumps' (tips) tied to Nostr notes, testing BCH adoption within the Nostr community."
        },
        {
          "question": "What is SLP DEX Nostr integration roadmap?",
          "answer": "SLP DEX (dex.psfoundation.info) is BCH wallet with Nostr integrated. Has basic social media functions, recently added Likes. Figured out how to 'Like' SLP tokens and working on integrating that. Next will let people post directly on tokens - nice merging of BCH, Tokens, and Nostr technology."
        },
        {
          "question": "Why can't Nostr keypairs be used directly with BCH transactions?",
          "answer": "Nostr uses BIP-340 BTC-style Schnorr signatures while BCH uses a different keypair scheme. The same private key generates different public keys in each system. If you send BCH to a Nostr pubkey address, the recipient cannot spend it using their Nostr private key because the keypair derivation is incompatible between the two systems."
        }
      ]
    },
    {
      "name": "Use Cases & Applications",
      "description": "Real-world applications, use case examples, domain names (BitCANN), fundraising, and practical implementations",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How do time-locked vaults protect users from mistakes?",
          "answer": "Jonathan: Smart educated people sometimes make mistakes, but if they set up time-locked vault when in good state of mind and have time to be careful, it protects them in future when they are of poor state of mind, under stress or other influences."
        },
        {
          "question": "How do transaction dependency graphs work with read-only inputs?",
          "answer": "Dependencies remain a DAG (Directed Acyclic Graph). Spending output A to create B, C, D, E, then spending those is equivalent to referencing A four times read-only to create the same outputs. In either case, if A gets removed (e.g., reorg), the entire descendant graph must be removed. Read-only inputs save the intermediate transaction creating copies but maintain the same dependency invalidation semantics."
        },
        {
          "question": "What are common JSX syntax restrictions that cause React errors?",
          "answer": "HTML nesting rules apply in JSX. A common error is placing block elements like <ul> inside inline elements like <p> - this is invalid HTML and React will throw 'Hydration failed' errors. Replace <p> with <div> when nesting lists, or remove the <p> wrapper entirely. JSX enforces stricter HTML validity than browsers which may render invalid markup."
        },
        {
          "question": "What domain registration issues affect BCH ecosystem?",
          "answer": "Bitcoinfees.cash expired on namecheap (though renewed later). Domain squatters use services like sedo.com with high minimum bids. Dot .io domains aren't awesome due to colonial history (British Indian Ocean Territory). Need to track critical ecosystem domains to prevent loss."
        },
        {
          "question": "What is Ethereum blind signing problem?",
          "answer": "J Master Pig: In Ethereum, users can't really see exact functions being executed, they are blind signing and just trusting address and domain unless they do serious deep dive. Signing is last line of defense, but if not structurally clear what they're signing, hard to catch malicious logic."
        },
        {
          "question": "What is current state of NIP process?",
          "answer": "Tom/Chris: Fiatjaf posted about changing NIP process because it's basically frozen and dead. Whole NIP process moving to 'everything is a draft, nothing is official'. NIP28 gets hate, most mirrors don't include it, but it works and people built software around it."
        },
        {
          "question": "What is the 80/20 rule in software development?",
          "answer": "The Pareto Principle in software states that 80% of a program can be written in 20% of the allocated time. The remaining 20% of features and bug fixes consume 80% of development time. This explains why initial implementations are fast but polish and edge cases take disproportionately longer. It's why 'don't let perfect be the enemy of good' is a common engineering philosophy."
        },
        {
          "question": "What is the counter-argument favoring faster blocks now?",
          "answer": "Having more robust futureproofed template encourages devs. Chain with less issues used by more people is encouraging. This is great time to do it - before/while people build, not after massive ecosystems exist. Fixed time spent, reap benefits forever - infinite ROI."
        }
      ]
    },
    {
      "name": "Documentation & Learning",
      "description": "Educational resources, documentation, tutorials, community learning, and developer onboarding",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How should documentation be formatted for LLM RAG databases?",
          "answer": "Ideal size is 2-3 paragraphs for documents in RAG database. Can't just add single large document or code base - must break up into small chunks so LLM can retrieve 'reminder snippets'. Use AI to break large docs into multiple markdown docs as pre-processing step. See github.com/christroutner/ben-training-data for examples."
        },
        {
          "question": "What are the BCH Devs & Builders chat ground rules?",
          "answer": "High signal low noise chat focused on BCH development. Constructive criticism welcome. When discussion gets long, consider if hundreds want to read it - take elsewhere or agree to disagree. No beating dead horses. Learn to DNE (Do Not Engage) if someone engages in bad faith."
        },
        {
          "question": "What are the benefits and risks of using AI tools like Grok for technical documentation?",
          "answer": "Grok can be useful for polishing documentation and enabling shared context through conversation links - anyone can continue from an already-set-up context. However, you must check everything the AI produces, as LLMs hallucinate when they don't know something. The new Grok 3 generation is reportedly more impressive, but complete removal of hallucinations is impossible since LLMs cannot be debugged like normal code."
        },
        {
          "question": "Why is decentralized educational content better than one centralized hub?",
          "answer": "Multiple educational sites provide redundancy and reach more people. BTC and ETH don't have single giant educational websites - large communities naturally produce several perspectives on the same topics. A group of interlinked sites allows exploration as the web was designed. Also, starting with 'educational website' is an easy entry point that often leads developers to more complex projects."
        }
      ]
    },
    {
      "name": "Community & Governance",
      "description": "Community processes, funding mechanisms, Flipstarter, governance, and ecosystem coordination",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How does community DAO funding work with BCH?",
          "answer": "BCA: Main problem with DAOs was they invite intermediaries but there's a way to hold dao accountable. Everyone's payment into dao is tracked, when dao pays out it takes same % from everyone's original payment. If not happy with what dao funds anymore - can pull out remainder of your money. Prevents money trapping."
        },
        {
          "question": "What alternative approaches exist for managing chat quality?",
          "answer": "Could require BCH bond in suitable/escalating amount which gets forfeit to community if continue to receive pushback (via regular vote). Could add cap of number/length of posts/words per time unit for people unable to observe social norms or obsessive about trivial nonsense."
        },
        {
          "question": "What are OpenCashDAO npm packages?",
          "answer": "Initial unstable versions: @opencashdao/contracts (github.com/OpenCashDAO/opencashdao-contracts) and @opencashdao/core (github.com/OpenCashDAO/opencashdao-core). Available on npm. Repos open for contributions. Telegram: t.me/opencashdao"
        },
        {
          "question": "What are tax implications of Flipstarter vs NFT fundraising?",
          "answer": "Flipstarter contributions are gifts (tax hassle, gift tax rules apply in US). Data analysis companies don't identify Flipstarter TXs automatically. Buying NFT for 5-10 BCH much less hassle than Flipstarter. UK example: can only gift 3000/year before affecting inheritance. Buying NFT for 10k doesn't trigger this - if sell for 5 it's cap gains loss."
        },
        {
          "question": "What is OpenCashDAO and what features does it provide?",
          "answer": "OpenCashDAO (bitcoincashresearch.org/t/opencashdao/1521, github.com/OpenCashDAO/contracts) is a DAO template with voting, proposals, and upgradable contract system. The base design pattern enables many applications like BitCANN. It demonstrates advanced covenant patterns for decentralized governance on BCH. Discussion group: t.me/opencashdao."
        },
        {
          "question": "What legal issues affect token distribution in crowdfunding?",
          "answer": "Creating tokens as part of campaign's claim TX easily done - on list for new cashstarter contract after bliss. However, putting limiter on collecting funding (target goal) might still classify as crowdfund bringing legal issues. Canada has crowdfunding-specific laws assuming custodial control. Worst-case: same regulation requirements as major bank."
        },
        {
          "question": "Why is concern trolling problematic in development chats?",
          "answer": "Concern trollers prolific in low moderation groups. 1 poorly adjusted person can cause grief for 10,000 others. Community must decide: change global reserve currency, or protect feelings of every socially maladjusted person. Exceptional cases must be treated exceptionally."
        },
        {
          "question": "What is the moderation philosophy for technical communities?",
          "answer": "Prefer not to heavily police chat - self-regulate and move off-topic discussions elsewhere. However, repeat offenders who drag chat down will be muted/banned. Generally had great signal-to-noise ratio with people keeping things professional and focused."
        }
      ]
    },
    {
      "name": "CashTokens Fundamentals",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is the fundamental difference between CashTokens and SLP tokens?",
          "answer": "CashTokens are part of the UTXO data model - they're native consensus-layer tokens embedded directly in transaction outputs. SLP tokens are an off-chain data convention that uses OP_RETURN metadata interpreted by indexers. CashTokens have native validation by all nodes, while SLP requires specialized indexers to track validity."
        },
        {
          "question": "How do CashTokens solve SLP's indexing problem?",
          "answer": "CashTokens fix the major SLP indexing problem by being consensus-validated at the UTXO level. SLP required specialized indexers to track validity across transactions, creating reliability issues. CashTokens are native to the UTXO data model with on-chain validation. However, CashTokens are currently harder to work with for developers than SLP was, as SLP had extensive tooling developed over time."
        },
        {
          "question": "What is the relationship between category IDs and fungible/non-fungible tokens?",
          "answer": "Category IDs are the parent of any combination of fungible and non-fungible tokens. A single category can contain both FTs and NFTs simultaneously. Common developer mistake: not understanding that category ID is the umbrella identifier, and different token types (FT, NFT with different commitments) can coexist under one category. The category ID comes from the genesis transaction's VOUT 0."
        },
        {
          "question": "Can you have both an NFT and fungible tokens in the same UTXO?",
          "answer": "Yes, you can have both an NFT and fungible tokens on the same UTXO as long as they share the same token category (tokenId). Each UTXO can hold exactly 1 token category, but that category can contain both NFT and FT components simultaneously. Example implementations include Popcorn and various covenant patterns."
        },
        {
          "question": "What is required for CashToken genesis transactions?",
          "answer": "Token genesis requires a VOUT 0 output. The new tokens will have tokenId equal to the TxId of that Vout0 UTXO. This creates the category ID that all tokens/NFTs in that category will share. See spec graphic at cashtokens.org/docs/spec/chip/#token-categories. The genesis transaction is the only time new token categories can be created."
        },
        {
          "question": "Can CashToken genesis transactions send to multiple addresses?",
          "answer": "Yes, CashToken genesis transactions can send newly minted tokens to multiple different addresses in a single transaction. This allows distributing the initial token supply across multiple recipients atomically during genesis."
        },
        {
          "question": "What is the proposed naming convention for token atomic units on BCH?",
          "answer": "The proposed term is 'tau' (plural 'taus'), derived from 'token-atomic-unit' which happens to be a Greek letter. For example: '100 taus of musd' equals 1.00 MUSD. The community agreed NOT to use 'sats' as the term to differentiate from Bitcoin terminology."
        },
        {
          "question": "Where are CashToken supply concepts (total, circulating, reserve) officially defined?",
          "answer": "Defined in the CashTokens CHIP at cashtokens.org/docs/spec/chip#fungible-token-supply-definitions. Total supply is all minted tokens, reserve supply is held in AuthUTXO (not circulating), circulating supply is total minus reserves. Reserves must be in the single AuthUTXO to count properly, not just any UTXO at authguard address."
        },
        {
          "question": "How do BCH and CashTokens on the same UTXO prevent state bloat?",
          "answer": "Having BCH and CashTokens on the same UTXO elegantly solves UTXO bloat - the BCH locked with the state acts as the ongoing payment/storage fee. This economic mechanism prevents spam by requiring value commitment. Converting all sats to tokens was considered but rejected because contracts need to hold both state (tokens) and value (BCH) simultaneously for this bloat-prevention mechanism."
        },
        {
          "question": "Why can't BCH be converted into a CashToken to unify sats and tokens?",
          "answer": "It's a crucially important feature for contracts to hold state (CashTokens) and BCH value simultaneously. Removing this would break the ability to create stateful contracts with native value, crippling covenant functionality. Contracts wanting to abstract BCH can already use Wrapped BCH (wrapped.cash) for token-only scenarios like token-to-token DEXes."
        },
        {
          "question": "Can CashToken NFTs contain arbitrary on-chain data or must they reference external storage?",
          "answer": "NFTs can contain up to 40 bytes of arbitrary data on-chain in the commitment field. This data is part of the UTXO and doesn't require IPFS/external storage. For larger data (metadata, images, etc.), use BCMR which references external storage. The 40-byte commitment can store small data directly (hashes, identifiers, compact state) or point to larger external data."
        },
        {
          "question": "Why does Moria USD show as 'is_nft: true' when it's a fungible token?",
          "answer": "Moria USD (MUSD) category contains both fungible tokens and NFTs. MUSD itself is the fungible token, but the category also has NFTs used internally by the loan contract to track state (positions, collateral, etc.). Indexers detecting any NFT in a category may flag 'is_nft: true' even though the primary token is fungible. One category can have both FTs and NFTs."
        }
      ]
    },
    {
      "name": "Trading & DEX",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is the difference between PSBT trading approach and covenant-based trading?",
          "answer": "PSBT (Partially Signed Bitcoin Transaction) trading is an off-chain offer that never gets on chain unless taken by someone. The maker creates an imbalanced transaction that the taker completes by adding inputs and outputs to balance it. Trades are essentially coinjoins. This differs from covenant approaches where the contract logic is enforced on-chain. BCH can implement PSBT-style trades using SIGHASH_SINGLE."
        },
        {
          "question": "What is CatDex and how does it work?",
          "answer": "CatDex is a Token Category Authorized Decentralized Exchange. It uses an authorization NFT category (authCat) to control trading. Makers create NFTs with commitment data encoding their offers and send them with assets to a contract address. A separate key-value index contract enables aggregation and discoverability across multiple DEX instances. Makers pay to publish their DEX as a value on the token's key, allowing anyone to query and discover available trades."
        },
        {
          "question": "How does CatDex discovery work through the key-value index contract?",
          "answer": "To make a DEX discoverable, publish it to the key-value index by sending an NFT with protocol identifier and authCat ID as commitment to contract index(bytes tokenCategory). To find all MUSD exchanges: query all UTXOs at the index address for that token category, parse for NFTs containing authCat IDs, then query contract CatDex(bytes32 authCat, bytes32 tokenId) addresses. Anti-spam: increase listing cost to reduce fake/unfunded exchanges."
        },
        {
          "question": "What libraries exist for interacting with Cauldron DEX contracts programmatically?",
          "answer": "Two independent libraries for on-chain contract interaction: vegabch (https://github.com/hosseinzoda/vegabch) and Cauldron_Swap_Test (https://github.com/mr-zwets/Cauldron_Swap_Test). These enable programmatic access to Cauldron DEX without using the website, supporting CLI/API integration for automated trading and liquidity management."
        },
        {
          "question": "How do you use vegabch CLI to interact with Cauldron DEX?",
          "answer": "Architecture: daemon/client RPC model. 1) Generate config with `daemon:gen-rpcauth`, 2) Run daemon: `vegabch daemon:run --config server-config.json`, 3) Set client config: `export VEGABCH_CONFIG=/path/to/client-config.json`, 4) Send RPC commands to daemon. Example configs at github.com/hosseinzoda/vegabch/tree/beta/share/examples. Wallet generation requires derivation_path parameter."
        },
        {
          "question": "What is the vegabch CLI workflow for executing Cauldron DEX trades?",
          "answer": "Two-step process: 1) `cauldron:construct-trade --target-demand --decimal-amounts BCH MUSD 1.00 trade.json` constructs trade showing rate/fee/supply/demand (fee is included, don't deduct), 2) `cauldron:fund-trade trade.json --broadcast` funds, builds & broadcasts. Set `VEGABCH_CONFIG=client-config.json` environment variable. Run daemon separately with daemon-config.json, send commands with client-config.json."
        },
        {
          "question": "What causes txn-mempool-conflict errors when trading on Cauldron?",
          "answer": "Two causes: 1) Someone traded before you pushed your transaction (pool state changed), 2) Broadcasting same transaction twice. Each constructed trade is only valid for building one transaction. If someone trades before you, must construct a fresh trade with updated pool state. This is inherent to on-chain AMM racing - first valid transaction wins."
        },
        {
          "question": "What's the current state of order types on Cauldron DEX?",
          "answer": "Cauldron currently only supports AMM pool trading (swap against liquidity pools). Limit orders are not yet implemented. All trades execute immediately at current pool rate. For deeper liquidity, use MUSD (MUSDv0 is retired). The construct-trade command calculates optimal routing across available pools."
        },
        {
          "question": "How do you list a new token on Cauldron DEX?",
          "answer": "Self-listing: Connect wallet and create liquidity pool for the token. Verification: Contact Cauldron team to get token verified/whitelisted. Documentation at docs.riftenlabs.com/cauldron/claim/. May be possible to list directly via script but no easy UI helper currently. Verification requires team approval for quality/scam filtering."
        },
        {
          "question": "How do flash loans work on BCH with CashTokens?",
          "answer": "Flash loans are implemented using BCH covenants and CashTokens. Implementation available at github.com/kiok46/flash-loans. Flash loans enable borrowing tokens within a single transaction with the requirement that they're returned (plus fee) before transaction completion, otherwise the transaction is invalid. Enabled by BCH's covenant capabilities allowing within-transaction state validation."
        },
        {
          "question": "What cross-chain atomic swap implementations exist for BCH?",
          "answer": "Three implementations: 1) cross-chain-swap-ves (general framework), 2) AxeSwap (BCH-XMR swaps), 3) BasicSwapDEX (BCH recently added). Challenge: Hard to get volume - atomic swaps have poor UX compared to alternatives. For better convenience and liquidity, ThorChain-like approach needed with liquidity pools rather than direct peer-to-peer atomic swaps. Current atomic swap UX is 'shitty' compared to pooled liquidity."
        },
        {
          "question": "Why don't atomic swaps gain more adoption despite being trustless?",
          "answer": "Atomic swaps have terrible UX compared to pooled liquidity solutions. They require both parties to be online simultaneously, matching exact amounts, and dealing with timelock complexities. Everything else (ThorChain, centralized exchanges) is 'way more convenient' despite trust tradeoffs. To compete, BCH would need a ThorChain-like dedicated project with liquidity pools, not just atomic swap infrastructure."
        }
      ]
    },
    {
      "name": "Smart Contracts & Covenants",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "Can NFTs have built-in royalties on BCH that enforce creator fees on every resale?",
          "answer": "Yes, BCH smart contracts can enforce royalties on NFT resales. The fee receiver can be a pay-to-NFT address, making the payout rights themselves tradeable. Use cases include concert tickets where resale is price-limited and the original creator gets a cut of every sale. The contract can restrict resale price and automatically send a percentage to the creator on each trade."
        },
        {
          "question": "How does the single-UTXO auction pattern work?",
          "answer": "Each bid pays out the previous highest bid, keeping the auction in a single UTXO until the item is sold. This makes the under-bidder whole to bid again. Can be enhanced with incentives where part of the new bid pays the previous bidder to encourage early bidding, eliminating the 'wait until last second' problem. Improves price discovery as people bid on underpriced items to collect the next bidder's fee."
        },
        {
          "question": "What is the Unspent protocol and how do perpetuity/annuity contracts work?",
          "answer": "Unspent is a PUSH-based recurring payment system where recipients are paid automatically without wallet interaction or signing. Perpetuity and annuity contracts create recurring payments already working in production. They represent ultimate commitment - transparent, on-chain, and cannot be redirected once created. You allocate a budget that flows over time. Ideal for contractor payments as it stabilizes spending and working behaviors."
        },
        {
          "question": "How do unspent protocol contracts execute and terminate?",
          "answer": "Unspent perpetuity and annuity contracts cannot be modified once created and automatically stop when the balance is depleted. They use the 'S' selector in the unspent protocol, allowing payments to be picked up and executed as anyone-can-spend MEV. The protocol enables Hodl, Subscriptions, and Wills through phi v3 timelocking and token-aware contracts."
        },
        {
          "question": "What are the technical challenges of USD-denominated recurring payment contracts?",
          "answer": "Fiat-denominated contracts require oracle data and face two key risks: if the contract extends past oracle lifetime it must be liquidated, and if BCH price increases significantly the installment becomes trivial and can't draw down principal properly. BCH-denominated perpetuity/annuity contracts avoid this by valuing BCH itself. A cancellable BCH-denominated subscription is considered an easy upgrade to existing contracts."
        },
        {
          "question": "What is the recommended approach to building recurring payment dapps?",
          "answer": "It's easier to develop many similar dapps within one protocol rather than one-offs. The key challenge is removing friction for adoption - while dapps have existed for half a decade with on-chain usage, making something that grows requires excellent UX. The vision includes wallet integration where users can subscribe to creators with customizable amounts and payment schedules."
        },
        {
          "question": "How do time-locked CashToken transfers work?",
          "answer": "Unspent V3 (currently being coded) will support time-locked transfers of both BCH and CashTokens. Important: tokens don't move automatically - the party locking the coins/tokens must publish a job that someone else can call to execute the transfer. This is timelocking with manual execution, not fully autonomous transfers."
        },
        {
          "question": "How does the EIP-2535 Diamond pattern adapt to BCH smart contracts?",
          "answer": "Similar to Ethereum's Diamond/Multi-Facet Proxy pattern, BCH contracts can use a plugin/facet architecture where auxiliary contracts provide 'code' while the main contract maintains 'storage/utxo'. This enables: pluggable systems (e.g., Lease Contract plugging into Domain system), borrowing against tokens, multi-party ownership, upgradable contract systems, and chainlink-like structures. All facets are just code providers to the core storage contract."
        },
        {
          "question": "What is the BitCANN domain registration system architecture?",
          "answer": "BitCANN is a complete decentralized domain system with auctions, expiry, transferability, record updating, and multiple TLDs. One authchain equals one TLD, with external convention determining which instance is authoritative. It's asynchronous (doesn't keep all state in one UTXO merkle tree), enforces charset validation, and uses guard contracts with incentive structures. Contract code is laid out to mirror transaction structure (preamble, inputs, outputs)."
        },
        {
          "question": "What's the difference between pre-native and native introspection in BCH contracts?",
          "answer": "Last-will and some older contracts use introspection from before 'native introspection' became available. These older designs are no longer optimal and tooling isn't cross-compatible between Spedn and CashScript. Simpler contracts like 2-of-3 multisig don't require introspection at all and make good candidates for WalletConnect apps."
        },
        {
          "question": "Why can't smart contracts measure coin-days for UTXOs not held by the contract?",
          "answer": "Contracts can only introspect their own inputs and cannot measure the age of UTXOs that weren't previously locked by the same contract. This prevents implementing rewards based on age  value for arbitrary UTXOs. The blockchain doesn't expose UTXO age/block height to script, making coin-days calculation impossible for external UTXOs without an oracle."
        },
        {
          "question": "What is BCHess and how does on-chain chess work with BCH covenants?",
          "answer": "BCHess is covenant-based chess implementation using CashTokens for game state. Older version available at github.com/SayoshiNakamario/BCHess with most basic logic. Presented at Bliss'25 - demonstrates complex game state management on-chain using covenant introspection. Updated version coming later with bug fixes and improvements."
        }
      ]
    },
    {
      "name": "Infrastructure & Indexing",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What infrastructure is needed beyond a full BCH node to build a wallet?",
          "answer": "A full node alone is insufficient for wallet creation. You need an indexer like Fulcrum to get address balances. However, Fulcrum currently doesn't work as a Token Indexer - it's anchored around wallet addresses. For general-purpose token queries (finding all addresses containing a specific category ID), use Chaingraph instead. Fulcrum can view tokens on addresses you already know about."
        },
        {
          "question": "When should you use Fulcrum vs Chaingraph for CashToken applications?",
          "answer": "Use Fulcrum for wallet-centric applications - it's perfect for querying balances and tokens on known addresses. Use Chaingraph for token-centric applications - it enables looking up a category ID to find all addresses/UTXOs containing those tokens. Fulcrum is address-indexed, Chaingraph is token-indexed. For wallet creation with known addresses, Fulcrum works perfectly."
        },
        {
          "question": "Do you need an indexer to use CashTokens with your own BCHN node?",
          "answer": "For basic CashToken functionality with libraries like mainnet.cash-js, you can connect directly to your BCHN node without a dedicated indexer. However, for advanced queries (finding all addresses holding a token, tracking NFT locations, etc.), you'll need an indexer like Fulcrum or Chaingraph. Simple send/receive works node-only."
        },
        {
          "question": "Why is BlockBook indexer important for CashToken adoption?",
          "answer": "BlockBook is a multicoin indexer (written in Go, maintained by Trezor) used by Edge wallet, Trust wallet (Binance), and possibly Exodus. Adding CashToken support to BlockBook would enable: CashToken support in multiple major wallets, Trezor hardware wallet support, and serve as public-good infrastructure. Success depends on convincing maintainers that CashTokens are native BCH features and minimizing API changes. Could be flipstarter funded."
        },
        {
          "question": "What BCMR indexers and explorers are available for CashTokens?",
          "answer": "Public resources: 1) Paytaca indexer (bcmr.paytaca.com) - indexes chain-resolved BCMR registries, 2) TokenExplorer.cash - on-chain resolution metadata lookup, 3) BlockBook explorer (blockbook.pat.mn/token/[categoryId]) - added to Cashonize, 4) Static registries: otr.cash (outdated, missing MUSD), badgers.cash, futurebitcoin.cash. Opportunity exists for better partitioned-per-category static registry (OpenTokenRegistry issue #9)."
        },
        {
          "question": "What is the OP_RETURN scanner utility and how does it work?",
          "answer": "The OP_RETURN scanner is a tool that finds all occurrences of specific OP_RETURN markers on-chain by scanning for protocol identifiers like 'BCMR' or LOKAD IDs. For example, searching for 'BCMR' returns 3417 transaction IDs. It's useful for discovering all instances of a particular protocol or smart contract app, as markers are a recommended place to store contract details."
        },
        {
          "question": "How can you scale mainnet-js when using your own Fulcrum indexer?",
          "answer": "mainnet-js requires websocket connections directly to Fulcrum, unlike bch-js which uses REST (enabling AWS queue routing). Solution: use fulcrum-http (github.com/mainnet-pat/fulcrum-http) - provides HTTP wrapper for Fulcrum, enabling load balancing and queue-based scaling architectures similar to bch-js REST approach."
        }
      ]
    },
    {
      "name": "Wallet Development",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "How can a wallet hold only CashTokens with zero BCH for fees?",
          "answer": "Three approaches: 1) Post Office pattern - centralized service adds fee input in exchange for tokens, 2) Cauldron pool swap - craft transaction that swaps tokens for just enough BCH to cover fee, then makes payment, 3) Combined tx - single transaction that performs Cauldron swap (picking up only txfee from pool) while splitting CashToken into payment output and change output. All avoid requiring BCH in the wallet."
        },
        {
          "question": "How feasible is building a token-only wallet that pays fees via Cauldron swaps?",
          "answer": "Very feasible - estimated one day of work. Create a wallet that exposes a single token (e.g., MUSD) and transparently pays transaction fees through Cauldron pool swaps. Can be implemented as an SDK that other platforms can use. The transaction combines a Cauldron swap (picking up just enough BCH for txfee from pool) with splitting the CashToken into payment output and change output."
        },
        {
          "question": "What is the recommended fee management strategy for token-only wallets?",
          "answer": "Wallets should maintain a fee stash of approximately 10 UTXOs of 800 sats each, managed behind-the-scenes. When user sends tokens, wallet automatically extends the transaction to swap tokens for a new 800sat output via DEX. Critically, make the DEX swap a 0-conf child rather than parent to avoid DSP (Double Spend Proof) coverage issues. Automatically replenish the BCH stash when depleted, so users don't manually manage the BCH pot."
        },
        {
          "question": "What are the privacy implications of fee management strategies for CashToken wallets?",
          "answer": "Reusable separate BCH UTXOs for fees destroy privacy through address reuse and linkability. Three privacy-preserving alternatives: 1) Single-use fee UTXOs (new UTXO each time), 2) Preload CashToken UTXOs with sats for spending during CashFusion process, 3) Just-in-time swap trick (DEX swap as 0-conf child). Also: mobile wallet push notifications travel through Google, exposing all deposits/payments - should default to disabled."
        },
        {
          "question": "What are the main development tooling options for CashTokens across different languages?",
          "answer": "JavaScript developers use mainnet-js and CashScript (or libauth directly for lower-level operations). Python developers can use bitcash library. For CashScript, this includes contract compilation, transaction building, and WalletConnect integration. Libauth provides the foundational primitives that other libraries build on."
        },
        {
          "question": "How do you enable CashToken support in Electron Cash?",
          "answer": "Use Electron Cash (regular), not Electron Cash SLP (which is for SLP tokens only). Enable CashTokens tab via View menu - it's hidden by default. Better wallets exist for CashTokens (Selene, Cashonize, Paytaca) but they don't necessarily support testnets. For testnet work, Electron Cash is reliable option once tabs enabled."
        },
        {
          "question": "Which wallets support WalletConnect on mobile devices?",
          "answer": "Paytaca and Cashonize support WalletConnect on mobile. For same-device connections, press QR code icon below close button to copy/paste WalletConnect info. Electron Cash doesn't have native WalletConnect functionality - the plugin is desktop-only. This limits Electron Cash's ability to interact with WalletConnect-based dapps on mobile."
        },
        {
          "question": "What are the security concerns with WalletConnect integration in BCH dapps?",
          "answer": "WalletConnect is just a transport layer for communication between dapp and wallet. Primary security concern is adding a middleman that can censor or know IP info - not cryptographic vulnerabilities. CashScript v0.11.1 added native WalletConnect support via TransactionBuilder method that generates WC transaction objects for signing. Overall security risk is minimal beyond typical relay/transport concerns."
        },
        {
          "question": "What breaking changes occurred in WalletConnect v2.21.0 affecting BCH wallets?",
          "answer": "@walletconnect/utils@2.21.0 deprecated `requiredNamespaces` - values are now automatically assigned to `optionalNamespaces` instead. This breaks BCH wallet implementations using requiredNamespaces. Warning: Don't upgrade @reown/walletkit or @walletconnect/core without testing. Fix: Use optionalNamespaces or pin to older versions (see bch-hodl-dapp package.json). Cashonize fix: github.com/cashonize/cashonize-wallet/commit/696daa49."
        }
      ]
    },
    {
      "name": "BCMR & Metadata",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is a BCMR authchain and why does 'Invalid authchain transaction' error occur?",
          "answer": "An authchain is a series of spends from a vout 0 UTXO, forming a zeroth descendant transaction chain. The error 'does not spend 0th output of previous transaction' occurs when providing a transaction without a vout 0 UTXO. To fetch BCMR metadata, use the token's categoryId as argument, NOT the transfer transaction ID. Each link in the authchain must spend output 0 from the previous transaction."
        },
        {
          "question": "How are CashToken decimal places determined and what happens without BCMR data?",
          "answer": "Decimals are NOT on-chain - they're determined by the 'decimal' field in BCMR (Bitcoin Cash Metadata Registry), an off-chain registry. Without BCMR data, wallets and explorers display raw integer amounts and category ID only. Example: 1000 tokens with 2 decimals shows as 100000 in BCMR-unaware wallets. This differs from ERC-20 where decimals are on-chain (Ethereum uses 18 decimals by design). Electron Cash supports BCMR lookup, with easier/automatic lookup coming."
        },
        {
          "question": "Can token decimals cause confusion when sending CashTokens between different wallets?",
          "answer": "Yes - if sender uses BCMR-aware wallet (like CashTokens Studio) and receiver uses BCMR-unaware wallet (older Electron Cash), decimal display differs dramatically. Sender sees 1000 tokens (with 2 decimals), receiver sees 100000 (raw amount). This can enable disputes where sender claims they sent more than received. Base-layer always shows ID and raw value correctly - only decimal presentation differs based on BCMR access."
        },
        {
          "question": "Can BCMR authchain owners manipulate token decimals to scam users?",
          "answer": "Yes - token authors have extensive power by design. Attacker with Auth access could change 500.00 to 50000 by removing 2 decimals. Protections: 1) Verified token lists (Cauldron integration) would delist scamming tokens, 2) Only trust issuers with strong reputations who would destroy themselves scamming, 3) Consider DAO governance for decentralized verified tokens. This area needs investigation and coordination - Selene doesn't adequately show verified/unverified status."
        },
        {
          "question": "Why do CashToken authors have the power to update logos and metadata?",
          "answer": "Updatable metadata is necessary for legitimate use cases: improving image quality, rebranding, or annual events like BLISS conference. Token authors have extensive control by design - this is intentional, not a bug. The solution is social: only trust tokens from issuers with strong reputations who would face severe consequences from abuse. Immutable metadata would prevent legitimate updates."
        },
        {
          "question": "What are the available public BCMR registries?",
          "answer": "Public registries: otr.cash, badgers.cash, futurebitcoin.cash, and wrapped.cash (location uncertain). Paytaca operates a public indexer that indexes chain-resolved BCMR registries. No comprehensive registry exists that captures all tokens - many appear to be private/project-specific. Chain resolution via DNS and app-embedded metadata provide alternatives to centralized registries."
        },
        {
          "question": "Why do some wallets not display SVG icons from BCMR metadata?",
          "answer": "Inconsistent SVG support across wallets despite BCMR spec recommending 'data:image/svg+xml,' URI format. Electron Cash and Selene don't load SVG icons, while Cashonize and salemkode explorer do. Implementation-dependent - wallets must explicitly add SVG rendering support. Test compatibility with BPT tokens on tapswap."
        },
        {
          "question": "Can IPFS URLs be used for BCMR metadata, or must it be HTTPS?",
          "answer": "HTTPS requirement is Electron Cash-specific ('only EC thing'), not a spec-wide mandate. Other wallets and tools may support IPFS or other URI schemes. The BCMR spec itself is flexible, but wallet implementation determines what protocols work. Check specific wallet/tool documentation for supported URI schemes."
        },
        {
          "question": "Can BCMR icons be embedded directly in the URI instead of using IPFS?",
          "answer": "Yes - BCMR supports 'data:image/svg+xml,' URIs for embedding SVG icons directly in metadata without IPFS. Example: BPTS token has SVG embedded in BCMR URI, eliminating external dependency. This improves reliability (no IPFS gateway failures) but increases BCMR file size. Trade-off between decentralization/persistence (IPFS) vs. inline embedding."
        },
        {
          "question": "What is the 'set it and forget it' metadata scheme for CashTokens?",
          "answer": "Proposed approach for permanent metadata storage without constant IPFS pinning requirements. Instead of IPFS (requires ongoing pinning), use permanent storage solutions where data is uploaded once and persists indefinitely. Reduces operational hassle for NFT/token projects. Alternative to traditional IPFS: Arweave, data URIs, or other permanent storage. Makes token metadata maintenance-free."
        }
      ]
    },
    {
      "name": "Network & Testing",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "Why can't you just swap address prefixes between mainnet and testnet?",
          "answer": "The prefix is included in the address checksum, so you cannot simply replace 'bitcoincash:' with 'bchtest:' - the checksum will be invalid. While lockscripts are identical across networks, addresses differ due to checksum recalculation. Use tools like stack.xo.cash/tools/primitives.html#address to properly translate addresses between networks (mainnet, testnet, chipnet)."
        },
        {
          "question": "How do you convert a regular BCH address to a CashToken-capable address?",
          "answer": "Use kth.cash/wasm.html tool to convert regular BCH addresses to CashToken receive addresses. Token addresses indicate support for tokens - ideally all addresses become token addresses eventually. Addresses encode support via checksum/format but underlying lockscript is identical. Tool enables sending tokens to legacy address format by converting to token-aware equivalent."
        },
        {
          "question": "How do you enable testnet4 or chipnet on different BCH wallets?",
          "answer": "Electron Cash: Start with `--chipnet` or `--testnet4` command-line flags. Selene: Tap the logo 6 times rapidly on the credits screen (settings  green version button) to access debug menu, then select testnet4. Paytaca and Cashonize both support chipnet. For development, CashScript Playground defaults to mocknet which is recommended over mainnet testing."
        },
        {
          "question": "What are the methods for broadcasting raw BCH transactions without a public RPC node?",
          "answer": "Four methods: 1) Connect directly to BCH P2P network (language-dependent, Bash scripts possible with known node IP), 2) Use Electrum protocol's blockchain.transaction.broadcast method via electrum-cash NPM library, 3) Use Electron-Cash GUI (Tools > Load transaction > From text), 4) Write custom P2P network script. No widely available public RPC nodes exist for sendrawtransaction."
        },
        {
          "question": "How can you look up a P2SH (Pay-to-Script-Hash) address on BCH block explorers?",
          "answer": "Use this bash script to generate a 3xpl/blockchair URL for any P2S address: `hex=0xAC; echo \"https://3xpl.com/bitcoin-cash/address/script-\"$(echo -n $hex | sed -s 's/^0x//' | tr 'A-F' 'a-f' | sha256sum | cut -b 1-32)`. Replace 0xAC with your script hex. This hashes the script and formats it for block explorer lookups."
        }
      ]
    },
    {
      "name": "CashScript & Development Tools",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What CashScript optimization anti-patterns should be avoided?",
          "answer": "Two key anti-patterns: 1) Never use 'else require(false)' - it wastes 9 bytes and adds unnecessary operations. Instead, put the require condition in the else block directly: 'else { require(condition, \"error\") }'. 2) Avoid deeply nested if statements - they increase bytecode size and complexity. Use early returns or flatter logic structures instead."
        },
        {
          "question": "What does 'stack item exceeded maximum length (520 bytes)' error mean in CashScript?",
          "answer": "This error occurs when a program attempts to push a stack item larger than 520 bytes (BCH's MAX_SCRIPT_ELEMENT_SIZE limit) even if total script size and opcount are within limits. This was reported as a potential compiler issue in CashScript v0.10.0 - reverting to v0.8.0 resolved it. Individual stack elements have stricter size limits than the overall script."
        },
        {
          "question": "What is the CashScript v0.10.0 simple transaction builder bug and how to fix it?",
          "answer": "CashScript v0.10.0 has a bug in the debugging tooling for the simple transaction builder causing 'stack item exceeded maximum length' errors even when script size and opcount are within limits. Workaround: Use v0.9.0 or v0.8.0. The issue will be fixed in v0.11, where the old simple transaction builder will be marked deprecated. The bug affects the SDK when running contract functions."
        },
        {
          "question": "What are the key features of CashScript v0.11.0?",
          "answer": "Major release after 6+ months development. Highlight: debugging capabilities for new transaction builder, enabling local testing/debugging with mocknet and Bitauth IDE integration. Contains breaking changes with migration notes provided. Significantly improves developer experience. Allows transaction builder to be used for development testing rather than just production. Presented in Rosco's Bliss talk."
        },
        {
          "question": "What new BCH development guides were added to CashScript documentation?",
          "answer": "Two fundamental guides added: 1) 'Transaction Lifecycle' (cashscript.org/docs/guides/lifecycle) - explains transaction progression through network, 2) 'Adversarial Analysis' (cashscript.org/docs/guides/adversarial) - security analysis framework. Both are general BCH development knowledge that was assumed but never documented before, making them essential reading for all BCH developers regardless of CashScript usage."
        }
      ]
    },
    {
      "name": "Cross-chain & Bridges",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "Can BCH smart contracts trigger based on BTC blockchain events?",
          "answer": "No, BCH blockchain cannot natively monitor BTC transactions or addresses - chains cannot see each other without external data. This is the trustless two-way bridge problem, 'one of the biggest unsolved problems in crypto.' The only solution is using an oracle service that reports BTC chain events to the BCH contract, introducing trust assumptions."
        },
        {
          "question": "Why can't proof-of-work verification solve trustless cross-chain bridges?",
          "answer": "While similar to drivechains/ThorChain concepts, PoW verification faces critical problems: handling reorgs and calculating the highest PoW chain when adversaries feed the contract data from minority hashrate branches. The technical complexity of on-chain SPV light client verification, combined with potential for dishonest oracle data, makes two-way peg SPV a 'graveyard idea' - heavily discussed but never successfully implemented."
        },
        {
          "question": "What are the practical approaches to wrapped BTC on BCH?",
          "answer": "Three approaches: 1) Tokenized BTC via CashTokens backed by custodial service (centralized trust, could use proof-of-reserves), 2) BCH Bull's battle-tested oracle service for BTC-pegged financial products (cash-settled instruments, not redeemable tokens), 3) WBTC CashToken bridge (possible today). All require trust assumptions - depositing BTC for truly trustless wrapped-BTC is impossible without BTC covenant support (unlikely). Usually solved with multisig custody."
        },
        {
          "question": "What is the difference between cash-settled instruments and redeemable wrapped tokens?",
          "answer": "Cash-settled instruments (like BCH Bull products) track BTC price via oracle and settle in BCH - you never get actual BTC. Redeemable wrapped tokens (like traditional WBTC) represent claims on real BTC held in custody that can be redeemed 1:1. These are entirely different animals - one is a derivative, the other is tokenized custody."
        },
        {
          "question": "What CashToken integrations are being pursued with ThorChain?",
          "answer": "Active collaboration to add MUSD, PUSD, and potentially other CashTokens to ThorChain for cross-chain trading. This would enable BCH CashTokens to be swapped with assets from other chains (BTC, ETH, etc.) through ThorChain's liquidity pools. Contact has been established between BCH CashToken developers and ThorChain team."
        }
      ]
    },
    {
      "name": "Exchange & Integration",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is the main barrier to CEX (centralized exchange) CashToken adoption?",
          "answer": "Almost all exchanges use node software directly to support token ecosystems. The BCH ecosystem 'botched it' by not implementing 100% token-aware support (receive/send CashTokens) in full node software from the start. After 5 years, no CEX has implemented CashTokens because they need complete native node support to easily integrate token trading, just like they do for other chains' token standards."
        },
        {
          "question": "What happens if a pre-CashTokens wallet tries to spend a CashToken UTXO?",
          "answer": "Pre-CashTokens wallets cannot spend CashToken inputs - signing for CashTokens inputs is designed to prevent this, protecting against accidental burns. However, if a CashToken-aware wallet spends a token UTXO without including tokens in outputs, the transaction is valid and tokens are implicitly destroyed (burned). Quote from spec: 'Tokens can be implicitly destroyed by omission from a transaction's outputs.'"
        },
        {
          "question": "What happens when a non-CashToken-aware wallet receives a CashToken deposit?",
          "answer": "Token-unaware wallets won't recognize UTXOs containing tokens - they don't know how to spend them. If exchange attempts consolidation including CashToken UTXO, transaction will fail due to signature generation error. The token_prefix must be included in sighash preimage construction. Solutions: 1) Mark CashToken deposits as 'failed' to exclude from UTXO selector, 2) Update sighash preimage to properly handle token_prefix (decode from UTXO data)."
        },
        {
          "question": "What's the technical requirement for signing CashToken inputs in custom BCH implementations?",
          "answer": "Sighash preimage construction must include token_prefix field (not hardcode as empty b''). Preimage structure: version + hashPrevouts + hashSequence + txid + txindex + token_prefix + scriptCode_len + scriptCode + amount + SEQUENCE + hashOutputs + lock_time + hash_type. Pre-CashTokens signing code fails because token_prefix is missing/empty. Must decode token prefix from UTXO and include in preimage."
        },
        {
          "question": "Can bch-js or mainnet-js accidentally burn CashTokens?",
          "answer": "bch-js cannot accidentally burn CashTokens - it doesn't know how to sign token input transactions. Without explicit support for token signing in sighash preimage construction, accidental burning is impossible. However, mainnet-js could accidentally burn SLP tokens if you use both. Pre-CashTokens wallets cannot spend CashToken inputs due to signature mechanism protection."
        },
        {
          "question": "What is the recommended exchange policy for handling unsupported CashToken deposits?",
          "answer": "No clear consensus policy exists yet. Challenge: even if exchange supports X tokens, users can deposit unsupported ones. Options: 1) Treat as simple BCH deposit (risks accidentally burning tokens), 2) Quarantine UTXOs containing unsupported tokens (prevents burns, requires extra infrastructure). Most exchanges haven't implemented CashTokens yet, so best practices still emerging."
        },
        {
          "question": "How should exchanges handle CashToken deposits to non-token-aware systems?",
          "answer": "Recommended approach: 1) Policy - Quarantine CashToken UTXOs to retain manual recovery option if user covers fees, 2) Implementation - Override block parser to construct pruned block containing only BCH txs for parent class processing, 3) Create token vouts in database with FAILED status, 4) Exclude FAILED status from UTXO selection queries. This prevents spend failures while preserving recovery capability."
        }
      ]
    },
    {
      "name": "Applications & Use Cases",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "How can BCH dapps avoid needing an application server?",
          "answer": "By putting contract details on-chain, dapps can be client-only with no backend server required. The BCH Hodl Dapp demonstrates this pattern - it's a fully functional smart contract application that runs entirely in the browser. The goal is to create a 'BCH Dapp Template' enabling developers to launch simple smart contract apps within 24 hours using this serverless architecture."
        },
        {
          "question": "What WalletConnect applications are desired for BCH CashToken development?",
          "answer": "Desired WalletConnect apps include: vault app for secure storage, last-will inheritance app for estate planning, Mecenas recurring payments app for subscriptions, 'Hodl' time-locked savings app, AnyHedge app for hedging, and airdrop/dividends app for token distribution. These would enable covenant-based financial primitives through user-friendly interfaces."
        },
        {
          "question": "How would a diversified CashToken index fund work on BCH?",
          "answer": "A FUND token could monitor completed tokens from BCH Pump and reset allocation each time a new Nth token completes, distributing 1/N to each completed token. Starting with the 2nd completed token (1/2 each), then adjusting to 1/3 when the 3rd completes, etc. Key challenges include programmability, custody of decision-making, determining initial group composition, and managing dynamic rebalancing intervals."
        },
        {
          "question": "What is the Vox platform architecture?",
          "answer": "Vox is a basket of CashToken-enabled contract apps with a distributed database connecting them, where the database itself is a CashToken contract. The architecture uses contracts with references to other contracts, creating an interconnected system that unifies multiple applications in one UI. This demonstrates contracts-as-database infrastructure on BCH."
        },
        {
          "question": "How does Vox's on-chain chat pricing and censorship resistance work?",
          "answer": "Anyone can post for 250 sats/character. Anyone can 'censor' (remove) any message for 2500 sats/character (10x cost). Authors can edit their messages for 1 sat/byte. Messages are deleted after ~1 week - NFT commitments are burned from active UTXO set, preserved in full node history but removed from pruned nodes. Identities link to address that issued identity token, enabling cross-device profiles."
        },
        {
          "question": "How does CashStarter use CashTokens for crowdfunding?",
          "answer": "CashStarter (circa 2023) is open source crowdfunding platform using CashTokens to track donations on-chain. Similar to Flipstarter but uses CashToken NFTs/FTs for donor tracking and campaign management. Code available at github.com/SayoshiNakamario/CashStarter/blob/main/CashStarter.cash. Demonstrates using tokens as accounting mechanism for complex multi-party applications."
        },
        {
          "question": "What are the existing gamified BCH faucet implementations?",
          "answer": "Three implementations: 1) bugs.cash (potential open source code for reference), 2) afifthofgaming.com (gamified faucet), 3) purelypeer.cash (geolocated cashdrops - users go on quests/campaigns to find BCH at physical locations). Primary challenge is marketing rather than technical implementation. These demonstrate BCH faucets with game mechanics for user engagement."
        },
        {
          "question": "What would a Double Spend Proof (DSP) checker website do?",
          "answer": "A DSP checker would take a transaction ID and show its status, plus display a history of recent double-spend attempts and their generated DSPs. The goal is to make double-spend proofs visible and accessible, as currently they're hidden technology at the node layer with no easy way to 'see' them."
        },
        {
          "question": "What are the limitations of Double Spend Proofs (DSP) for P2SH transactions?",
          "answer": "DSP won't catch a double-spend with P2SH ancestors. P2SH ancestor means DSP score of 0 (NOT COVERED). Spec requires transactions be all P2PKH, or all mempool ancestors must be all-P2PKH, signed SIGHASH_ALL without ANYONECANPAY. This creates problems for payments using DEX swaps to convert tokens to BCH for fees on-the-fly - if 0-conf ancestor is Cauldron pool, child could get dropped when parent drops. Not all 0-conf is equal."
        }
      ]
    },
    {
      "name": "Token Management",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is the difference between reserve supply and burned tokens, and how do you manage them?",
          "answer": "Reserve supply is held in the AuthUTXO (not just 'original minter address' - no such concept in BCMR spec). Only AuthUTXO can update metadata and hold reserved supply. To move tokens to reserve: send to AuthUTXO. Burning is different: transaction has tokens as input and none as output - 'missing' tokens are permanently deleted. Use tokenburner.cash or CashTokens.Studio AuthGuard Contract Address."
        },
        {
          "question": "How do you properly return tokens to reserve supply versus just burning them?",
          "answer": "Reserve supply must be in the single AuthUTXO, not just any UTXO at the authguard address. To return to reserve: spend AuthUTXO together with circulating tokens, consolidate output back to single AuthUTXO. Just sending tokens to authguard creates multiple UTXOs that pollute it - not true reserve. Difficult if tokens owned by different wallets. For permanent removal, burn instead (CashTokens Studio now sends burns to tokenburner.cash)."
        },
        {
          "question": "What tools exist for batch managing unwanted CashTokens?",
          "answer": "Requested feature ('shitcoin autodumper'): tool to list FTs with checkboxes, prepare Cauldron transactions for selected tokens, show total value summary. Currently on Selene wallet todo list. For tokens without Cauldron liquidity pools, use dropship.cash to send/airdrop them. No complete solution exists yet - manual cleanup via individual Cauldron trades or burning required."
        },
        {
          "question": "How do you send payments to specific NFT holders?",
          "answer": "To send BCH to an address holding a specific NFT: you need to find which address currently holds that NFT (by querying blockchain for the NFT's UTXO), then send BCH to that address. NFTs don't have individual tokenIds - they share the category's tokenId but have unique commitments. Can add receiving address in NFT metadata, or query explorer/indexer to find current holder's address."
        },
        {
          "question": "What are the approaches for paying to specific NFT holders?",
          "answer": "Three approaches: 1) Backend service that scans/tracks UTXO set to find current NFT holder address, 2) Adding receiver address in NFT metadata (requires trust - creator can change it, must update on every transfer), 3) Contract redeemable only when specific NFT included in transaction (verification challenging - need indexer/BCMR check + redeem script verification). P2NFT CHIP discussed for future improvements. Cannot burn metadata modification rights for individual NFTs."
        }
      ]
    },
    {
      "name": "Standards & Protocols",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What are the BIP21 query parameters for requesting CashTokens in payment URIs?",
          "answer": "Standard: bitcoincashresearch.org/t/bip21-query-parameters-for-cashtokens/1015. Parameters: &c=<categoryId_hex> for token category, &ft=<amount> for fungible token amount (Paytaca uses &f=). Example: bitcoincash:address?c=e38d7f8e85da78943b3d7766e94c5560522ad67758402ae8f31765412b746292&f=3000000. Different wallets use 'ft', 'f', or 't' parameters. Request 100.00 MUSD: &c=<hex>&ft=10000."
        },
        {
          "question": "What's the current state of BIP21 URI support for CashTokens?",
          "answer": "PayPro proposal exists (github.com/bitjson/chip-paypro) but not implemented anywhere. Key challenges: backwards compatibility ('s' param breaks old wallets, adding 'amount' violates spec), risk of wallets ignoring token params (c, f) and sending BCH-only. Potential solution: 'bch:' prefix for PayPro instead of 'bitcoincash:' to prevent accidental partial sends. Token addresses don't require tokens - can send BCH-only to them."
        }
      ]
    },
    {
      "name": "CashScript Language & Compilation",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "What is the proposed compileScript() function for CashScript?",
          "answer": "A proposed function that compiles small CashScript code segments into CashASM without requiring a full contract wrapper. Example: compileScript('a + b', {a: 'int', b: 'int'}) would output '<a> <b> OP_ADD'. This enables easier template creation by allowing developers to write complex field calculations in CashScript and compile them to CashASM at build time."
        },
        {
          "question": "What syntax is proposed for standalone CashScript function compilation?",
          "answer": "Instead of requiring full contract definitions, the proposal suggests compiling standalone functions like: compileScript(`function checkLockingBytecode(bytes lockingBytecode) { require(lockingBytecode.length == 25); }`) or using arrow function syntax: `(int a, int b) => { return a + b }`. This skips the contract wrapper overhead while maintaining function parameter definitions."
        },
        {
          "question": "Are standalone CashScript functions on the roadmap?",
          "answer": "Yes, creating self-contained functions is on the CashScript roadmap. When implemented, they will be compilable independently for use cases like template field injection. Adding CashASM as an explicit compilation target (separate from regular hex bytecode/asm) is also planned to support template generation workflows."
        },
        {
          "question": "Is there a Python version of the CashScript SDK?",
          "answer": "CashScript-py is being developed and recently received funding. It will be feature-compatible with the JavaScript SDK. However, it's not a solution for OP_CHECKMULTISIG support since the Python version will have the same SDK limitations as the JS version (no collaborative transaction building)."
        },
        {
          "question": "What is Spedn and how does it compare to CashScript?",
          "answer": "Spedn is an alternative BCH smart contract compiler with different syntax from CashScript. While CashScript is more widely adopted with active development and extensive ecosystem support, Spedn offers an alternative approach. Developers can experiment with Spedn using community test repositories, though tooling and documentation are less mature."
        }
      ]
    },
    {
      "name": "Template Design & Standards",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Should BCH templates use CashScript, CashASM, or bytecode?",
          "answer": "Templates should use CashASM (assembly), not CashScript or bytecode. CashScript at build-time compiles to CashASM for the final template. CashASM is human-readable, syntactically simple to port across languages, and already supported by LibAuth-based wallets (Paytaca, Selene, Cashonize, ZapIt). Bytecode would save bandwidth but requires all wallets to implement assemblers."
        },
        {
          "question": "Why not embed CashScript source code in final templates?",
          "answer": "Embedding CashScript would force all wallets and dapps to incorporate a CashScript parser, creating version incompatibility issues when CashScript optimizations change the output CashASM. It also limits cross-platform adoption since non-JavaScript implementations would be difficult. Templates with only CashASM avoid these problems."
        },
        {
          "question": "What are LibAuth WalletTemplates and how do they relate to BCH templates?",
          "answer": "LibAuth WalletTemplates provide a standardized format for describing BCH transactions using CashASM. Templates leverage this by embedding sandboxed CashASM evaluation instructions that wallets execute, enabling dynamic field calculations like nested evaluations: '$($(<value> <1000> OP_SUB) <2> OP_DIV)'. This allows complex transaction templates without requiring CashScript runtime support."
        },
        {
          "question": "What is the trade-off between CashASM and bytecode in templates?",
          "answer": "Bytecode advantages: smaller file size, bandwidth savings (important for NFC). CashASM advantages: human-readable, simpler parser implementation, easier cross-language porting, already supported in LibAuth wallets. The consensus is CashASM provides better versatility and portability while keeping complexity manageable, with bytecode reserved for specific use cases like NFC."
        },
        {
          "question": "How does template design balance versatility vs simplicity?",
          "answer": "CashASM is chosen as a mid-ground: syntactically simple enough to port to other languages but versatile enough for complex contract use-cases. Nested evaluation capabilities are needed for transaction shape definitions and signing operations. The philosophy is to handle complexity in tooling (build-time) rather than requiring wallets to support complicated features."
        },
        {
          "question": "What is the debug symbols approach for BCH smart contracts?",
          "answer": "Similar to traditional compiled languages, contracts use external metadata files (debug symbols) that accompany compiled scripts. Production templates contain only CashASM/bytecode, keeping them lightweight. Debug symbols (\"byte N is variable A\") are stored separately for development/debugging only. This separates complexity from production requirements."
        },
        {
          "question": "Why is CashASM evaluation executed within wallets in templates?",
          "answer": "Templates embed CashASM evaluation instructions that wallets execute in a sandboxed environment. This allows templates to perform dynamic calculations (like computing leverage ratios or concatenating NFT commitments) without requiring pre-compiled values. The wallet evaluates the CashASM expressions using its BCH VM capabilities to build the final transaction."
        }
      ]
    },
    {
      "name": "Wallet Support & Ecosystem",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Which BCH wallets currently support CashASM?",
          "answer": "At least four ecosystem wallets use LibAuth under the hood and thus support CashASM: Paytaca, Selene, Cashonize, and ZapIt. Electron Cash may have ported it with the new WalletConnect plugin. This existing support makes CashASM a practical choice for template standardization."
        },
        {
          "question": "How is the CashConnect wallet transaction building API designed?",
          "answer": "CashConnect uses a partial TransactionTemplate approach where users provide outputs (with lockingBytecode, valueSatoshis, and optional token data), and the wallet automatically appends required inputs and change outputs. The TransactionBuilder follows the tokens-first, satoshis-last pattern internally, handling fee calculation and change construction transparently."
        }
      ]
    },
    {
      "name": "Transaction Building",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Does the CashScript TransactionBuilder automatically add change outputs?",
          "answer": "No, the advanced TransactionBuilder does nothing automatically - you must manually add satoshi change outputs and token change outputs. This design gives full control but requires developers to handle fee calculation and change output construction themselves."
        },
        {
          "question": "What is the correct order for handling tokens and satoshis when building transactions?",
          "answer": "Tokens first, satoshis last. Correct sequence: addTokensFromUnspents()  addTokenChangeOutputs()  addSatoshisFromUnspents()  addSatoshiChangeOutput(). This is critical because satoshi change amount depends on the final transaction fee, which can only be calculated after token outputs are finalized."
        },
        {
          "question": "How do you calculate transaction fees when spending from multiple contracts?",
          "answer": "Fee calculation is non-trivial for multi-contract spends because input sizes aren't known until unlockers are defined. Options include: 1) Use getCurrentByteSize() or build() then check rawTxHex.length/2 to get transaction size, 2) Create utility functions to estimate output sizes, 3) Build the transaction, parse with libauth to check sizes, then add balancing outputs (which may require extra inputs)."
        },
        {
          "question": "What transaction builder utilities are proposed for fee management?",
          "answer": "Proposals include: getCurrentByteSize() to get current transaction size, and calculateOutputSizes() to estimate change output sizes for different types (like P2PKH with tokens). The current method is building the transaction and checking rawTxHex.length/2, but more sophisticated utilities would help with multi-contract spends."
        },
        {
          "question": "How can you get intermediate transaction information before finalizing?",
          "answer": "After adding contract spends with defined unlockers, you could extract intermediate information like input sizes from the prebuilt transaction. Since spending args are provided to unlockers, the final input shape is known. This would help calculate change outputs before fully building and sending the transaction."
        },
        {
          "question": "What fee estimation utilities exist for CashScript transactions?",
          "answer": "bch-js has getByteCount() for simple cases: `bchjs.BitcoinCash.getByteCount({ P2PKH: 1 }, { P2PKH: 1 })`. However, this is too simple for CashScript multi-contract spends. More sophisticated utilities to check bytecount for different transaction shapes with varying input/output types would be valuable."
        },
        {
          "question": "Can NFT inputs be auto-populated in transaction builders?",
          "answer": "No elegant solution exists yet for auto-populating NFT inputs. NFTs must be explicitly passed in the template rather than populated automatically. Most transactions requiring NFTs need to specify a particular outpoint anyway (\"use this exact UTXO\"), making auto-selection less useful than with fungible assets."
        },
        {
          "question": "What features does the Flowee API transaction builder provide?",
          "answer": "The Flowee API transaction builder includes: automatic byte count calculation, output adjustment to achieve specific fee-per-byte targets, and BIP69 anonymity features (deterministic input/output ordering). These are reference implementations for transaction building best practices."
        }
      ]
    },
    {
      "name": "Debugging & Development Tools",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "What debugging capabilities does CashScript v0.11.0+ provide?",
          "answer": "CashScript v0.11.0+ adds debugging support for the new transaction builder, allowing use with mocknet for local testing and integration with the Bitauth IDE. You can call .debug() on failed transactions or .bitauthUri() to manually inspect. The debugging works with the contract's optimized bytecode, so dev and prod contracts are identical, eliminating the dev/prod discrepancy that could hide bugs."
        },
        {
          "question": "Can you debug transactions that spend from multiple different smart contracts?",
          "answer": "Yes, in CashScript v0.11.0+. Use the new transaction builder to combine multiple contracts in a single transaction, then call .debug() or .bitauthUri() on it. The Bitauth IDE allows you to click through and debug each input individually, making multi-contract transaction debugging straightforward."
        },
        {
          "question": "Can you select specific inputs to debug in TransactionBuilder.debug()?",
          "answer": "No, debug() automatically debugs the entire transaction. When you open the Bitauth URI (logged on debug failure or via bitauthUri()), you can click through different inputs one by one in the IDE. This allows inspecting each input individually even though debugging operates on the complete transaction."
        },
        {
          "question": "What is CashScript Arena?",
          "answer": "CashScript Arena (arena.layer1.cash) is an interactive learning platform with challenges based on exploitable or broken smart contracts. It's designed for both complete beginners (first challenge just requires setting up the environment) and experienced developers to practice contract security and CashScript fundamentals."
        }
      ]
    },
    {
      "name": "Version-Specific Features & Updates",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "What new features does CashScript v0.11.0 introduce?",
          "answer": "v0.11.0's highlight is debugging capabilities for the new transaction builder, allowing use with mocknet for local testing and Bitauth IDE integration. The old simple transaction builder is deprecated. The release includes sourcemaps that work with optimized bytecode so dev and prod contracts are identical. See migration-notes in docs for breaking changes."
        },
        {
          "question": "What new features does CashScript v0.11.4 include?",
          "answer": "v0.11.4 includes a bug fix for P2PKH-only transactions and enhanced MockNetworkProvider functionality that allows simulating a real network more closely during testing. Both features were contributed by the community (mainnet_pat)."
        },
        {
          "question": "What new features does CashScript v0.12.0 introduce?",
          "answer": "v0.12.0 removes the old deprecated transaction builder and adds: 1) getVmResourceUsage() function to measure VM resource consumption, 2) New TransactionBuilder safety options, 3) Several breaking changes requiring migration (see migration-notes in docs)."
        },
        {
          "question": "What new guides are available in the CashScript documentation?",
          "answer": "The CashScript docs now include two essential BCH development guides that document assumed knowledge: 1) \"Transaction Lifecycle\" guide explaining how transactions are created, validated, and propagated, and 2) \"Adversarial Analysis\" guide covering security considerations and attack vectors in smart contract development."
        }
      ]
    },
    {
      "name": "Common Issues & Troubleshooting",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Why does my CashScript transaction hang when using ElectrumNetworkProvider?",
          "answer": "If using CashScript v0.10.0 with chipnet, the old default electrum server is down. Either pass a custom server like chipnet.bch.ninja when instantiating ElectrumNetworkProvider, or upgrade to the @next pre-release which has updated default servers."
        }
      ]
    },
    {
      "name": "Protocol Features & Capabilities",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Does Bitcoin Cash have MAST or Taproot?",
          "answer": "No, BCH does not currently have MAST or Taproot. However, there's an ongoing CHIP proposal for OP_EVAL which would enable MAST-like constructions. Additionally, MAST functionality can be emulated today using BCH's native introspection opcodes, specifically OP_UTXOBYTECODE, without requiring a protocol upgrade."
        },
        {
          "question": "Does the CashScript SDK support OP_CHECKMULTISIG?",
          "answer": "No, the language supports it but the SDK does not. OP_CHECKMULTISIG requires collaborative transaction building support which isn't currently implemented. The recommended alternative is using NFTs for multisig authorization - for 1-of-M scenarios, NFT ownership proves authorization; for N-of-M, participants can merge NFTs non-interactively to accumulate the required N signatures."
        },
        {
          "question": "What advantages does NFT-based multisig offer over traditional OP_CHECKMULTISIG?",
          "answer": "NFT-based multisig provides better discoverability and easier backup recovery. Since NFT ownership is on-chain and queryable, wallets can discover multisig authorization tokens by scanning the blockchain. Traditional multisig requires coordinating public keys off-chain. For N-of-M scenarios, NFTs can be merged non-interactively to accumulate signatures."
        }
      ]
    },
    {
      "name": "BCH Fundamentals & Philosophy",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "Why don't smart contracts need human intermediaries?",
          "answer": "Smart contracts hold funds in a trustless manner where even the contract creator cannot access them. Funds are controlled by code logic that executes deterministically on the blockchain. This removes human custody risk - no one can unilaterally change the rules, steal funds, or fail to execute. While many applications still require a 'transaction server' to invoke contract functions, the critical difference is custody: the server cannot steal funds, only help construct valid transactions according to immutable contract rules."
        },
        {
          "question": "What is the main difference between a server-controlled wallet and a smart contract?",
          "answer": "The critical difference is custody and immutability. Smart contracts commit to constraints that even the contract creator cannot change - e.g., if a contract requires 10% to go to address A, it will do so forever. A server-controlled wallet relies on a private key and code that can be updated anytime to change payout rules. The question isn't about needing a server, it's about who controls the funds."
        },
        {
          "question": "What is the correct mental model for CashScript contract deployments?",
          "answer": "Think of all CashScript contracts as elaborate spending conditions rather than deployments. Some contracts have unique 'deployments' (a UTXO authenticated by a tokenid) like Moria and ParityUSD, but others are just spending scripts like multisig or vaults. Contracts that share the same spending conditions without unique parts get a stable address over time. Depending on your contract type, you care about total 'balance' or specific UTXOs on the address."
        },
        {
          "question": "What mental model should you have for UTXO covenants?",
          "answer": "Each UTXO has its own program/script that can specify the full required transaction shape. A UTXO can require other specific scripts to be present in the same transaction. This enables complex multi-party transaction patterns where different inputs enforce different spending conditions that must all be satisfied simultaneously."
        },
        {
          "question": "How is data storage different between CashScript/BCH and Solidity/Ethereum?",
          "answer": "BCH doesn't have global state like Ethereum. Instead, you store data in CashToken NFT commitments - currently limited to 40 bytes, expanding to 128 bytes on May 15, 2025. This gives you local transferrable state that your contract can introspect and update. You can even store functions themselves in token commitments (if they fit in 128 bytes), creating 'local transferrable functions'."
        }
      ]
    },
    {
      "name": "Language Features & Syntax",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What language improvements are planned for CashScript?",
          "answer": "Near-term improvements include: 1) Enforcing correct bytesX types for .split() assignments, 2) Disallowing bytesX in function arguments (untrusted/unenforced), 3) Renaming tx.age to this.activeInputAge, 4) New activeInput syntax (this.activeInput instead of tx.inputs[this.activeInputIndex]), 5) Syntactic sugar for slice operations, 6) Source maps for optimized bytecode, 7) Struct functionality for naming bytestring parts. Longer-term: Template syntax for constructor arguments to insert them exactly where needed rather than always at the start."
        },
        {
          "question": "What two types of structs are being considered for CashScript?",
          "answer": "Two types are planned: 1) Fixed-size bytestructs that only support bytesX types for simple bytestring parsing, and 2) General variable-size structs that support all types (bytes, int, string). With bigint support, casting to fixed bytesize adds overhead, so both types will likely be needed. Variable-size structs would store length prefixes for each field, similar to how some contracts manually pack data today."
        },
        {
          "question": "Will CashScript support global constants?",
          "answer": "Yes, global constants are planned and tracked in an open issue. Unlike local constants which currently get pushed onto the stack, global constants would be inlined at compile time, avoiding unnecessary opcode overhead. This is a common feature in other languages and would improve contract efficiency. Breaking changes like this would only be introduced with major version updates."
        },
        {
          "question": "What does renaming tx.age to this.age clarify?",
          "answer": "The rename from tx.age to this.age clarifies that this field represents a UTXO-level property (the age of the specific input being evaluated), not a transaction-level property. This follows the pattern where 'this' refers to properties of the active input, making the code more intuitive and preventing confusion about what age actually measures."
        },
        {
          "question": "What new syntax did CashScript v0.11.3 add?",
          "answer": "Version 0.11.3 added a new .slice(start, end) syntax for extracting byte ranges from byte arrays, along with improved type safety around both .split and .slice operations. This provides more intuitive substring-like operations on bytes data, similar to array slicing in other languages."
        },
        {
          "question": "Does CashScript support do-while loops?",
          "answer": "Yes, CashScript@next has do-while loop support using OP_BEGIN and OP_UNTIL opcodes. Install cashc@next to compile contracts with do-while loops, or try the preview playground at next.cashscript.org. Version 0.13.0-next.1 fixed edge cases when using do-while loops with the SDK debug tooling. This implements bounded loops to maintain deterministic execution and enables iteration over transaction inputs/outputs and other bounded operations."
        },
        {
          "question": "What emergent patterns have CashScript users developed?",
          "answer": "Three key patterns emerged: 1) Defining structs as comments to track bytearray splitting, 2) Creating abstractions for macros/reusable functions and constants across contract files (like Fex.cash does), 3) Defining transaction shapes inside contract logic files to clarify what introspection indexes refer to. These patterns are being studied for potential native language support."
        },
        {
          "question": "Why is defining transaction shapes in contract files unique to CashScript?",
          "answer": "This pattern is unique to programming in the UTXO model with introspection. No other programming language has this because BCH is advancing the state of the art - pioneering UTXO-based smart contracts with transaction introspection. This requires inventing new UTXO-specific language features, which requires significant research to get right."
        }
      ]
    },
    {
      "name": "Type System & Casting",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "How does integer to bytes casting work in CashScript without a length argument?",
          "answer": "When casting `bytes(n)` without a length argument, it's simply a no-op - no call to OP_NUM2BIN is needed. The variable remains in scriptnumber format (minimal encoding). Only when you specify a length like `bytes8(n)` does CashScript generate OP_NUM2BIN with the explicit length parameter."
        },
        {
          "question": "Why is casting integers to fixed-size bytes important in CashScript?",
          "answer": "Casting integers to fixed-size byte-length is critical when storing local state in an NFT commitment. If you have multiple values concatenated in one field, you need fixed length for most items to be able to split them. BCH script uses scriptnumbers which have variable-length encoding, so explicit casting to bytesX ensures predictable byte offsets for parsing."
        },
        {
          "question": "What happens with OP_NUM2BIN overflow in BCH?",
          "answer": "Currently, OP_NUM2BIN can overflow if you cast to a byte size too small for the number (e.g., trying to fit a large number into bytes1). However, with the BigInt upgrade (May 2025), maxint equals maxstack, eliminating overflow issues. After the upgrade, any valid stack item will be convertible to a valid int through BIN2NUM without overflow, though you may still hit VM resource limits."
        },
        {
          "question": "What is BigInt support in CashScript?",
          "answer": "As part of the VM limits upgrade preparation, CashScript can now test for proper BigInt support. This allows contracts to work with arbitrarily large integers beyond the previous limits. BigInt support affects struct design since casting to fixed bytesize adds overhead, requiring both fixed-size and variable-size struct types."
        }
      ]
    },
    {
      "name": "CashScript SDK & Development Tools",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What makes CashScript unique compared to other smart contract languages?",
          "answer": "CashScript's uniqueness isn't just advanced language features - it's the ecosystem: 1) SDK with a fully overhauled transaction builder API and integrated debugging functionality, 2) Mocknet support for local testing, 3) Bitauth IDE integration for visual debugging, 4) Online playground for experimentation, 5) Contract testing suite, 6) Syntax highlighting and auto-completion in editors. This comprehensive tooling makes BCH covenant development accessible despite the complexity of the UTXO model."
        },
        {
          "question": "Why should you use TypeScript with CashScript instead of JavaScript?",
          "answer": "TypeScript catches type errors at compile time that would otherwise cause runtime failures. The CashScript team worked hard to provide full type checking from start to finish - TS artifacts automatically integrate unlocking types, function signatures, and parameter validation. Many common errors like wrong argument counts, incorrect UTXO structure, or invalid API calls are immediately caught by the TypeScript compiler."
        },
        {
          "question": "How should you compile CashScript artifacts for TypeScript projects?",
          "answer": "For best TypeScript integration, compile artifacts to .ts format instead of .json. This provides full type checking including automatic unlocking types for contract functions. Use the cashc compiler's TypeScript output option. The TypeScript artifacts enable the IDE to catch type errors at compile time rather than runtime."
        },
        {
          "question": "What is the correct way to access contract functions in the SDK?",
          "answer": "Use `contract.functions.functionName(args)` to create unlockers. For example: `contract.functions.refund(signatureTemplate)`. The older `contract.unlock` API is deprecated. Each function call returns an unlocker that you pass to TransactionBuilder.addInput() or addInputs() as the second parameter."
        },
        {
          "question": "What parameters does TransactionBuilder constructor accept?",
          "answer": "TransactionBuilder requires a `{ provider }` parameter with a NetworkProvider instance, not `{ addressType }`. For example: `new TransactionBuilder({ provider: new ElectrumNetworkProvider() })`. The addressType is specified when instantiating the Contract, not the TransactionBuilder. For testing, use MockNetworkProvider."
        },
        {
          "question": "Is TransactionBuilder.build() an async function?",
          "answer": "No, txb.build() is synchronous and returns a string immediately. You don't need to await it. Simply call `const txHex = txb.build();` without the await keyword. This is a common mistake when migrating from other transaction building libraries."
        },
        {
          "question": "Should you prefix hex strings with '0x' in CashScript contract constructor parameters?",
          "answer": "No, don't prefix hex strings with '0x' when passing them as contract constructor arguments. CashScript handles hex strings directly without the prefix. For example, pass the hash as `params.otpHashHex` not `'0x' + params.otpHashHex`. The '0x' prefix is only used in certain contexts like literal bytes in contract code."
        },
        {
          "question": "Should you mix libauth transaction building with CashScript TransactionBuilder?",
          "answer": "No, don't tinker with libauth transaction building when using the CashScript TransactionBuilder. CashScript provides a higher-level abstraction that handles transaction encoding internally. Mixing the two creates confusion and errors. Use CashScript's TransactionBuilder API exclusively for contract transactions unless you have very specific low-level requirements."
        },
        {
          "question": "How do you integrate CashScript TransactionBuilder with WalletConnect?",
          "answer": "Use the generateWcSourceOutputs utility function to convert from CashScript TransactionBuilder to WalletConnect object in 4 lines: Build the unsigned transaction, decode it with decodeTransaction(hexToBin(unsignedRawTransactionHex)), then call generateWcSourceOutputs(transactionBuilder.inputs, decodedTransaction). This standardized pattern simplifies WalletConnect integration for dapp developers."
        },
        {
          "question": "How does CashScript v0.11.1 integrate with BCH WalletConnect?",
          "answer": "CashScript v0.11.1 added a TransactionBuilder method to generate BCH WalletConnect transaction objects. Developers can build transactions using the SDK's TransactionBuilder, then call a method to convert it to a WalletConnect-compatible format that can be sent to a WC client for signing. This simplifies dapp development by standardizing wallet integration."
        }
      ]
    },
    {
      "name": "Debugging & Testing",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What debugging capabilities did CashScript v0.11.0 add?",
          "answer": "Version 0.11.0 added debugging capabilities for the transaction builder, allowing it to be used with local testing via MockNetworkProvider and inside the Bitauth IDE. The release was in development for over 6 months with multiple pre-releases to handle edge cases. This greatly improved the developer experience by enabling visual debugging and local contract testing."
        },
        {
          "question": "Why do you need to upgrade both cashc compiler and cashscript SDK to use improved debugging?",
          "answer": "The cashc compiler v0.11 outputs additional debug data in the artifact JSON that the SDK's debugging tooling requires. If you use cashc v0.8 with cashscript SDK v0.11, the debugging tooling won't work as well because the artifact lacks the necessary debug metadata. Both must be v0.11+ to get full benefits of mocknet testing and Bitauth IDE integration."
        },
        {
          "question": "What MockNetworkProvider improvements were added in CashScript v0.11.4?",
          "answer": "Version 0.11.4 added features to MockNetworkProvider that allow it to simulate a real network more closely, making local testing more realistic. The release also included a bug fix for P2PKH-only transactions. Both features were contributed by the community (mainnet_pat)."
        },
        {
          "question": "What debugging improvements did CashScript v0.11.5 add?",
          "answer": "Version 0.11.5 enhanced debugging by including the input index in console.log statements, making it easier to identify which input is being evaluated in multi-input transactions. It also improved type inference for function and constructor arguments in the Contract class, and cleaned up dependencies by removing accidental @types/node inclusion."
        },
        {
          "question": "How can you visualize the CashScript to opcode mapping for debugging?",
          "answer": "Use the Bitauth IDE debugging integration via `const uri = await transactionBuilder.getBitauthUri();`. This generates a URI that opens in Bitauth IDE showing: CashScript source code as comments in the middle panel, compiled opcodes color-highlighted, and execution results for each opcode on the right panel. This requires the full transaction context from TransactionBuilder, not available with compiler-only operations."
        },
        {
          "question": "Does CashScript mocknet support upcoming BCH upgrades like Layla (BCH 2026)?",
          "answer": "Yes, MockNetworkProvider allows you to configure which virtual machine version is used for evaluation. You can test against BCH 2026 (Layla upgrade) features locally. The CashScript@next branch has BCH 2026 set as the default mocknet configuration, enabling developers to test loop constructs and other new opcodes before the May 2025 network upgrade."
        }
      ]
    },
    {
      "name": "Contract Bytecode & Advanced Patterns",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What is this.activeBytecode in CashScript and what does it contain?",
          "answer": "this.activeBytecode represents the complete contract bytecode of the input currently being evaluated, consisting of constructor arguments (prepended in reverse order) + contract body. Critically, it does NOT contain the unlocking arguments (function parameters). This is different from tx.inputs[i].unlockingBytecode which represents the scriptSig that includes function arguments, constructor arguments, and contract body."
        },
        {
          "question": "What is 'simulated state' in CashScript contracts?",
          "answer": "Simulated state is a pattern where contracts modify their own constructor arguments to simulate state changes across transactions. The contract strips out old constructor arguments from this.activeBytecode, prepends new ones (with proper push byte encoding like 0x14 for 20-byte pushes), hashes the result, and requires the output to lock to this new bytecode. The major drawback is that each state change creates a new contract address, making it difficult to track the 'current' contract location."
        },
        {
          "question": "Why is simulated state considered an antipattern in modern BCH contracts?",
          "answer": "Simulated state changes the contract address with each state transition, requiring off-chain tracking of the current active contract. It's also complex to implement - you must carefully calculate constructor argument sizes, strip them from bytecode, add new ones with proper push byte encoding, then derive the new locking bytecode before building the transaction. Modern contracts use CashTokens NFT commitments to store state instead, keeping a stable contract address while allowing state to evolve in the token's commitment field."
        },
        {
          "question": "How do you manually encode constructor arguments when modifying contract bytecode?",
          "answer": "Constructor arguments must be prepended to the contract body in reverse order with push byte encoding. For example, a 20-byte argument requires the prefix 0x14 (hex for decimal 20) followed by the 20 bytes of data. A bytes32 would use 0x20. This encoding tells the BCH VM how many bytes to push onto the stack. You can see examples in contracts that use simulated state, like the Refresh contract which reconstructs itself with new constructor arguments."
        },
        {
          "question": "What is the hidden function selector argument in multi-function contracts?",
          "answer": "If you have more than one function in a contract, there is a hidden/implicit input argument for the function selector. This is related to the if/else opcodes before/after each function that route execution to the correct function. You need to be aware of this when calculating byte offsets for bytecode manipulation. However, the function selector is not part of this.activeBytecode - it's part of the unlocking bytecode."
        },
        {
          "question": "What is the difference between optimized and unoptimized contract bytecode in CashScript?",
          "answer": "CashScript produces optimized bytecode for production use (smaller, more efficient). The artifact also contains unoptimized bytecode under 'debug.bytecode' for debugging purposes. In v0.11.0+ debugging tooling, the dev and prod contracts were made identical - both use optimized bytecode. However, factory contracts creating child contracts must match the bytecode type (optimized vs unoptimized) to generate correct addresses."
        },
        {
          "question": "How do you handle factory contracts that create child contracts with matching addresses?",
          "answer": "To ensure factory-created contract addresses match SDK-compiled contracts, use the optimized bytecode from Contract.bytecode (not the raw artifact debug bytecode) as the parameter in your factory contract. The factory should concatenate constructor args + optimized bytecode, hash it, and create the P2SH32 address. This ensures addresses match when you later instantiate the child contract with new Contract()."
        },
        {
          "question": "What is the optimization boundary problem for reusable CashScript functions?",
          "answer": "When CashScript functions are compiled in different contexts (e.g., main contract vs. XO templates), the optimizer may produce slightly or greatly different opcode outputs due to cross-function optimization. This creates audit burden - the same high-level code may compile to different bytecode depending on context. The proposed solution is a facility to mark functions for isolated optimization, ensuring consistent opcode output across usages. This is tracked in GitHub issue #256."
        }
      ]
    },
    {
      "name": "CashTokens",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "How do you create CashToken genesis transactions with the CashScript SDK?",
          "answer": "Creating CashToken genesis is easy with the advanced transaction builder. Simply add a token parameter field to your output: `token: { amount: 100n, category: contractUtxos[0].txid }`. The category must be the txid of the input being spent (at index 0 for genesis). The SDK handles all the complexity - you just specify the token amount and category in your transaction outputs array."
        },
        {
          "question": "How do you burn CashTokens (NFTs or fungible tokens) in a transaction?",
          "answer": "Simply leave the token out of your transaction outputs - any tokens in inputs that don't appear in outputs are automatically burned. This is a common gotcha: developers are sometimes surprised that omitting a token from outputs destroys it. There's no explicit 'burn' operation; non-preservation equals burning."
        }
      ]
    },
    {
      "name": "Transaction Building & Fees",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "Can you introspect the transaction fee inside a BCH smart contract?",
          "answer": "No, transaction fee is not directly introspectable in BCH script. You must calculate it yourself by summing all input and output values. Contracts often hardcode an expected fee amount (like minerFee = 1000 satoshis in the Mecenas example), but this only represents the actual fee if the contract also restricts the number of inputs/outputs (e.g., require(tx.inputs.length == 1)). Without loops, contracts typically require a fixed or limited number of ins/outs to make fee calculation feasible."
        },
        {
          "question": "Why can't contracts precisely control transaction fees for arbitrary numbers of inputs/outputs?",
          "answer": "Calculating the exact transaction fee requires summing all input values and all output values. Since BCH script doesn't have loops, you cannot iterate over an arbitrary number of inputs and outputs to compute this sum. Contracts work around this by requiring a fixed number of inputs/outputs or very limited variability, making the fee calculable with explicit additions rather than loops."
        },
        {
          "question": "How do you require two different parties to sign inputs in a single transaction?",
          "answer": "You need two separate scripts/contracts, not a single multisig. Script1: \"I can only be spent by person A and need to be next to an input with script2\". Script2: \"I can only be spent by person B and need to be next to an input with script1\". These create two different P2SH addresses, and both UTXOs must be present as inputs in the same transaction, each providing its required signature."
        },
        {
          "question": "What is Median Time Past (MTP) and why does BCH use it for time-based locktimes?",
          "answer": "Median Time Past (MTP) is a trailing measure of the median timestamp from the previous 11 blocks. BCH uses MTP for time-based locktimes because it's a decentralized system without a real-time concept of accurate time. This means your CLTV time-locked transaction may not be accepted immediately when your wall clock shows the locktime has passed - you must wait for MTP to advance past your locktime value."
        }
      ]
    },
    {
      "name": "Common Errors & Debugging",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What does the 'missing inputs' error mean and how do you debug it?",
          "answer": "The 'missing inputs' error means your transaction is literally missing one or more inputs - it's a transaction building issue, not a signing issue. Debug by console.log-ing the UTXO before calling transactionBuilder.addInput(someUtxo, someUnlocker) to verify it's not undefined. You're likely passing undefined values to addInput or addInputs, possibly from failed UTXO lookups."
        },
        {
          "question": "How do you properly pass function arguments (unlockers) to TransactionBuilder?",
          "answer": "There is no `setUnlocker()` method. You pass the unlocker directly to `addInput()` as the second parameter: `txb.addInput(utxo, contract.functions.refund(signatureTemplate))`. Each input can have its own unlocker specifying which contract function to call and with what arguments. Refer to the transaction builder documentation examples for correct API usage."
        },
        {
          "question": "What does 'bad-txns-nonfinal, non-final transaction (code 64)' error mean?",
          "answer": "This error means you set a blockheight as locktime that hasn't been reached yet by the blockchain. The transaction is non-final and cannot be broadcast until the specified blockheight is reached. Debug by logging your locktime value and comparing it to the current blockheight: `console.log(await provider.getBlockHeight())`. For time-based CLTV, ensure you're using Unix timestamps (not block heights) and the time has passed."
        },
        {
          "question": "Why shouldn't you rely on AI (ChatGPT/Claude) to generate CashScript code?",
          "answer": "AI frequently hallucinates non-existent CashScript methods and APIs. For example, ChatGPT generated code using `txb.setUnlocker()` which doesn't exist in the TransactionBuilder API. As noted by CashScript maintainers: 'AI is just making shit up here.' Always refer to the official CashScript documentation at cashscript.org instead of trusting AI-generated code snippets."
        }
      ]
    },
    {
      "name": "Advanced Topics & CHIP Proposals",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What is the relationship between CashScript and OP_EVAL proposals?",
          "answer": "CashScript developers are actively engaged with OP_EVAL CHIP proposals, providing feedback on how function evaluation would work in the language. OP_EVAL would enable MAST-like constructions and potentially enhance CashScript's capabilities for complex contract patterns."
        },
        {
          "question": "Is there a CHIP proposal for adding loops to BCH script?",
          "answer": "Yes, there is a CHIP (2021-05) for bounded looping operations. The proposal was last updated in 2024. Bounded loops would allow iteration over transaction inputs/outputs and other structures while maintaining deterministic execution and preventing infinite loops through iteration count limits."
        },
        {
          "question": "How can Schnorr signatures improve smart contract privacy on BCH?",
          "answer": "Schnorr signatures enable multi-party key aggregation schemes where multiple parties cooperatively 'add together' their public keys to produce one aggregated pubkey and one aggregated signature. This allows smart contracts to settle on-chain as simple P2PKH transactions rather than revealing the contract script. Mark Lundeberg calls this 'Hiding as P2PKH' - it uses interactive cryptography to regain privacy by making smart contract settlements indistinguishable from regular transfers."
        }
      ]
    },
    {
      "name": "Use Cases & DeFi",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "How can smart contracts enable trustless inheritance on Bitcoin Cash?",
          "answer": "Instead of giving someone custody of your BCH funds to process inheritance, you can use a smart contract where you retain custody but after some idle time your relatives can claim funds according to contract rules. This removes the risk of the custodian stealing or mismanaging the funds. The LastWill contract pattern allows heirs to claim funds after a specified inactivity period while the owner can reset the timer."
        },
        {
          "question": "Can BCH smart contracts enable ratio swaps and derivatives trading?",
          "answer": "Yes, BCH can enable ratio swaps and derivatives through smart contracts. AnyHedge (accessible via bchbull.com) demonstrates this - you can gain or lose BCH based on price changes against supported assets like USD or BTC. If BTC goes up and BCH goes up more, you capture the full benefit of the ratio change. This enables long/short positions on price ratios between assets."
        },
        {
          "question": "Can BCH smart contracts enable trading on non-BCH asset pairs like XMR/BTC?",
          "answer": "Yes, you can use BCH as a proxy between two assets. If BCH Bull supported XMR but didn't support BTC-XMR pairs directly, you could theoretically set up two different AnyHedge-style contracts to achieve near the same result - one for BCH/XMR and another for BCH/BTC. This leverages BCH's smart contract capabilities to trade ratios between assets that don't have their own DeFi infrastructure."
        },
        {
          "question": "What 2-party atomic swap pattern exists for BCH?",
          "answer": "The 2-party atomic swap contract setup pioneered by bitcoincashautist backs tapswap.cash NFT marketplace. It uses coordinated UTXOs where both parties must provide inputs to complete the swap atomically. The pattern is documented in the simple-swap repository and demonstrates multi-party transaction coordination."
        }
      ]
    },
    {
      "name": "Ecosystem & Learning Resources",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What is CashScript Arena and how does it help developers learn?",
          "answer": "CashScript Arena (arena.layer1.cash) is a learning platform where developers challenge each other with intentionally broken or exploitable smart contracts. It targets complete beginners, starting with environment setup challenges and progressing through vulnerability exploitation exercises. This CTF-style approach teaches CashScript security patterns through hands-on experience finding and exploiting contract flaws."
        },
        {
          "question": "What general BCH development guides did CashScript documentation add?",
          "answer": "CashScript added Transaction Lifecycle (cashscript.org/docs/guides/lifecycle) and Adversarial Analysis (cashscript.org/docs/guides/adversarial) guides. These cover general BCH development concepts that were previously assumed knowledge but never formally documented. They help developers understand transaction processing stages and potential attack vectors when designing contracts."
        },
        {
          "question": "What is CashScript-Py and why is it important?",
          "answer": "CashScript-Py is a Python version of the CashScript SDK being developed to bring BCH smart contract programming to Python developers. Python is one of the world's most popular languages, but Python developers currently have few tooling options for BCH smart contracts. CashScript-Py aims to attract new developers and enable new application categories."
        },
        {
          "question": "Why doesn't the CashScript VSCode extension appear in Cursor's extension marketplace?",
          "answer": "Cursor uses the open-vsx marketplace instead of Microsoft's VSCode marketplace due to licensing restrictions. Extensions must be published separately to open-vsx to appear in Cursor. The workaround is either to download the VSIX file manually from open-vsx.org and install it, or wait for the extension to propagate after the developer publishes it to open-vsx."
        },
        {
          "question": "Can the CashScript playground be pre-populated with contract code via URL parameters?",
          "answer": "This capability was discussed as a feature request for CashScript Arena integration. The idea is to add an 'open in playground' button that would open the playground with a specific contract pre-loaded, instantiated, and with parameters prepared. This would make it super easy for beginners to start working with contracts. Implementation is feasible but wasn't available at the time of discussion."
        },
        {
          "question": "How can you create unique contract addresses for faucets without changing contract logic?",
          "answer": "Use an index parameter as a constructor argument that doesn't affect contract behavior. Example: `require(index >= 0);` - this uses the index to avoid compiler warnings about unused variables while allowing each user to generate a unique address by choosing their own index. This pattern lets faucets fund unique addresses for different users without changing contract rules."
        }
      ]
    },
    {
      "name": "Version History & Major Releases",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What major changes were in CashScript v0.12.0?",
          "answer": "Version 0.12.0 removed the old deprecated TransactionBuilder, introduced getVmResourceUsage() to measure VM resource usage, added new TransactionBuilder safety options, and included several small breaking changes. This was a maintenance-focused major release cleaning up deprecated functionality and improving developer safety features."
        }
      ]
    }
  ]
}