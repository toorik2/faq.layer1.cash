{
  "title": "BCH FAQ - Comprehensive Technical Guide",
  "description": "A searchable collection of technical Q&A from BCH Devs & Builders, CashScript, CashTokens, BCH Compilers, and Electron Cash communities",
  "total_faqs": 971,
  "categories": [
    {
      "name": "Standards & Specifications",
      "description": "Protocol specifications, standards, BIPs, address formats, and technical references",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "What is this FAQ and how was it created?",
          "answer": "This is a comprehensive technical FAQ database for Bitcoin Cash development, containing 643+ questions and answers across 54 categories. The content was extracted from technical Telegram group discussions (BCH Devs & Builders, CashScript, CashTokens, and BCH Compilers communities) using AI analysis. Each Q&A captures real developer conversations, technical insights, and community knowledge about BCH protocol development, smart contracts, token standards, wallets, and infrastructure."
        },
        {
          "question": "Can read-only inputs be spent in the same block as a full spend of the same UTXO?",
          "answer": "It depends on specification. If spent in the same block, it could be defined either way as long as clearly specified. Once a UTXO is spent in a previous block, it cannot be referenced read-only anymore. However, mempool and reorg complexity increases - if a block spending A is reorged, it must include A plus all dependent transactions."
        },
        {
          "question": "How does P2S address standardness issues?",
          "answer": "P2S (Pay to Script) addresses 2 of 5 standardness issues: output standardness and max script size. Doesn't touch dust, opreturn or max tx size. See bitcoincashresearch.org/t/non-standard-transactions-out-of-band-miner-submission/1257/10 for discussion."
        },
        {
          "question": "How should exchanges store BCH addresses in database?",
          "answer": "BCA: Personally would store hashes and then generate address for user UX on-the-fly, especially since you may want to support multiple types (BTC legacy, BCH cashaddress, BCH token cashaddress). Addresses work too, just moves encoding/decoding to elsewhere."
        },
        {
          "question": "How would faster block times affect exchange confirmation requirements?",
          "answer": "If BCH magically had 2min blocks before gaining respect/market share, exchanges would likely 5x the number of required confirmations (from 6 to 30). You don't get respect by changing yourself - in business you get respect by being profitable for them. Need to become bigger part of their income first."
        },
        {
          "question": "What are the key SEO factors for improving website rankings?",
          "answer": "Main SEO factors: 1) Avoid AI-generated content (can be detected and downranked). 2) Get organic backlinks, especially from high-authority sites. 3) Consistently update with fresh content (blog section, news). 4) Domain name should match target keywords (e.g., 'BCHEcosystem' vs 'minisatoshi' for 'Bitcoin Cash Ecosystem'). 5) Align metadata tags with content. 6) Distribute links across platforms (Twitter, Telegram, Reddit, Bitcoin Cash Research)."
        },
        {
          "question": "What is BCH reference spec purpose vs howtos?",
          "answer": "BCA/Tom: Reference specification just tells data formats (tx, block, network messages) and consensus & network rules. Implementing or using software that satisfies spec is not part of spec. Reference spec is to be read by implementers of software, not by end users."
        },
        {
          "question": "What is BCH specification repo structure issue?",
          "answer": "Tom: Git repo was made by some people, inherited by other people, copied by several projects to show on their own sites, then maintained by random people sometimes copying between repos. Not ideal, has structure that is in many ways flawed."
        },
        {
          "question": "Which BCH specification repos are actively maintained?",
          "answer": "Dustin: BU accepted PRs (reference.cash) and Flowee took input to update their copy (flowee.org/docs/spec/). Tom's codeberg.org/bitcoincash/specification is most consistently maintained version - tries to find changes others make and pull them in as well as make fixes."
        },
        {
          "question": "Why is assurance contract aspect critical for Flipstarter?",
          "answer": "Key aspect (along with focused window of opportunity) that gives people confidence to pledge large amounts. It all funds or not - prevents falling back to sporadic donations which historically result in very little. Reason for doing this pain in the ass novel thing (copy of lighthouse)."
        },
        {
          "question": "Why use pseudonymity for BCH development?",
          "answer": "You should not use your real name here IMHO, especially if you plan to become a dev. Anonymity or pseudonymity is very useful when doing groundbreaking controversial stuff. Government names created by state - legal fiction they can tax and regulate."
        },
        {
          "question": "How does Ethereum global state pricing work?",
          "answer": "Pat/Jonathan: Ethereum global state is huge RocksDB-based KV database. Storage reads and writes cost extra gas accounted for in tx fees. You can choose what to store and read, don't need to pay for part of global state you don't care about. Individual read/writes don't need to touch rest of it."
        },
        {
          "question": "What is \"perfect is enemy of good\" in BCH context?",
          "answer": "Response to argument that faster blocks don't solve double spend problem in exact logical maxwellian sense - like saying 'bitcoin doesn't solve the double spend problem'. Point is that improvements don't need to be perfect to be valuable. This is true in exact logical maxwellian sense."
        },
        {
          "question": "What is BCH mentorship program for developers?",
          "answer": "Bitcoin Cash University mentorship program at bitcoincashuniversity.com/mentors helps people get involved in coding on BCH. Sign up to help developers new to BCH or veterans."
        }
      ]
    },
    {
      "name": "Protocol Development & Opcodes",
      "description": "Core protocol features, opcodes, CHIPs, and consensus-level improvements including OP_EVAL, loops, VM limits, and network upgrades",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Are sidechains possible on BCH with current tools?",
          "answer": "Yes possible - SPV 2-way peg via OP_CAT (gist.github.com/A60AB5450353F40E/59eee82c5d6e3d989166bb8eaf7826e9). But nobody cares to build them. OP_CHECKSPVPROOF could simplify checking process. Industry moved to ZKPs for sidechains. Unpopular opinion: concept introduced by Core to stop on-chain innovation, always dead-on-arrival. ETH can't scale account-based architecture so L2s devouring L1. BCH doesn't need them yet - base chain power barely put to use."
        },
        {
          "question": "Big math opcodes vs native EC arithmetic for BCH?",
          "answer": "Big math may make EC primitives unnecessary, but native opcodes more efficient. Loops could emulate EC operations but very costly in time and computation. With eval, routine defined once at contract start and reused many times. Can turn loop into chain of 256 TXs with mutable NFT commitment going 255 to 0."
        },
        {
          "question": "Can BCH verify zero-knowledge proofs without a specialized ZKP verifier opcode?",
          "answer": "Yes, BCH can already verify ZKPs using existing opcodes, but it's highly impractical. You'd need to use many different contract inputs to perform the verification. Loops and optimization CHIPs (like OP_EVAL) would make it more practical. However, even with improvements, porting a zkVM's verification might cost ~10,000x typical transaction fees with limited wallet support."
        },
        {
          "question": "Can OP_DEFINE use script from neighboring input as function?",
          "answer": "Yes, BCH Functions CHIP allows defining script pushed as data in neighboring input as function and executing it in context of current script. Can use specially formed OP_RETURN-defined functions as read-only inputs, but that's not in scope - would be future extension."
        },
        {
          "question": "Can SHA256 collision in function identifier cause fork?",
          "answer": "It can cause fork if you don't specify hashing algo used. If you spec it it's fine. Hash collision just turns UTXO with 1 spending path into UTXO with 2 spending paths - whichever preimage spender uses, all nodes see same preimage and evaluate same."
        },
        {
          "question": "Can executable bit requirement be sunset later?",
          "answer": "If we change our mind: can stop caring about bit and just let eval exec whatever. Bit can be sunset. OP_PUSHSCRIPT would become NOP (or OP_PUSHDATA). Just NOP prefix to existing pushes. Once you add function tables etc, you're stuck with that. Best argument so far: if there's path to soft-fork sunset, 'cost' would just be some consumed code points."
        },
        {
          "question": "Do BCH Script opcodes need to be extended to support zero-knowledge proofs?",
          "answer": "No specialized ZKP opcode is strictly necessary. ZK proofs ultimately reduce to polynomial arithmetic which can be implemented using existing BCH Script math operations after the BigInt upgrade. However, a specialized opcode could offer performance advantages. The tradeoff is consensus layer complexity versus efficiency - building with existing opcodes first validates the use case before proposing consensus changes."
        },
        {
          "question": "Does OP_EVAL expand attack surface of BCH VM?",
          "answer": "Not adding anything new VM can't already do - just changing how you can express things. VM not supposed to be designed to protect developers from themselves. Only people who interact with VM are already highly skilled, smart enough to avoid tinkering with things they don't understand with large amounts of money. Attack surface = developers writing bugs, which they can and will do with or without OP_EVAL."
        },
        {
          "question": "Does OP_RUNSUB2 violate the principle that locking code must be known at lock time?",
          "answer": "Yes, in a sense. A P2SH redeem script containing `<0> <0> OP_RUNSUB2` doesn't know what the first input's first subroutine contains when locking funds. However, because code doesn't mix with data in the Subroutines CHIP, you're certain the executed code was present in the transaction you signed when locking the funds on-chain - it's just from a different input."
        },
        {
          "question": "Does the dust limit change with the new VM limits?",
          "answer": "No, dust limit doesn't change with the VM limits. The formula remains: dust limit = 444 + output_size * 3. Some implementations use higher values (800-1332 sats) to allow for worst-case scenarios like old school p2ms."
        },
        {
          "question": "How are BitCANN TLDs and multiple competing registries handled?",
          "answer": "One contract instance per TLD (e.g., .bch has one categoryId, .xyz another). Multiple people could launch competing instances claiming authority over the same TLD, but this is resolved off-chain through reputation. Everyone picks the instance with better reputation and it dominates/snowballs. Similar to how DNS root zones work - technical protocol allows duplicates, social consensus picks the authoritative one."
        },
        {
          "question": "How can BCH scripts have runtime-determined code?",
          "answer": "OP_INPUTINDEX OP_1ADD OP_UTXOBYTECODE OP_EQUAL - code to be ran determined after UTXO creation. Code runs on another input, but that input can spend UTXO created AFTER original input, just to provide correct bytecode in same TX context. UTXO with required locking script created after 'this' input for sole purpose of unlocking it."
        },
        {
          "question": "How can DEX micro-LPs prevent UTXO contention without consensus changes?",
          "answer": "Each micro-LP requires signature from node managing it - prevents competing transactions without requiring same server/entity/contract. Doesn't stop aggregator service combining liquidity, just ensures only valid transactions reach mempool. Can be done today with no CHIP. Pool operator gives you TX, fills in sig, makes sure doesn't sign same UTXO twice - otherwise everyone can do what they want."
        },
        {
          "question": "How can OP_EVAL enable code compression using hash verification?",
          "answer": "Pattern: `<push bytecode from stack> OP_DUP OP_HASH256 <hardcoded hash> OP_EQUALVERIFY OP_EVAL`. This compresses code to a hash in the redeem script, fetching actual bytecode from arbitrary sources (inputs, NFT commitments, etc). The code is kept off-chain until use but can be audited beforehand by revealing the code and verifying it against the hash. This is more flexible than OP_RUNSUB2's fixed subroutine tables."
        },
        {
          "question": "How can custom VMs circumvent OP_EVAL guardrails?",
          "answer": "Convoluted series of OP_IFs is custom VM just for that input, can 'execute' any data as bytecode just as Eval could. Any guardrail on op_eval circumvented by those convoluted ifs since that code wouldn't implement guardrails. Wastes blockspace on custom VM implementations when BCH VM available. Most viable: pure op_eval or nothing."
        },
        {
          "question": "How can users verify complex OP_EVAL optimized bytecode is safe?",
          "answer": "Reproducible builds solve this. If bytecode claims to be compiled from audited CashScript, you can verify: 1) audit the high-level CashScript source, 2) compile it yourself using the same compiler version, 3) compare the resulting bytecode hash to the on-chain hash. If someone provides unauditable complex bytecode - simply don't use it. The Unspent PHI vulnerability shows contracts can break regardless of OP_EVAL."
        },
        {
          "question": "How can web push notifications handle BCH recurring payments?",
          "answer": "Use browser PUSH protocol with bidirectional communication - wallet shows monthly subscription list marked green/yellow/red based on USD/EUR value match. User clicks \"Confirm and Pay All\" once verified. No oracles, NFTs, opcodes, or contracts needed. Just communication protocol + UI + send coins."
        },
        {
          "question": "How do MAST merkle proofs work for Functions CHIP?",
          "answer": "If have 20 functions in balanced tree and want to use one for define/invoke need: root hash and 4-5 additional hashes to prove leaf within tree. If redeem script using ten functions: 1 root hash and 40-50 additional hashes. Would have specific merkle root for functions your utxo uses."
        },
        {
          "question": "How do VM Limits prevent DoS attacks with OP_EVAL?",
          "answer": "VM Limits maintain an execution budget that tracks every operation executed. When the budget is depleted, the transaction becomes invalid. EVAL'd scripts are verified and evaluated the same way as normal scripts, bounded by the parent program's VM limits. This prevents scripts from running continuously or consuming excessive resources, whether they use OP_EVAL or not."
        },
        {
          "question": "How do relay rules relate to consensus in BCH?",
          "answer": "Relay rules and standardness are not technically consensus, but pseudo-consensus. Nobody can just assert what network will do, and some changes have real impact. Deserve as much thought as consensus CHIP. Can either move into consensus (like transaction version CHIP) or move out (remove rule, like P2S proposal)."
        },
        {
          "question": "How do you manually connect to a BCH node and send messages via p2p protocol?",
          "answer": "P2P handshake sequence: A sends 'version', B sends 'verack', B sends 'version', A sends 'verack'. Example version message hex: 'e3e1f3e876657273696f6e00000000005f00000020e7d3e4...'. Can use tools like nc (netcat) but requires proper message formatting. The protocol is more than just version message."
        },
        {
          "question": "How do you monitor BCH address balance changes using the Electrum protocol?",
          "answer": "Use blockchain.scripthash.subscribe to be notified about state changes (gives current state, then updates for new 0-conf payments and first confirmation). The notification doesn't include balance details, so call blockchain.scripthash.get_balance after notification. You must also understand and use server.ping to maintain the connection. See electrum-cash-protocol.readthedocs.io for Protocol Methods and Protocol Basics."
        },
        {
          "question": "How does 10^x exponentiation work in BCH Script?",
          "answer": "Jonathan/Mathieu: With loops exponentiation will get trivial! Just <10> OP_MUL then reduce counter or some such until done. BCA optimized version saves 30 bytes using binary decomposition approach. Can't believe getting so much power is only 8 months away (May 2026 upgrade)."
        },
        {
          "question": "How does BCH VM limits prevent infinite loops?",
          "answer": "Mathieu/BCA/Tom: VM limits CHIP already set hard limit to ops per input - loops can't exceed it, if they try tx will be invalid. Each byte gets 800 compute budget, different opcodes have unique opcost. Loop terminates with failure when script runs out of compute budget. Loops don't need exits, not BASIC-style GOTO."
        },
        {
          "question": "How does Electrum protocol status hash work for BCH?",
          "answer": "Used for blockchain.address.subscribe - returns status hash and emits on each update. Can cache with history + unspents to avoid refreshing each subscribe. Confirmed TXs come back with CTOR, unconfirmed sorted by height/increasing value/ascending hash. Status based on that order. State hash super expensive on server side - room for optimization if clients don't use it. Just compare to previous hash to check for update."
        },
        {
          "question": "How does executable bit add extra dimension to stack?",
          "answer": "Instead of 'OP_EVAL pops top item and executes as bytecode' you have 'OP_EVAL pops top item and executes as bytecode UNLESS top item has been result of OP_ADD, OP_SUB, OP_MOD...'. Adding extra dimension to stack - all complexity has been squared. It's just 1 bit: stack opcodes preserve it/pass it on, all other opcodes clear it. Same how OP_VERIFY cares about value of item, doesn't care HOW it got value."
        },
        {
          "question": "How does stack overflow relate to OP_EVAL safety concerns?",
          "answer": "Stack overflow bugs break code/data separation by making data executable, causing millions of security vulnerabilities historically. Critics argue OP_EVAL creates similar risks by mixing code and data. However, BCH Script already allows 'dangerous' contracts, and OP_EVAL can be implemented consensus-safely with no undefined behaviors. Individual contracts can be broken by misuse of any opcode - OP_EVAL doesn't fundamentally change this risk profile."
        },
        {
          "question": "How should OP_DEFINE and OP_INVOKE count as hashing operations?",
          "answer": "From VM Limits chip: Hashing operations add 1 + ((message_length + 8) / 64) to nHashDigestIterations, and nOpCost += 192 * iterations. Might need to salt identifier for each transaction input to avoid anyone ever finding arbitrary SHA256 collision that could cause fork."
        },
        {
          "question": "How to track BCH contract TVL and transactions like tokenaut.cash?",
          "answer": "Depends on particular contract - some have OP_RETURN markers, some have constant address, some can be tracked by NFTs that they emit. FBCH 'savings club' tracker is open source with protocols using OP_RETURNs listed at github.com/2qx/future-bitcoin-cash/blob/main/packages/lib/src/extra.ts."
        },
        {
          "question": "Is OP_DEFINE_VERIFY wasteful for saving 3 bytes?",
          "answer": "Jonas thinks wasteful to reserve opcode for saving 3 bytes for some use cases. Validating unknown code with hash is just one way of trusting external code - another might be validating specific NFT is used as input or code is signed by known pubkey."
        },
        {
          "question": "Is OP_EVAL dangerous for BCH contracts?",
          "answer": "The danger of OP_EVAL is debated. Critics cite 'mixing code and data' concerns from other contexts. Proponents argue: 1) BCH Script already allows writing dangerous contracts without OP_EVAL, 2) nobody is forced to lock funds in risky contracts, 3) OP_EVAL won't affect existing contracts that don't use it, and 4) it's analogous to subroutines in scientific calculators. Compiler complexity increases but doesn't inherently create consensus-level risk."
        },
        {
          "question": "Is the deterministic tiebreaker H(A||B) proposal a consensus change?",
          "answer": "Not a consensus change - blocks satisfy all the same consensus rules. It's like a soft fork but unusual: normally takes HF to undo SF, but here miners insisting on 1st-seen could still have blocks included if they get lucky. Following the 'wrong' policy would lose money, so miners need to know which policy everyone else follows."
        },
        {
          "question": "Should documentation.cash OP_DATA description be updated?",
          "answer": "documentation.cash/protocol/blockchain/script/op-codes/op-data-x.html says 'two's complement integer' for 1-75 byte push. Technically correct (C++ int type is 2s complement in C++20) but confusing since doesn't matter for those numbers. Should say 'unsigned int'. OP_X similar issue. Script numbers are sign-magnitude per wikipedia.org/wiki/Signed_number_representations#Sign-magnitude"
        },
        {
          "question": "What BCHD v0.21.0 updates for May 2025 upgrade?",
          "answer": "BCHD and associated tools (dnsseeder, meep, bchwallet, bchutil) updated and compatible with upgrade on 15th. Added chipnet DNS seeder at chipnet-seed.bchd.cash. meep v0.6.1 fixed Moria v1 TX inspection - just needed quick one liner fix to update flag. See github.com/gcash/bchd/releases/tag/v0.21.0"
        },
        {
          "question": "What CHIPs are planned for BCH's 2026 upgrade?",
          "answer": "The 2026 upgrade plans include Loops, OP_EVAL, and P2S CHIPs. These are still in debate stage. Jason confirmed these make ZK verification and advanced covenants smaller and way cheaper compared to current implementations. The goal is to reduce transaction fees and improve smart contract expressiveness beyond the current state."
        },
        {
          "question": "What Lokad IDs are used by Permissionless Software Foundation protocols?",
          "answer": "PSF uses several Lokad IDs: 0x00504d00 for PS008 Pin Claims (very active) and PS006 Simple Store Protocol (less active, maybe deprecated); 0x00510000 for PS010 IPFS File Pinning Protocol (very active). These protocols enable on-chain claims, data storage, and decentralized file pinning using OP_RETURN markers for protocol identification."
        },
        {
          "question": "What are MCP Servers and how do they improve LLM workflows?",
          "answer": "MCP (Model Context Protocol) Servers integrate tools like firecrawler (AI web crawler) and Brave Browser with LLMs to provide more context in requests rather than crazy chain of prompts. The MCP Server list GitHub repo (github.com/modelcontextprotocol/servers) has 20k stars and offers many integrations for dev workflows."
        },
        {
          "question": "What are alternatives to OP_DEFINE_VERIFY for code verification?",
          "answer": "Calin's take 2 and take 3 alternatives solve GP issue. Can validate external code by checking hash, verifying specific NFT used as input, or confirming code signed by known pubkey. OP_DEFINE_VERIFY is addition not replacement."
        },
        {
          "question": "What are current BCH OP_RETURN limits and restrictions?",
          "answer": "BCH moved OP_RETURN to 220 bytes. Multiple op_returns allowed in single transaction (restriction removed), but total for all must still be 220 bytes or less. See flowee.org/docs/spec/forks/multiple-op-returns-for-bitcoin-cash/"
        },
        {
          "question": "What are read-only inputs and why controversial?",
          "answer": "Read-only inputs: script reads bytecode/data from UTXO without spending it (OP_LIBRARY concept). More controversial than OP_EVAL. Peter Rizun suggested scripts could have read access to whole UTXO state (global read) while writes/modifications TX-local. Concern: write/modification could mess up all readers."
        },
        {
          "question": "What are the bytecode limits after the VM Limits CHIP?",
          "answer": "After VM Limits CHIP, bytecode and stack item length limits are no longer relevant to worst-case validation performance. Standard transactions can reach MAX_STANDARD_TX_SIZE (100,000 bytes). The increased limits on Maximum Bytecode Length and Maximum Stack Element Length apply equally to both locking and unlocking bytecode. Lower per-item limits offer no additional network safety while inconveniencing applications with larger data requirements."
        },
        {
          "question": "What are the concerns about TXv5 increasing locking bytecode limits?",
          "answer": "TXv5 proposes increasing locking bytecode from 201 bytes (P2SH limit) to 100,000 bytes. This data is stored in the UTXO set, raising concerns about UTXO bloat and node resource requirements. However, the 201-byte locking bytecode limit may not be affected - the discussion likely refers to P2SH scriptsig size standardization (10,000 bytes after P2S CHIP removes the 1,650-byte input limit)."
        },
        {
          "question": "What are the concerns with deferred TXID assignment?",
          "answer": "Kills block explorers - can't track TX before mining. 0-conf may not work without TXIDs assigned on spot. Would require consensus change and even then, not 100% sure 0-conf would work. Cannot just get rid of TXIDs and assign when miners mine them - not Nakamoto Consensus anymore."
        },
        {
          "question": "What are the ecosystem costs of consensus changes like block time?",
          "answer": "Consensus changes costly to everyone - lots of hours debugging, writing code, updating servers. Bigger upgrade = harder for companies to start building. Looming massive upgrade causes them to reconsider: 'If we can change this, what else will be changed?'"
        },
        {
          "question": "What are the focus areas for BCHD's 2025 network upgrade implementation?",
          "answer": "BCHD is implementing VM Limits and Big Int CHIPs to ensure full support and compatibility with the May 2025 network upgrade. These consensus changes expand Bitcoin Cash's smart contract capabilities by removing previous VM operation limits and enabling arbitrary-precision integer arithmetic in scripts."
        },
        {
          "question": "What are the main use cases for OP_EVAL according to BCH developers?",
          "answer": "Multiple use cases exist: 1) Jonas: optimize stack manipulation by implementing custom opcodes like OP_UNROLL, 2) MathieuG: compile CashScript functions into executable bytecode with compiler-managed calling conventions, 3) bitjson: compress bytecode by detecting repeating patterns and using CAT/SPLIT to reuse common bytes, 4) bitcoincashautist: commit hashes of code and only provide preimages when needed, saving space."
        },
        {
          "question": "What changed in BCH transaction version 2?",
          "answer": "2qx/Tom: Only change was treatment of nSequence numbers in BIP68. Version 2 was started by soft fork, didn't actually change format but changed interpretation of one field. To use opcode with sequence data in output, you were required to set version number to 2."
        },
        {
          "question": "What content strategy improves SEO for cryptocurrency websites?",
          "answer": "Combine evergreen static content with regular fresh updates. Evergreen examples: fork history maps, ecosystem links pages (get tweaked but persist). Fresh content: blog section with BCH news, commentary on developments, links to foundation/podcast content. Successful sites have both: stable resources that build authority over time, plus semi-regular new content that signals active maintenance to search engines."
        },
        {
          "question": "What documentation sources recommended for BCH developer chatbot training?",
          "answer": "CashScript docs, libauth docs, Electron-Cash protocol, SoftwareVerde bitcoin-cash-specification, BCHN announcements, documentation.cash, all CHIPs, bitcoincashresearch.org, cashtokens.org, mainnet.cash, flowee.org/docs/spec/, upgradespecs.bitcoincashnode.org, BitcoinCashPodcast.com/faqs. Mastering Bitcoin and Mastering Bitcoin Cash already added."
        },
        {
          "question": "What does 'safety' mean in the context of BCH Script contracts?",
          "answer": "Two levels exist: 1) Consensus/VM safety: code can't damage the VM (like making your computer 'go up in flames'). This is handled by VM Limits. 2) Fund safety: preventing people from spending your money without your intent. Critics argue OP_EVAL compromises fund safety by allowing runtime code generation. Both levels are important, but they address different concerns."
        },
        {
          "question": "What does emergence of AlbaVM say about BCH development?",
          "answer": "Amazing thing about BCH peacefully and consistently putting out good work: we have no visibility on continually emerging set of new things bubbling in background. Both from existing and new teams. Every specific topic in BCH has its own active channel and active community. There aren't many crypto projects with so many different channels - BCH is serious business, unlike many cryptos."
        },
        {
          "question": "What is 95% alternative to OP_EVAL proposal?",
          "answer": "Locally defined immutable OP_EVAL - can only operate on input-defined blobs, blob can't be mutated if going to get op_eval'ed. Literal op_eval but must be defined locally and can't be mutated. Going to more pro tool like eval easy moving forward, basically impossible to move back. Gray area preference."
        },
        {
          "question": "What is BCH script number encoding vs C++ encoding?",
          "answer": "Stack items use script numbers (sign+magnitude encoding). OP_X and OP_DATA_X documentation says 2s complement but numbers 1-75 work with any signing method. Numbers never put on stack - that's at different layer of script bytecode interpretation. In other places it's C++ numbers (uint/int) or custom unsigned varint encoding. C++20 requires 2s complement for signed integers."
        },
        {
          "question": "What is BitVM challenge setup for BCH ZK-rollups?",
          "answer": "BitVM provides native level of verification for commitment proofs with far less trust setup required. Challenges to commitments could come in as late as 1 week or more per Ekrem Bal's OP_Next talk. Current staking models assume there isn't an equivalent on BCH yet."
        },
        {
          "question": "What is Jerry's native elliptic curve arithmetic CHIP?",
          "answer": "Proposal for ECADD and ECMUL opcodes (bitcoincashresearch.org/t/1570). Enables native ZKP verification rather than relying on OP_CHECKDATASIG attestation. Needed for Bulletproofs, Groth16, SNARKS/BLS verification, field inversion, curve equation checks. Emulating with loops computationally expensive - must verify points lie on y2=x3+7 (mod p) secp256k1."
        },
        {
          "question": "What is OP_DEFINE_VERIFY shorthand proposal?",
          "answer": "OP_DEFINE works on any stack element no matter where it came from. Adding extra <hash> <index> OP_DEFINE_VERIFY is shorthand for OP_DUP OP_HASH256 <hash> OP_EQUALVERIFY <index> OP_DEFINE. Allows verification with hash while keeping normal OP_DEFINE for other use cases."
        },
        {
          "question": "What is OP_PUSH_EXECUTABLE proposal for static analyzability?",
          "answer": "Stack items marked executable only if pushed verbatim with OP_PUSH_EXECUTABLE. If modified (OP_ADD etc.) item loses executable bit, becomes data blob. OP_EVAL can only execute items with executable bit. Keeps static analyzability while allowing unverified code execution if script author chooses. However can be circumvented by implementing VM within VM."
        },
        {
          "question": "What is Tom's subroutines CHIP approach to OP_EVAL?",
          "answer": "Alternative to OP_EVAL using OP_RUNSUB2 and OP_DEFINESUB. Transaction creates multiple outputs that work together if spent in one transaction later - they share same prev txid. Separates code from data. Locking script requires certain unlocking script by hash - code executed in VM known at time output was mined. See bitcoincashcode.org/bitcoincash/CHIP-subroutines"
        },
        {
          "question": "What is a Turing tarpit and how does it relate to Bitcoin Script?",
          "answer": "A Turing tarpit is a system that is theoretically Turing-complete but practically useless due to extreme inefficiency. The original Bitcoin Script VM inherited by BCH was essentially a tarpit - not even Turing complete and missing basic operations like MUL, forcing repeated ADD operations instead. It's like a calculator without multiplication. BCH has been progressively escaping this tarpit with VM upgrades."
        },
        {
          "question": "What is central bank confiscation concern with OP_EVAL?",
          "answer": "Oracles today have power over funds, but only select from 2+ possible outputs pre-designed in output script when mined. Master key signature for arbitrary bytecode makes central bank style confiscation possible. If code being signed is malicious, writer has huge advantage - days to adapt to unmoving target to get script to say 'yes' for sending to themselves."
        },
        {
          "question": "What is chipnet anyone-can-spend faucet address?",
          "answer": "2qx/Kallisti: P2sh20 base58 address for <42> OP_NUMEQUAL is 2N28ZR5MgBoKq6sBceEoGvTuGs1wfZeXvFF. Kallisti mining chipnet to this address so anyone can claim coins after 100 blocks. Put coins there and took them from playground with require(answer==42) spending script."
        },
        {
          "question": "What is compromise approach with OP_EVAL and executable bit?",
          "answer": "EVAL + special push as compromise doesn't close off any future paths, still gives all nice benefits of Eval while mitigating 'we don't know what gets executed' problem. If declare some NOP as OP_PUSH_EXEC, then if one day wiser and decide to just allow Eval to run anything - can make that decision without much technical debt. Lose some benefits like cross-input compression, but if blobs all explicit then can do compression on another layer."
        },
        {
          "question": "What is covenant recursion path for AMM without consensus change?",
          "answer": "Covenant recursion could be path forward for AMM without changing consensus. Plus 2026 upgrades help even more with looping. See github.com/bastiancarmy/bitcoin-cash-trustless-defi-recursion. Needs solid peer review. Basic problem still there regarding mempool transactions pre-mine."
        },
        {
          "question": "What is debate about OP_EVAL code verification?",
          "answer": "OP_EVAL executes stack items as code. Locking script can verify with OP_DUP OP_SHA256 <hash> OP_EQUALVERIFY OP_EVAL but not required - script author's choice. Concern: allows anyone-can-spend if just OP_EVAL without verification. Counter: people can write anyone-can-sweep P2S/P2SH anyway. Separation of code/data vs primitives debate."
        },
        {
          "question": "What is locally defined immutable compression requirement?",
          "answer": "Code/data package locally defined and immutable - 'code was known at time money was locked in'. Serves local code compression use case. Tom's subroutines CHIP achieves this using P2SH principles. Prevents someone seeing locking script from writing matching code to unlock. Some argue guardrails could be circumvented (VM within VM) making them obstacles."
        },
        {
          "question": "What is master key signature pattern for OP_EVAL?",
          "answer": "Lock funds into: OP_TUCK <pubkey> OP_CHECKDATASIGVERIFY OP_EVAL. Unlock with: [...data] <sig> <bytecode> <redeem>. Executes script if signed by certain key. Change multisig logic, add oracle requirements, need script signed as master key. This type of system possible TODAY with VM limits activated. Can let admin approve alternative spending methods after UTXOs created."
        },
        {
          "question": "What is real benefit of OP_EVAL beyond bytecode compression?",
          "answer": "Not just 'less bytes on blockchain' - enables new category of applications: cryptography on stack and ZKPs in script which wouldn't be possible to express within VM limits without 100x to 1000x compression enabled by EVAL. These complex contracts simply would not be possible without compression."
        },
        {
          "question": "What is real use case for OP_EVAL modularity?",
          "answer": "Oracle multi-input contract sometimes needs checks, sometimes doesn't. If does need checks, require extra checks done by another input (authed by hash) - lot of overhead verifying other input checks same data as *this* input, plenty footguns. Way simpler if provide module as *this* input's push only when needed, easier to secure."
        },
        {
          "question": "What is relay vs consensus rules gap issue?",
          "answer": "Standardness rules (relay) vs consensus creates complexity. CashScript docs have 5 occurrences of 'standardness': max contract size, max tx size, max opreturn size, dust threshold, output standardness. Proposal: 'great standardness cleanup' - make relay limits consensus or remove gap. Risk-averse approach: make relay limits consensus. Case-by-case convergence needed."
        },
        {
          "question": "What is risk tolerance difference in OP_EVAL debate?",
          "answer": "Different risk analysis: one side says 'realistically, is this creating fresh pitfalls likely to cause large issues' = no, because most usage by experts or abstracted, time/experience helps develop templates. Other side: even with tooling, look at exploits/0-days in mature C++ ecosystem - why create additional risk when 80-90% achievable without it? Last 10% effectively free if ever comes to that."
        },
        {
          "question": "What is sharp knives argument for OP_EVAL?",
          "answer": "OP_EVAL doesn't let you do anything outside BCH VM instructions - just compression. Cryptocurrency can't avoid scams from growth. If bad dev, can always lose money through misconfiguration. Devs choosing OP_EVAL volunteer for risk. ETH blow-ups from Solidity bugs, not EVM itself. Can't prevent incompetent devs."
        },
        {
          "question": "What is sharp knives philosophy for OP_EVAL?",
          "answer": "OP_EVAL doesn't let you do anything outside BCH VM instructions - just about compressing bytes. Bad devs can always lose money through misconfiguration. Can't prevent that. Devs choosing OP_EVAL do so knowingly - if not confident, don't use it. Compilers/tools handle complexity, not humans hand-coding hex. All about byte compression, not new capabilities."
        },
        {
          "question": "What is static analyzability debate with OP_EVAL?",
          "answer": "Processing code to create 'complete' code requires execution or sophisticated analysis due to: loops, mutable code/data blobs (eval executes from stack), recursion, combinations. Nothing prevents VM implementation inside VM that reads blob and interprets as opcodes. OP_PUSH_EXECUTABLE doesn't prevent this - guardrails become obstacles if circumventable."
        },
        {
          "question": "What is the Merkle Header Commitment (MHC) CHIP?",
          "answer": "MHC CHIP (gitlab.com/0353F40E/mhc, bitcoincashresearch.org/t/chip-2025-03-merkle-header-commitment-for-enhanced-spv-scalability/1518) adds merkle commitments to block headers for enhanced SPV scalability. Computational cost is negligible: ~20 hashes per block, because leaves are added to a sorted list so only the right edge branch needs recomputing. Placement options discussed: last output for compact proofs vs OP_RETURN prefix for future extensibility."
        },
        {
          "question": "What is the OP_RETURN scanner and how does it work?",
          "answer": "The OP_RETURN scanner (opreturn-scanner.netlify.app, github.com/mr-zwets/opreturn-scanner) finds all occurrences of specific opreturn markers (lokad-ids) on-chain. For example, searching for 'BCMR' finds 3417 txids. The tool promotes using markers for on-chain protocol/smart contract apps as a great place to store contract details, enabling discoverability without centralized indexers."
        },
        {
          "question": "What is the difference between soft forks and hard forks from a practical perspective?",
          "answer": "The soft/hard fork distinction was arguably an excuse to create a nonexistent problem. In some situations, hard forks are far better - less headache, cleaner, and less complicated than soft forks. The key is ensuring everyone is aboard through a reasonable process like CHIPs, which can continuously improve through discussion. BCH has demonstrated that coordinated hard fork upgrades work well when properly managed."
        },
        {
          "question": "What is the op_1 UTXO sweeping attack vector?",
          "answer": "UTXOs at address prdpw30fk4ym6zl6rftfjuw806arpn26fv8cp7wyl3 can be spent with input script 0x81. If miners automatically swept these and ignored user TXs spending them, it gives anyone a way to set up double-spend: send to op_1 address then race miner's sweep against your own spend to victim."
        },
        {
          "question": "What is the purpose of bytecode compression with OP_EVAL?",
          "answer": "Compilers can use heuristics to detect repeating executable byte patterns and maximally compress Script when compiling from high-level languages. CAT/SPLIT operations on eval'd bytecode enable reusing common bytes and appending bytes to match non-optimized code. All eval-scripts are 'trusted' and hard-coded as data pushes in locking bytecode. The Subroutines CHIP focuses on IDE/NPM-like repositories for importing third-party bytecode."
        },
        {
          "question": "What is the relationship between nSequence and OP_CHECKSEQUENCEVERIFY (CSV)?",
          "answer": "Setting nSequence in a transaction input enforces relative locktime at consensus level - the input must age before the transaction can be mined. However, without additional restrictions, a spender can set any valid nSequence value up to the UTXO's age. CSV (or introspection) restricts what nSequence value can be used in the spending transaction, enforcing minimum locktime requirements. CSV essentially creates 'timelocked covenants' that existed before introspection opcodes."
        },
        {
          "question": "What is the timeline and adoption requirement for TXv5 on BCH?",
          "answer": "Jason stated TXv5 won't happen in 2027 and he won't push for it unless BCH becomes a Top 10 coin. At that ranking, BCH can justify forcing integrated services to upgrade rather than drop support. The CHIP will be ready if BCH reaches that position. If not, TXv5 can wait. Meanwhile, 2026 upgrade plans include Loops, OP_EVAL, and P2S CHIPs."
        },
        {
          "question": "What is user protection strategy for OP_EVAL contracts?",
          "answer": "Users protected same way as from dodgy code - by avoiding niche services, devs they don't trust, or projects that lost user money. Users second-order effect of devs (or third-order after compiler devs). Wallets can have default 'never trust OP_EVAL' or 'only if local compression' policies. Script devs downstream of compiler devs."
        },
        {
          "question": "What is vegabch daemon mode and what are MoriaV0 commands?",
          "answer": "Vegabch beta introduced daemon/server mode to improve performance by maintaining program state for minimal-delay command responses. MoriaV0 commands enable interaction with the Moria lending protocol: mint (create loans), repay (pay back loans), liquidate (close undercollateralized positions), and redeem (withdraw collateral). This CLI tool provides programmatic access to BCH DeFi protocols."
        },
        {
          "question": "What malleability did BCH fix vs what remains?",
          "answer": "BCA: We fixed 3rd party malleability when we implemented BIP-62 stuff in consensus. But 1st/2nd party malleability is still possible. Recipient can't do it - he'd be 3rd party without one of privkeys. XMR doesn't even have script multisig, so nothing to malleate."
        },
        {
          "question": "What prevents rigorous testing and formal verification with OP_EVAL?",
          "answer": "OP_EVAL allows code pushed in unlocking scripts to execute without being committed to in advance. This means: 1) code isn't known when money is locked, 2) the same contract call can execute different code based on runtime data, and 3) test cases can't exhaustively verify all possible code paths. Traditional opcodes have well-documented behavior with testable inputs/outputs. OP_EVAL breaks this model by allowing runtime code generation."
        },
        {
          "question": "What standard for BCH consensus changes regarding benefits vs risks?",
          "answer": "Benefits must be concrete, risks allowed to be hypothetical. Reverse NOT acceptable. This approach for BCH consensus where it's one-way street, changes only come on order of years, mistakes can be very costly. Very high value + very low risk = high bar for consensus changes."
        },
        {
          "question": "When did BCH get covenant capabilities and how have they evolved?",
          "answer": "BCH has had covenants since 2018, became easy to use in 2022. In 2023, CashTokens brought persistent state to covenants, enabling them to communicate with each other and provide compact proofs. The 2025 upgrade (BigInt/VM Limits) enables more advanced crypto in single inputs, with Lamport signatures as a starting point. Loops and optimization CHIPs in 2026 will make advanced cryptography more practical."
        },
        {
          "question": "Why is BCH not big enough for payment protocol adoption?",
          "answer": "If BCH made perfect protocol it would be ignored - just not big enough. Some big ones (MS/FB/Google/Coinbase) needed to sponsor these things before it happens. Unfortunate problem in today's world. Sad BCH not the one to design x402 protocol - would bring PR for Money for the Internet."
        },
        {
          "question": "Why is OP_CAT considered essential for Bitcoin VMs?",
          "answer": "CAT and SPLIT are super useful features in concatenative languages like BCH Script (a Forth dialect). A Bitcoin VM without OP_CAT is like Unix without cat command, or a farm with a mouse problem - tough to take seriously. These operations are fundamental to the concatenative programming paradigm that BCH Script is built on."
        },
        {
          "question": "Why is SLP on BTC risky despite relaxed OP_RETURN?",
          "answer": "Platform risk: BTC changed OP_RETURN limit before, killing token protocols. Not first time - used to be bigger. Most token use-cases impractical once TX fees over $0.10 USD. Better to stick with BCH for network effects (Paypal & Thorchain) and lower platform risk. See cashstack.info/docs/global-back-end/slp-indexer/why-slp"
        },
        {
          "question": "Why is cross-network compatibility limiting for BCH?",
          "answer": "Multicoin world exists but blockchain-agnostic = adapted to lowest common denominator of BTC forks. Limits using BCH-specific features. Being latecomer to BCH features means lagging knowledge when BCH takes off - fewer opportunities while others racing ahead."
        },
        {
          "question": "Why is risk model different for BCH VM than generic programming?",
          "answer": "Risk model of generic programming language vs BCH VM that handles trillions of ounces of gold in value are different at practical level. Like telecoms use Erlang - average developer doesn't use that, but reason specialists use different tools. Yes Javascript probably already handles trillions in value, but through custodial databases that get rolled back/edited all the time. Our risk context is different."
        },
        {
          "question": "Why is unhashed eval code fundamentally safe?",
          "answer": "It's all just sequence of bytes that unlocks UTXO. A script OP_ADD OP_EQUAL can already be unlocked with OP_0 OP_0 OP_0. Contract either is or isn't secure - can either be unlocked by unpredicted bytes in unintended manner or can't. Function eval changes nothing in that regard. Extreme hand holding would remove whole script system and only allow P2PKH."
        },
        {
          "question": "Why is zkVM verification currently impractical on BCH?",
          "answer": "Porting zkVM on-chain verification to 2025 BCH VM requires extensive workarounds. Even if implemented, every protocol interaction might cost ~10,000x typical BCH fees with extremely limited wallet support. Additionally, constraint differences encourage sub-optimal ZK constructions versus systems designed without program length concerns. This makes even non-workaround work potentially a technical dead end for production use."
        },
        {
          "question": "Why local-only OP_EVAL creates bugs and hurts scalability?",
          "answer": "Input local means define function inside transaction you're using it in. Creates bugs: 1) Used space against TX VM limits wish could have outsourced, 2) Might have made mistake copying it in, 3) Same data duplicated over and over is huge efficiency loss against blockchain as a whole, which hurts scalability. Compiler selecting code from library vs local contract compression - but local has major downsides."
        },
        {
          "question": "Why was OP_EVAL originally rejected in Bitcoin in 2011?",
          "answer": "Mike Hearn argued OP_EVAL invalidated security assurances and put Bitcoin 'back at square one' without clear benefits. However, this argument has weaknesses: Bitcoin had critical bugs after 2011 (duplicate TXIDs, DB migration, supply cap bug), yet later additions (P2SH, CHECKLOCKTIMEVERIFY, BCH upgrades) had no issues. Transaction compression saves bandwidth (not just disk), and infrastructure operators care about efficiency even if lightweight clients don't."
        }
      ]
    },
    {
      "name": "Smart Contracts & Covenants",
      "description": "Contract development, covenant patterns, introspection, CashScript, and contract architecture best practices",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can BCH Script be considered Turing complete and what does that mean for ZK implementations?",
          "answer": "If a scripting language is complete, it can express any program. BCH Script can be seen as another Forth dialect. The issue with zkVM on BCH isn't whether it's possible (theoretically it is), but practicality: incredible inefficiencies in contract code requiring workarounds for input limits. Implementation without deep ZK knowledge risks subtle errors like nonce reuse in ECDSA. Simply mirroring Solidity functions isn't enough."
        },
        {
          "question": "Generic vs specific contract discovery for BCH wallets?",
          "answer": "Generic approach (works for any contract) has privacy impacts, stores more on-chain, limited by complexity. Tom's take: won't get nice UX as long as generic. Best approach: actual products appear, contract devs work with front-end devs in specific wallets. GUI and code for one/two contracts together can find TXs easily. Some systems want to be discoverable - SORTS gives standard."
        },
        {
          "question": "How can you broadcast a raw transaction directly to a BCH node?",
          "answer": "Use Bash script with p2p protocol handshake (github.com/A60AB5450353F40E/f408a7cc0df4ee2a609dd2229e14557c). Complete the version/verack handshake, then send TX message. AI tools like Grok can help generate the bulk of the script but require some tinkering to work correctly."
        },
        {
          "question": "How can you use raw transactions with CashScript ecosystem?",
          "answer": "Can manually create contract artifact (without CashScript language/compiler) to use TransactionBuilder and mocknet environment integrated with BitAuth IDE. Cashlab (github.com/hosseinzoda/cashlab) uses straight bitauth templates and has tests. See next.cashscript.org/docs/guides/optimization#overwriting-the-artifact for overwriting artifact details."
        },
        {
          "question": "How do MEV contracts work on BCH?",
          "answer": "Hundreds of users with unspent.cash perpetuity get paid monthly - contract stipulates minimum payment but leaves small gas fee for anyone to claim. Monthly installment transactions built by anyone, not authenticated with signatures, only introspection logic. Dozens of contracts like that with hundreds of permutations. bitcoincashresearch.org/t/a-cataloge-of-miner-extractable-value-mev-on-bitcoin-cash/1616"
        },
        {
          "question": "How do NFT-controlled subscription pulls address price changes?",
          "answer": "Jonas's design: NFT controls amount corpo can pull - they need approval to raise rate by requiring new NFT issuance. Individual contract per subscription also addresses this, but bag of subscriptions is less manual."
        },
        {
          "question": "How do ZK proofs prevent miners from stealing withdrawals?",
          "answer": "The recipient address is used as input into the proof generation, effectively hardcoding the withdrawal destination. When the proof, recipient address, nullifier hash, and merkle root are sent to the contract, changing any of these makes proof verification fail. The verification process uses all these inputs together with the proof, preventing address substitution."
        },
        {
          "question": "How do anyone-can-spend subscription contracts enable MEV?",
          "answer": "Anyone with phone can make little money executing regular payments from public anyone-can-spend subscription contract. Hyper-redundant non-guaranteed method works because if one of 5B+ people with phones can make few thousand sats submitting transaction, chances are good few people might try."
        },
        {
          "question": "How do pull-based BCH subscription vaults work?",
          "answer": "User locks funds in vault and issues NFTs allowing service to pull certain amount at interval. NFT revoke is like revoking debit card, insufficient vault funds like insufficient bank balance. Analogous to current subscription flow but with cryptographic controls."
        },
        {
          "question": "How do wallets find UTXOs spendable by NFTs they own?",
          "answer": "Wallets scan for hash of script bytecode using Electrum. If you have tokenid=x with commitment=y, wallet generates standard script, hashes it, queries Electrum server to find whatever is spendable with tokens in wallet. Scan for P2SH that uses that script. Same principle as querying P2PKH and P2SH multisig for bunch of HD addresses. Wallet needs code to know fingerprint and how to generate hash from key or NFT."
        },
        {
          "question": "How do you debug P2SH script failures in BitAuth IDE?",
          "answer": "For complex scripts with evaluation errors, need to cross-check against authentication-template-v0.schema.json. Naming convention and structure leads to failure. Common issue: stack evaluating to empty instead of 1 (or non-0). Can manually create contract artifact without CashScript compiler to use TransactionBuilder."
        },
        {
          "question": "How do you handle the NULLFAIL rule with OR operators in CashScript checkSig?",
          "answer": "The NULLFAIL rule (BIP-146) makes failed checkSig fail the entire script rather than returning 0. For 'require(checkSig(userSig, seller) || checkSig(userSig, refere))', the first checkSig with wrong signature errors instead of continuing. Solution: use two signature parameters - 'function release(sig sellerSig, sig userSig)' then pass '0x' for the unused sig (e.g., '0x, userSig' when user sweeps; 'sellerSig, 0x' when seller sweeps)."
        },
        {
          "question": "How does Anyhedge contract fingerprinting work?",
          "answer": "BCA: Each anyhedge contract has different address due to specific contract parameters, but they all have same fingerprint because executable part of bytecode is same for all. If Bob knows exact contract he can look it up on electrum using script hashes."
        },
        {
          "question": "How does BitCANN's domain registration system work on BCH?",
          "answer": "BitCANN implements an Unstoppable Domains/ENS-like protocol using BCH covenants. It represents one of the most complex BCH Script systems built, using nSequence, CSV, and introspection to manage decentralized domain ownership and renewals. The system enforces registration periods through relative locktimes, allowing trustless domain management without centralized control."
        },
        {
          "question": "How does executable bit proposal enable static analyzability?",
          "answer": "Explicit executable push (and inheritance rules so can't be mutated but can be shuffled/dup'd/dropped) means script author can't hide that script is more complex than it seems. Parse script, extract all executable pushes, count number of evals - that'll tell you max complexity of contract. Authors could write exotic contracts with lots of small blobs shuffled and executed in combinations, but you'd immediately know something is sus."
        },
        {
          "question": "How does function visibility work in BCH Script contracts?",
          "answer": "BCH Script has no concept of public/private functions - all functions can be called by anyone. Unlike Solidity's access modifiers, you must explicitly lock down function capabilities within the contract logic itself. Use require statements and signature checks to restrict who can execute specific contract paths. This is a fundamental difference from account-based smart contract platforms."
        },
        {
          "question": "How does nSequence enforcement work with signatures vs covenants?",
          "answer": "Three scenarios: 1) Pre-signed transactions: the signer chooses nSequence, signature covers it, recipient can't change it. 2) Full control (P2PKH): user can set any valid nSequence (0 to UTXO age), field is enforced but value isn't fixed. 3) Partial control (covenants): script enforces minimum nSequence via CSV or introspection (require(tx.inputs[N].sequenceNumber == minWaitTime)). Consensus always enforces whatever nSequence value is present; script limits what can be set."
        },
        {
          "question": "How does state management differ between BCH Script and Solidity?",
          "answer": "BCH uses UTXO architecture instead of account-based state. There's no equivalent to Solidity's receive() function that triggers on payment. Contracts don't maintain internal state like structs. Instead, state is 'sharded' using NFTs - each state element becomes a separate UTXO. To track deposits, contracts mint NFTs with user data stored in the NFT commitment field. Listen to indexers for receiving events rather than contract-internal triggers."
        },
        {
          "question": "How does the Subroutines CHIP ensure code safety compared to OP_EVAL?",
          "answer": "Subroutines separate code from data by: 1) requiring exact code to be known when transaction is mined, 2) only executing unlocking script code after formal verification by locking script (like P2SH hashes), and 3) allowing rigorous testing with defined inputs/outputs like opcodes. OP_RUNSUB2 can call code from other inputs, but because code doesn't mix with data, you're certain it's code from the transaction you signed when locking funds."
        },
        {
          "question": "How should contract safety be evaluated in BCH Script?",
          "answer": "Low-level languages (assembly, C, BCH Script) are inherently 'dangerous' in that bugs can cause fund loss. High-level languages like CashScript provide safer abstractions. Contract risk assessment should focus on: 1) specific attack vectors rather than general 'danger' claims, 2) compiler and testing rigor, and 3) recognizing users choose to lock funds in contracts. New opcodes like OP_EVAL don't inherently make safe contracts unsafe."
        },
        {
          "question": "How should introspection opcodes handle read-only inputs to maintain backward compatibility?",
          "answer": "Current introspection opcodes should be made to fail if they try to read a read-only input. A new set of opcodes would be needed to access read-only input data. Otherwise, old contracts could be fooled by unexpected read-only inputs they weren't designed to handle. This prevents security issues with existing contracts when read-only inputs are introduced."
        },
        {
          "question": "How should untested BCH contracts be shared?",
          "answer": "Write contracts as // comment, // op_code, CashScript triples for more folks to review. Easy to correct mistakes and track reasoning on BCR. If you leave mistake in contract, you'll start seeing it copied elsewhere by people and AI. Contracts are meant to find directional bearings on paths to take."
        },
        {
          "question": "How to fund CashScript contract initially?",
          "answer": "Contract.address gives address to fund. Send to that address on correct network (chipnet vs testnet4 vs mainnet). Use Contract.address will give you the address you need to fund. Note you are on chipnet so make sure sending with chipnet funds rather than mainnet. Can call contract.getBalance() and getAddressUtxos() to check."
        },
        {
          "question": "How to get MTP-corrected current time for BCH contracts?",
          "answer": "Get 13 most current headers, decode and calculate value according to spec. MTP is not meant to relate to current time - by definition it lags behind real time for ~1hr. OP_TXLOCKTIME in contract uses nLocktime set on transaction level, checked against MTP per STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE | LOCKTIME_MEDIAN_TIME_PAST."
        },
        {
          "question": "What BCH development patterns emerge from AlbaVM release?",
          "answer": "Developer had no history, joined 3 days ago, initial drop was an hour ago. Makes you wonder how long this has been in works, when it started. Love it when people come out of nowhere to just drop cool work like this. Asked at last years BLISS if CashScript could be made to create formal validation work - this provides way to do things on much more strict way."
        },
        {
          "question": "What CashScript version fixes and network issues?",
          "answer": "Use cashscript@next (npm install cashscript@next) for updated default chipnet server and ElectrumNetworkProvider fixes. Chipnet vs testnet4 confusion: chipnet for CHIP proposals, testnet4 general purpose. Use chipnet by default for less issues. ElectrumNetworkProvider certificate expired - need @next version or custom server. Contract address is hash160/hash256 of unlocking script (P2SH20/P2SH32)."
        },
        {
          "question": "What JavaScript type coercion issues should developers watch for?",
          "answer": "In JavaScript, 'for...in' constructions make the iterator variable a string until converted, which can cause dramatic performance differences. Additionally, 'string + number' can produce unexpected results - \"1\" + 0.5 might become \"10.5\" (string concatenation) instead of 1.5. These type coercion behaviors can prevent JIT compiler optimizations and cause bugs."
        },
        {
          "question": "What are Dutch Auctions and how are they implemented on BCH?",
          "answer": "Dutch Auctions start at a high price that decreases over time until someone buys. Implementation uses timelocking with token-aware contracts (bitcoincashresearch.org/t/unspent-phi-v3-timelocking-token-aware-contracts/1501/3). For cancellation, instead of a separate cancel function (which could race with sales), the seller can trivially 'buy back' many UTXOs in succession through the UI. BIP68 512s units can be used for time restrictions."
        },
        {
          "question": "What are LLM limitations for BCH contract development?",
          "answer": "LLMs really bad at stuff not done thousands of times by others. Also bad when thousands of conflicting ways exist (e.g. Android APIs changing over time). They're language models not world models - can translate ideas to code but get lost with logical structure. Need to give good info first to anchor them, and context fades from beginning."
        },
        {
          "question": "What are P2SH scriptsig size limits after the P2S CHIP?",
          "answer": "The P2S CHIP removes the 1,650-byte input limit. The standardization limit for full P2SH scriptsig becomes 10,000 bytes. This is the effective practical limit after the change. The locking bytecode length limit of 201 bytes for standard transactions remains unchanged - the increased limits apply to unlocking scripts (scriptsig), not locking scripts (scriptPubKey)."
        },
        {
          "question": "What are common mistakes when creating CashToken transaction preimages?",
          "answer": "Common error: forgetting to update 'transaction outputs hash' to include token data in outputs. The token prefix (including PREFIX_TOKEN byte) must be included before the modified locking script. Error 'mandatory-script-verify-flag-failed (Signature must be zero for failed CHECK(MULTI)SIG operation)' often means preimage construction is wrong. The 'modified locking script length' should include both token data and lockscript when present."
        },
        {
          "question": "What are concerns with read-only inputs TXv5 design?",
          "answer": "Current assumption that transaction where any NFT is spent as input and not in output is burnt no longer holds. This might cause serious issues in some current contracts. The idea is half-cooked and design is flawed."
        },
        {
          "question": "What are concerns with untrusted code injection in contracts?",
          "answer": "Introspection fetching code in unlocking transaction means code not guaranteed to come from you. If don't know unlocking code at time of locking, very likely doing it wrong - open to code injection. Locking script visible for all can be brute forced with any unlocking script to find one that unlocks it."
        },
        {
          "question": "What are contract UTXO constraint best practices?",
          "answer": "P2PKH constraint: bill must 'see' signature for hash covering TX contents, signing key hash must match hash in program. With introspection: can codify '50% to address A, 50% to address B'. But if only constrain 50% to A, remaining 50% goes wherever TX creator decides - not constrained means allowed. See bitcoincashresearch.org/t/exploit-and-solutions-for-calculated-outputs/1423"
        },
        {
          "question": "What are problems with centralized AMM serial provider approach?",
          "answer": "Contract using introspection for different input where server adds tagging input/output and client signs their own funds, then server signs after ensuring no split. Problem: central entity could simply not sign and effectively lock up users funds. Withdrawal could still conflict with trade. Not permissionless if permission in form of signature is needed."
        },
        {
          "question": "What are subscription vault funding options?",
          "answer": "Two approaches: 1) One big bag named \"subscriptions\" for all services (semi-manual, risk of corpos pulling too much), or 2) Multiple subscription bags, one per service (basically full manual). Option 1 risks mismanaging money if you don't verify amounts each period."
        },
        {
          "question": "What are the key design considerations for OP_EXEC in BCH Script?",
          "answer": "OP_EXEC should avoid stack pollution by isolating subroutine arguments. A proposed design uses: 1) OP_EXEC1 to execute scripts in the same output by index, 2) OP_EXEC2 to execute scripts from earlier outputs in the same transaction, and 3) OP_SUB_PUSH to define subroutines with argument counts. Subroutines see only their expected arguments on stack. MAST integration allows unlocking scripts to push subroutines to a temp sub-stack that locking scripts can verify and migrate."
        },
        {
          "question": "What are the security risks of mixing code and data in BCH Script?",
          "answer": "Mixing code and data enables: 1) calling functions with identical arguments yielding different results, 2) self-modifying code (exploited in viruses/malware historically), 3) impossible-to-test code paths, and 4) bypassing formal verification. With OP_EVAL, code from unlocking scripts can execute without being verified by locking script hashes (unlike P2SH). This makes contracts 'impossible to keep free from bugs or exploits' according to critics."
        },
        {
          "question": "What are the three scenarios for nSequence enforcement in Bitcoin transactions?",
          "answer": "1) Pre-signed transactions: If given a pre-signed TX with relative locktime, the chosen timelock is enforced (signature covers nSequence). 2) Full control: Using your own P2PKH, you can pick any valid relative locktime (nSequence is enforced but value isn't fixed). 3) Covenant partial control (e.g., inheritance): Script enforces minimum nSequence field. In scenario 2 you had full control so no specific timelock was enforced; in scenario 3 the script limits what you can do."
        },
        {
          "question": "What challenges exist when regex validating file paths in JavaScript?",
          "answer": "Pattern like '^([A-Za-z]:|[A-Za-z0-9_-]+(.[A-Za-z0-9_-]+)*)((\\/[A-Za-z0-9_.-]+)+)$' may validate shorter paths but fail on longer strings. Issues often relate to catastrophic backtracking or quantifier nesting. Testing with tools like regex101.com helps, but JavaScript's RegExp implementation can behave differently than other regex engines."
        },
        {
          "question": "What development tools are available for CashScript?",
          "answer": "An official VS Code extension for CashScript was released in January 2025, replacing the old unofficial extension. It supports all latest CashScript functionality including syntax highlighting, code completion, and integration with the CashScript compiler. This provides a significant productivity boost for BCH smart contract development."
        },
        {
          "question": "What is 2nd-party multisig malleability in BCH?",
          "answer": "BCA: Either of the 2 parties in multisig could re-roll their sig to change txid and disable any descendant tx that requires parent to have exact txid. With BCH covenants child won't depend on exact txid so problem is avoided. P2PKH can only be malleated by whoever has private key."
        },
        {
          "question": "What is 8-byte script number limitation in BCH?",
          "answer": "Numeric opcodes restricted to 8-byte signed 'Script Number' integers (HF-20220515). Excludes value -9223372036854775808 that fits in 8-byte 2s complement encoding but not in 8-byte Script Number (sign-magnitude) encoding. Because we use sign bit, can't represent that 1 value that can usually be represented with 8-byte 2s complement. With '25 upgrade now can operate on that value with bigger integers."
        },
        {
          "question": "What is AlbaDSL/AlbaVM for BCH contracts?",
          "answer": "Haskell-based DSL and VM for Bitcoin Cash 2025 contract programming. Developer joined BCR 3 days ago and dropped cool work. Forked haskoin-core specifically for contracts - might be first Haskell-specific contract system. Provides way to do things in much more 'strict' way. Amazing work that came out of nowhere."
        },
        {
          "question": "What is BCH contract fingerprinting approach?",
          "answer": "gitlab.com/0353F40E/smart-contract-fingerprinting - extracts executable/data segments, generates bytecode patterns, provides confidence scoring. BCHN patterns RPC addition will populate dataElements field for contract type identification. TapSwap example: fingerprint indexed, parameters in OP_RETURN, bytecodePatternAsm from RPC, contractType field available."
        },
        {
          "question": "What is BCHN P2S contract pattern tracking?",
          "answer": "BCA: BCHN merged feature to track P2S contracts. Contract 'pattern' is obtained by stripping data pushes and replacing with number of pushes, 'fingerprint' is hash of pattern. Will find all contracts between different people using same pattern but different keys - very useful to track P2S contracts."
        },
        {
          "question": "What is BitCANN and how does it use BCH smart contracts?",
          "answer": "BitCANN (github.com/BitCANN/contracts) is an Unstoppable Domains/ENS-like protocol for decentralized domain registration on BCH. It represents one of the most complex BCH Script systems built so far, using sophisticated covenant patterns with nSequence, CSV, and introspection to manage domain ownership and renewals. The system uses relative locktimes to enforce registration periods."
        },
        {
          "question": "What is CashScript Arena learning group?",
          "answer": "Telegram group for challenging each other with 'broken' or exploitable smart contracts. Complete beginners welcome - helps with questions of getting started. First challenge only requires setting up programming environment to interact with given smart contract. Experienced people welcome to help create challenges and answer newcomer questions. t.me/CashScript_Arena"
        },
        {
          "question": "What is CashScript bitauthURI method for debugging?",
          "answer": "Create contract and use bitauthURI method of Transaction builder - gives URL to paste in browser and inspect. Use latest 0.11.0-next.3 of CashScript - has scenario generation and multi contract debugging. Use private key you don't use in production."
        },
        {
          "question": "What is DEX contract anyone-can-spend risk?",
          "answer": "BCA: DEX contracts are anyone-can-spend and sometimes contentious spends can happen by accident if multiple users try to interact with same UTXO. Need to be watchful for p2sh in dependency graph when batching user withdrawals."
        },
        {
          "question": "What is OP_DEFINE_VERIFY proposal for code injection?",
          "answer": "OP_DEFINE_VERIFY is shorthand for OP_DUP OP_HASH256 <hash> OP_EQUALVERIFY <index> OP_DEFINE. Makes transition from P2SH simple: unlocking script pushes code, locking script has code-hash and OP_DEFINE_VERIFY. Prevents brute forcing unlocking script that steals funds."
        },
        {
          "question": "What is SORTS standard for BCH contract discoverability?",
          "answer": "Simple Op Return Text Standard - parsing data for Bitcann and similar contract systems. Records include profile, social, crypto, DNS. Example: contracts.anyhedge.artifacts=<url>, contracts.anyhedge.params.0=\"parameters\". Wallet uses getRecords('alice.bch') to construct contracts and show info. Optional - user chooses to attach contracts to identity."
        },
        {
          "question": "What is Tom's verified code proposal for OP_DEFINE?",
          "answer": "Provide OP_DEFINE variant to verify function matches hash - like P2SH today only executes provided code if matches hash. Unlocking script pushes [code], locking script has: push 32-bytes-hash, push index, DEFINE_VERIFY. Hash can come from anywhere as stack item. This usecase is what P2SH does in more convoluted way."
        },
        {
          "question": "What is UTXO model explained as bills analogy for BCH?",
          "answer": "UTXO is like individual cash bill - transaction destroys bill and creates new bills, amounts must add up (difference claimed by miners as fee). Each bill has locking script - codified checklist enforcing conditions to spend. Different from EVM - code encodes constraints not actions. Most important: **anything that's not constrained is allowed** - root of footguns."
        },
        {
          "question": "What is ZCE Bag covenant specification requirement?",
          "answer": "Need to specify ZCE Bag covenant - central to design but no mention of how supposed to work. Opcode for just one contract type has very bad smell. Attention is scarce resource so not priority now."
        },
        {
          "question": "What is ZK-rollup state-root updater contract structure for BCH?",
          "answer": "Contract stores oldRoot and verifier pubkey. To spend: provide signature (proofSig) over (oldRoot || batchHash || newRoot), verify with OP_CHECKDATASIG, enforce single output preserving value, ensure next UTXO locks to new contract script via P2SH32(newScriptHash). Off-chain compiles fresh contract with newRoot."
        },
        {
          "question": "What is big footgun with BCH contract UTXOs?",
          "answer": "If not constrained, all bills for contract can be spent at once, and value for one of them can satisfy constraints of ALL of them. Example: contract says 'any bill spent by anyone but 1000 sats must go to address A' - with 10 inputs only one needs to satisfy constraint for all. Bills can be spent as single input thread or highly multi-threaded input - must be considered."
        },
        {
          "question": "What is debate on OP_DEFINE_VERIFY necessity?",
          "answer": "Tom proposes as safety valve for code injection - prevents brute forcing unlocking scripts. BCA, Jonas, Jason, Calin see no problem in the issue. Debate centers on whether bytes unlocking UTXO being executed by input's VM vs parsed as data matters. Many consider it unnecessary complexity."
        },
        {
          "question": "What is immutable code argument for OP_EVAL?",
          "answer": "Want to state as fact when sending transaction to lock money, know for fact which scripts will run to unlock. Even if stupid mistake in code, ONLY thing people mess with is data. Can't provide new code to unlock. Code is locked. This is 'trusted code' or 'immutable'. How it works today via push-only rule for unlocking scripts."
        },
        {
          "question": "What is local execution context for BCH scripts?",
          "answer": "Whole TX+prevouts already is local execution context. Eval loading from stack is just loading static data from rest of TX. Script can require other script passes in another transaction, brings proof through token. Even with eval, stacks can't interact between inputs."
        },
        {
          "question": "What is main concern with enabling powerful VM for complex contracts?",
          "answer": "Main point against: Do we want BCH script so powerful that certain contracts will blow up because they were too complex? ZK-contracts will be extremely complex, only very select few would have ability to review cryptography. If ZK-contract catches on and blows up, it won't be due to specifics of any opcode or missing security guardrail."
        },
        {
          "question": "What is the challenge with multiple inputs when receiving payments in UTXO contracts?",
          "answer": "A single transaction can have 10+ inputs from different addresses, making it ambiguous which sender to record. UTXO architecture requires thinking differently than account-based systems. Rather than a single 'sender' variable, use NFTs to create separate state UTXOs per user, or implement contract patterns like Cauldron's per-user contract addresses where each depositor gets a unique contract address containing their pubkey."
        },
        {
          "question": "What is the key difference between OP_EVAL and the Subroutines CHIP?",
          "answer": "Subroutines CHIP forces designers to introduce subroutine code in the locking script via fixed subroutine tables. OP_EVAL/OP_EXEC takes executable bytecode from the stack, allowing it to come from: the locking script, unlocking script, another input/output's script (via introspection), or constructed dynamically by code. OP_EVAL provides flexibility; subroutines provide structured safety by restricting where executable code can originate."
        },
        {
          "question": "What is use case for executing functions from other UTXOs?",
          "answer": "When scripts too large for limits. With P2S binding limit 10kb vs 1650 byte standardness limit. Is 10kb enough for ZKP functions? Could see UTXO exporting specific function. Well-known script constructions integrated into BitAuth IDE and CashScript instead of copy-pasting."
        },
        {
          "question": "When should you download full blocks instead of using Fulcrum subscriptions?",
          "answer": "For monitoring >1 million script hashes, downloading full blocks and filtering locally is more efficient than subscriptions. Subscribing to 1M addresses = 50MB network traffic + 50MB local storage just for subscriptions. If behind a full node, filtering blocks is safe and cheap. Remember which blocks you've processed to catch up after downtime. Fulcrum max_subs limit (10M) is generous DoS prevention, but downloading blocks scales better."
        },
        {
          "question": "When should you use CSV vs introspection for enforcing relative locktimes?",
          "answer": "CSV is better for simple cases like `require(tx.age >= <expression>)` as it automatically enforces TX version 2. For variable age scenarios (e.g., longer staking = more rewards), use introspection: `require(tx.version == 2); int nSeqInput = tx.inputs[3].sequenceNumber; require(nSeqInput > 0);`. This allows using nSequenceInput in other calculations while still enforcing the timelock."
        },
        {
          "question": "Where to find advanced CashScript examples for BCH?",
          "answer": "0353f40e.gitlab.io/emerald-dao/ has advanced examples. awesomebitcoin.cash/#script lists published documented scripts (libauth templates and op_code fine too). youtube.com/@bitcoincashuniversity has badgers and fundme contract tutorial vids. PurelyPeer.cash uses CashScript for cashdrops (microads) and vaults (digital coupons). cashscript.org/docs/showcase for project showcase."
        },
        {
          "question": "Why do anyone-can-spend contracts need faster confirmations?",
          "answer": "Any kind of anyone-can-use UTXO contract - multiple users could accidentally try interact with same UTXO at same time, and until block is mined they won't know which user's tx will go through. If anyone-can-spend tx has conflict, rather know in 1-9 minutes than 10-90. Can't control app logic of 3rd parties to whom BCH is just another coin, only to be hit by 20-30min waits 1 in 10 times."
        },
        {
          "question": "Why does CashScript use signed magnitude not two's complement?",
          "answer": "Emergent/Mathieu: BCH VM works natively with signed magnitude, not two's complement. Therefore any tools around script and VM will also use signed magnitude. Script numbers don't use twos complement, they use signed magnitude. CashScript must follow same since it compiles to BCH VM bytecode."
        },
        {
          "question": "Why is Flipstarter not true assurance contract?",
          "answer": "Tom: While advertised as 'assurance contract' it is not actually any contract because moment money is sent, obligation on receiver drops to zero. There literally is only one thing that can be applied: social pressure. This is opposite of a contract."
        },
        {
          "question": "Why is hash validation important for executable code?",
          "answer": "Practical difference based on cryptography. Script with just OP_EQUAL not very useful. Hashes hide actual data that unlocks it, avoid brute forcing. With code you don't validate, massively easier to find script to unlock money. Locking script that uses eval without hash validation allows experimenting until unlocked."
        },
        {
          "question": "Why is zero-conf vs faster blocks a false dichotomy?",
          "answer": "Zero-conf will always be the way forward for in-person transactions and low-value payments. However, improving UX for cases where 0-conf doesn't work (high-value, untrusted parties, or p2sh ancestor chains) is also important. Faster blocks and zero-conf are complementary, not competing solutions. More TPS (enabled by both) drives price."
        }
      ]
    },
    {
      "name": "CashTokens & NFTs",
      "description": "CashTokens implementation, NFT usage, token standards, BCMR, and token-based contract patterns",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can read-only inputs be implemented without the TXv5 transaction format?",
          "answer": "Yes. Read-only inputs could be added by including just 1 optional byte to input encoding, similar to how CashTokens were added to output encoding. This avoids requiring a full transaction format version change. However, no one is currently championing this approach separate from TXv5."
        },
        {
          "question": "How can NFT on/off switch solve AMM withdrawal conflicts?",
          "answer": "NFT can be used for withdrawal, second contract as on/off switch for LP. If LP contract requires NFT held by on/off switch contract (or <1 confirmation movement from it) for trades to occur, and withdrawal path requires NFT included with 1 confirmation, then trade transactions and withdrawal transactions should no longer have risk of conflict."
        },
        {
          "question": "How can NFTs be used to store contract state on BCH?",
          "answer": "NFTs act like mini-structs in UTXO architecture. When a user deposits into a contract, an NFT is created with the user's address and data stored in the NFT commitment field. The BCH amount is held on that same NFT UTXO. NFTs contain: satoshi amount, token category, token capability, and custom fields in the commitment (user address, flags, etc). Each NFT represents one piece of contract state, owned by the contract itself or users."
        },
        {
          "question": "How can you verify that a CashToken transaction succeeded?",
          "answer": "Check multiple sources: 1) Verify txId was returned from wallet.send(), 2) Use decodeTransaction() to inspect the raw transaction outputs, 3) Check token-aware explorers like explorer.electroncash.de or Electron Cash wallet which display tokenData in outputs. Some explorers (like melroy.org) may not show token amounts even if the transaction succeeded."
        },
        {
          "question": "How do CashTokens enable subscription payment model?",
          "answer": "BCA: Can all be done with CashTokens. Service would hold NFT which it could use to trigger pull. When you want to cancel you just burn their NFT. Could have multiple services pull from same pool of funds if they have authorization via NFTs."
        },
        {
          "question": "How do you monitor token balance changes in real-time with mainnet-js?",
          "answer": "Use wallet.watchTokenBalance() which accepts a callback that fires when balances change. Example: `const cancelWatch = wallet.watchTokenBalance(undefined, (updatedBalances) => { setTokenBalances(prevBalances => ({...prevBalances, ...updatedBalances})) });`. Get initial balances with getAllTokenBalances(). Remember to call cancelWatch() when unmounting the component to prevent memory leaks."
        },
        {
          "question": "How do you send CashTokens using mainnet-js TokenSendRequest?",
          "answer": "Use `new TokenSendRequest({ cashaddr: recipientAddress, amount: 100n, tokenId: 'your_token_id', value: 1500 })`. The `amount` is the token quantity (BigInt), `value` is the satoshi amount on that output (minimum 1000 sats for token outputs). Send via `await wallet.send([tokenRequest])`. Verify with `await Wallet.util.decodeTransaction(sendResponse.txId, true)` to see full transaction details."
        },
        {
          "question": "How does BitCANN handle domain name uniqueness without global state?",
          "answer": "BitCANN doesn't 'remember' claimed domains on-chain. Instead, the real name UTXO can terminate anyone's UTXO trying to add the same name. State management is delegated to external agents (users/services tracking existing names). The DomainOwnershipGuard uses an NFT ('ExternalAuthNFT') from the Domain contract - its mere existence proves domain ownership. Users wanting to use the incentive system penalize invalid auctions."
        },
        {
          "question": "How to use OP_DEFINE with external data from NFT commitments?",
          "answer": "Example: <0> OP_OUTPUTTOKENCOMMITMENT to get NFT commitment at Output 0, then <0> OP_DEFINE to define program from it, then <0> OP_INVOKE. Safety caveat: program has access to full stack (no stack isolation). Must ensure stack empty before invoking and returns expected items. Otherwise callback could mutate Stack items to get truthy result."
        },
        {
          "question": "How would BCMR verification work for OP_EVAL contracts?",
          "answer": "Like CashTokens where anyone can create scam tokens but BCMR verifies most used ones integrated into wallets. Same with smart contracts - BCMR of vetted bytecode locations on-chain for functions like 'quantum resistance check', 'ZKP verification'. Naive users use defaults (kiddy playground of vetted things). Audited OP_EVAL functions reach users via BCMR verified system."
        },
        {
          "question": "How would freeze/seize functionality work on BCH CashTokens?",
          "answer": "Tokens would need to be contained in smart contract rather than sent to user's wallet. Users wouldn't have exclusive ownership like with p2pkh - just privilege to transfer their part of ownership in the big contract. This privilege could be revoked with an admin key. By default, CashTokens in user's wallet cannot be seized."
        },
        {
          "question": "What BCMR API issues exist with NFT flagging?",
          "answer": "Paytaca BCMR server has 'is_nft' boolean flag that should really be changed to 'has_commitment' because that's what it means. Paytaca doesn't use this flag anymore. Can create issue at github.com/paytaca/bcmr-indexer to track change. Flag is actually object with NFT info, not just boolean."
        },
        {
          "question": "What NFTs do FundMe.cash pledgers receive?",
          "answer": "Pledging gives pledgeNFT which you keep. It records campaignID and how much BCH pledged. Can be refunded before campaign completes. Wallet tab shows pledgeNFTs for refundable pledges - could expand to show all campaigns funded and BCH amounts for tax tracking."
        },
        {
          "question": "What are current BCH BCMR registries and resources?",
          "answer": "BCMR repos: Paytaca at bcmr.paytaca.com (metadata indexer, not true token registry per BCMR spec), otr.cash, PTR at github.com/zapit-io/ptr, Flowee BCMR server (added HTML way to get BCMR details on tokens/auth-chains for human viewing, was purely JSON before). Also minisatoshi.cash/ecosystem lists all with BCMR tags."
        },
        {
          "question": "What are security footguns with NFT-owned UTXOs?",
          "answer": "NFT can't be on same input as UTXO it locks - spender specifies which input has NFT. Footgun: NFT UTXO itself needs to verify whole TX. If it doesn't (suppose NFT spent with SIGHASH_ONE), then 3rd party could just add more inputs owned by NFT and do what it wants with them. Locking script defines ownership, unlocking just satisfies predicate requesting signature or NFT."
        },
        {
          "question": "What are the Wyoming Stable Coin blockchain selection criteria?",
          "answer": "Wyoming stable token (WYST) requires 'Freeze and Seize' capabilities as a criteria. Liquid network gained qualification because AMP's APIs facilitate freeze/seize via whitelisting addresses. Blockchains without freeze/seize functionality would be disqualified. For BCH, it's technically possible to implement via covenant for a token but requires keeping tokens in smart contract rather than user's p2pkh wallet."
        },
        {
          "question": "What are the key concerns about iBCH as an additional incentive token?",
          "answer": "Main concern is circular dependency: incentive mechanism depends on DEXs existing, which rely on consensus tools, which require the token. Can't have an incentive securing the chain that's reliant on services built on the chain. Additional issues: either iBCH value is low (proposal falls apart) or has value (arguably alters 21M cap), and no other network has implemented similar scheme to observe real-world behavior."
        },
        {
          "question": "What are use cases for mutable NFT code in contracts?",
          "answer": "Vault where you can update spending paths without moving funds - new spending funds validated with tokens or pubkey/signatures. Code compression: if (program in NFT1) else (program in NFT2). Contract could keep benefactor in commitment and let current benefactor mutate state with signature to set new benefactor. Exotic but can be very useful."
        },
        {
          "question": "What evidence shows CashTokens spurring BCH project growth?",
          "answer": "CashTokens integrated into Zapit, Paytaca, Cashonize, Selene, rumored for Bitcoin.com. Projects: TapSwap, BCH Pump, Badgers, BLISS, BCH Guru FURU, AFoG token, Fiendish spaces token, Cauldron, CashTokens studio, MUSD, FundMe. Number of projects seriously rising since CashTokens added. Transaction volume not yet up but projects and infrastructure growing."
        },
        {
          "question": "What is Bitcart and what cryptocurrencies does it support?",
          "answer": "Bitcart (bitcart.ai) is an open-source, self-hosted payment processor written in Python. It supports BTC, LTC, BCH, XMR and more. BCH has been supported for 4+ years (6th birthday in March 2025). Work is ongoing for CashTokens support via Electron Cash API. It's a viable alternative to custodial payment processors for merchants wanting full control."
        },
        {
          "question": "What is BitcoinCashClient C# library for BCH integration?",
          "answer": "Nuget library to abstract away complexity from integrating BCH into C# .net application. AFoG uses it for all BCH tasks except address monitoring. Uses NBitcoin as base layer to handle bits and bytes of transaction construction. github.com/david-shattuck/BitcoinCashClient. Todo: fully remove NBitcoin dependency for total control over transaction construction for CashTokens stuff."
        },
        {
          "question": "What is Blockbook indexer and why for BCH CashTokens?",
          "answer": "Trezor's indexer for BCH - wraps node RPC, has WebSocket subscriptions. Pat's fundme.cash campaign/39 for CashTokens support aims for hardware wallet level support. Blockbook pretty much wrapping node rpc, no UTXO chain token balance support currently (only EVM, looks awkward). Fast performance."
        },
        {
          "question": "What is Thorchain CashTokens support status?",
          "answer": "Thorchain considering adding support to CashTokens but need SMEs. Tyler (9R): BCH devs interested in getting CashTokens supported by TC. BCH very important to us - only DEX that really supports BCH. thorchain.net/pool/BCH.BCH. Fees to pool depth ratio is 30% for year - very productive pool. Want to add MUSD/RUNE."
        },
        {
          "question": "What is camping lottery BCH NFT use case?",
          "answer": "Island with 6 campsites, dates May 15-Sept. Simplify lottery processing: sign up with BCH address, receive NFT with unique commitment (date + sequence), transfer NFT to camp (admission slip). Can trade NFT on marketplace in meantime. Similar to concert ticket usecase. Just assets, no smart contracts needed - send to someone else's wallet, could use poster with phone number to meet in real life."
        },
        {
          "question": "What is standard script pattern for NFT-owned UTXOs (P2NFT)?",
          "answer": "Standard script for NFT ownership: `OP_DUP OP_UTXOTOKENCATEGORY OP_SWAP OP_UTXOTOKENCOMMITMENT OP_CAT OP_HASH160 <x> OP_EQUALVERIFY` where x is hash. Compressed version: input script pushes index where NFT is placed. Wallet discovery: take what wallet has (pubkeys, NFTs) -> generate assumed UTXO locking scripts they could unlock -> query Electrum for UTXOs locked with those scripts."
        },
        {
          "question": "What is the BCH dust limit formula and what is the recommended safe amount for CashTokens?",
          "answer": "Dust limit formula is: 444 + output_size * 3. For safety after CashTokens it's best to use 1000 sats as dust amount. Electron Cash uses 800, some dapps use 1000 and others use 800. The exact calculation per UTXO is available in libauth, but using a fixed amount (800-1332) is simpler than perfect calculation."
        },
        {
          "question": "What is the computational cost for miners to add MHC commitments to coinbase?",
          "answer": "Negligible: ~20 hashes per block. Because leaves are added at the end of a sorted list, you only need to compute the right edge branch of the merkle tree. With UTXOs this wouldn't work (added/removed randomly), but for header commitments the append-only pattern makes it extremely cheap. If placed as last output, compact proofs can be created via SHA256 midstate without needing the full coinbase tx."
        },
        {
          "question": "What is the difference between token inputs showing 'tokenData: undefined' and actual token data?",
          "answer": "In mainnet-js transaction decoding, inputs from previous transactions may show 'tokenData: undefined' in the vin array even when the transaction successfully creates token outputs. The vout array is what matters for new outputs. Inputs only need enough BCH value and token authority - the tokenData in outputs determines what was actually sent."
        },
        {
          "question": "What is the original BCMR verification model vs how it's commonly used today?",
          "answer": "BCMR was designed so the payer provides the JSON to you, then you cheaply verify truth via the auth-chain (maybe 10KB total including merkle proofs). DNS-based verification via webserver files was also core to the spec. Today, most implementations use trusted indexers that provide the JSON (turning the model upside down), which works but means nobody validates ownership, IPFS is needed wallet-side, DNS-based is ignored, and a central database would work better."
        },
        {
          "question": "What is vox.cash and how does it differ from unspent.app?",
          "answer": "Vox.cash is 2025 update of unspent.app (2022) that includes integrated wallet, state and tokens - much more powerful with CashTokens. Features 10 market-making contracts including super easy Dutch Auction (26 bytes unlocking code). Each contract designed to make some kind of market in as few bytes as possible."
        },
        {
          "question": "When can you use reduced entropy for NFT category IDs?",
          "answer": "If you generate category/NFT yourself, 2^128 is fine (half of category ID via OP_SPLIT). If you're given NFT, not fine - someone could have rolled colliding pair - you'd want 2^256 there. Reduced entropy donation address: `<0> OP_UTXOTOKENCATEGORY <16> OP_SPLIT OP_DROP <half_of_NFT_categoryID> OP_EQUAL` - total input size 64 bytes, sweep 1000s of UTXOs with just 1 signature."
        },
        {
          "question": "Why do many developers and communities hate 'crypto'?",
          "answer": "The crypto space is overwhelmed by scams - furries, musicians, artists, and gamers all hate 'crypto' due to perception damage. Those trying to fulfill Bitcoin's original purpose are drowned out 1000:1 by scam tokens. The damage to crypto's perception is probably much higher than people imagine. Recruiting good C++ devs to the space is nearly impossible - asking means you're considered 'dirty'. This makes developer recruitment extremely challenging."
        },
        {
          "question": "Why do some developers avoid BCH-specific features like CashTokens?",
          "answer": "Blockchain-agnostic approach allows exit if BCH fails to be best chain. Multiple OP_RETURN and CashTokens not compatible with BCH forks (eCash, Nexa). Two main reasons to stay: network effects (Paypal, Thorchain availability) and backward compatibility maintained in recent years without breaking changes."
        },
        {
          "question": "Why do wallets use BCMR indexers instead of the original verification model?",
          "answer": "For NFTs with thousands of images, BCMR files become megabytes in size and lack core features (requiring extensions). Airdrops and DEXes don't have payment protocols to support the original model. Trusted indexers solve this by providing JSON, but it's essentially standardized data storage on someone else's computer. The tradeoff: easier implementation but centralization and loss of the trustless verification design."
        },
        {
          "question": "Why does Cashonize show 0 tokens sent when sending tokens to yourself?",
          "answer": "This is not a bug - wallet history displays the net balance change. When you send tokens from your address back to your address, the balance doesn't change (0 net change). Contract interactions require this calculation method. Use block explorers like explorer.electroncash.de or Electron Cash to see the actual token outputs and amounts in the transaction."
        },
        {
          "question": "Why don't developers calculate exact dust limits per CashToken UTXO?",
          "answer": "It's not clear how to divide up funds in a wallet (do CashToken UTXO sats count to your cash balance?). Managing UTXOs with large amounts or multiple token types is complex. Also, the amounts are too small to bother optimizing at this stage. Eventually someone will make a library/method and everyone will use that."
        },
        {
          "question": "Why is wrapped asset integration important for BCH DeFi?",
          "answer": "Need WBTC, WETH and standard derivatives for DeFi. Real killer likely stablecoin (MUSD or possibly Tether return). If BCH had wrapped CashToken versions of other UTXO projects, those ecosystems could get fast low-fee DeFi on BCH. FBCH currently largest TLV CashToken project."
        },
        {
          "question": "Why was CashToken signing serialization designed to prevent old software from creating token transactions?",
          "answer": "For transaction encoding, token data precedes the locking script. But for signature preimage, token stuff is intentionally moved 'outside' (before the script length). This design ensures unupgraded software can't generate valid token signatures and accidentally burn tokens. Old software lacking token awareness will create invalid signatures, preventing catastrophic token loss."
        }
      ]
    },
    {
      "name": "Development Libraries & Tools",
      "description": "Software libraries, SDKs, development tools, and frameworks including libauth, mainnet-js, and language-specific tooling",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How do you set up mainnet-js with React and Next.js?",
          "answer": "Mainnet-js provides a React/Next.js demo with proper configuration at github.com/mainnet-cash/mainnet-js/tree/master/demo/react-next. The key is configuring next.config.mjs correctly to handle polyfills for Node.js modules that don't exist in browser environments. Clone the demo repository and examine the configuration rather than starting from scratch to avoid common polyfill errors."
        },
        {
          "question": "How does NPM supply chain attack work?",
          "answer": "Farooq: For many packages on npm, the domains used for Email has expired. Someone else can register domain, launch mail server, then use reset password mechanism to get control of packages. Major supply chain attack vector."
        },
        {
          "question": "How does Telegram mute functionality work for community management?",
          "answer": "Telegram doesn't have per-user mute like Nostr. If could globally mute people adding noise, would be decentralized version of banning - quickly muted by anyone adding signal, unpopular to reply giving fuel, faster with mute-replies feature. Without this tool, needs willingness to not be everyone's best friend."
        },
        {
          "question": "How does vox wallet modularize DeFi protocols?",
          "answer": "Each vox module is just libauth template and page of helper functions to build transactions. Libauth doing all heavy lifting constructing/validating transactions (no cashscript sdk). When libauth library available elsewhere easier to port modules to Flowee or EC. Drip was BCA's idea, WBCH was Dagur's, BlockPoints based on Badgers."
        },
        {
          "question": "What BCH development library recommendations for different needs?",
          "answer": "mainnet-js: automatic UTXO selection, change outputs, simple sends. libauth + cashscript combo: preferred by Jerry for SDK. libauth alone: nice if don't need wallet or electrumX. mainnet-js has bloat and workarounds with webpack/bundlers per some. npm concept doesn't make sense to Tom. Python: wait for cashscript-py. Rust: rust-bitcoincash supports CashTokens. 2qx working on libauth examples."
        },
        {
          "question": "What Node.js version should be used with mainnet-js and Next.js?",
          "answer": "The mainnet-js React/Next.js demo works with Node 22.13.0. Use yarn as the package manager (the repo includes yarn.lock). While npm can work, mixing package managers causes lock file inconsistencies. The repo's next.config.mjs handles polyfills for browser environments, eliminating manual webpack configuration."
        },
        {
          "question": "What Rust libraries available for BCH development?",
          "answer": "gitlab.com/rust-bitcoincash/rust-bitcoincash/ - supports CashTokens. Rust forces write out every return type and possible state - library usually done or not done. Very common to see well written rust libraries go for years without release - they're not unmaintained, they're just done. 'electrum-client-netagnostic' crate for electrum API access. libauth-rs replacement for libauth.org would be cool."
        },
        {
          "question": "What Rust tooling exists for BCH development?",
          "answer": "Riften Labs (gitlab.com/riftenlabs) has Rust BCH tooling including a Rust indexer. rust-bitcoincash (gitlab.com/rust-bitcoincash/rust-bitcoincash) provides core Bitcoin Cash libraries. Libauth also has Rust components (compiled to WASM for hashing functions at github.com/bitauth/libauth/tree/master/wasm/hashes). Java and C++ are the most mature compiled languages for BCH, with Go standalone libraries also available."
        },
        {
          "question": "What are Vox apps built with?",
          "answer": "2qx: Every vox app is libauth template, builder function and UI page. There are 4 examples now but will be like 12 soon. Mainnet and Selene also do this. Short general audience READMEs in each app, more technical breakdowns in libauth templates."
        },
        {
          "question": "What are mainnet-js and CashScript SDK compatibility options?",
          "answer": "Kallisti: Short answer is yes. Long answer - you'll probably need to write some of your own glue code to make two libraries talk to each other. 2qx: There are three type formats for unspent outputs - each library has its own format and common format (electrum-cash) underneath."
        },
        {
          "question": "What are vegabch MoriaV1 BCH libraries release?",
          "answer": "npm packages: vegabch@0.2.0 @cashlab/common@1.0.4 @cashlab/moria@1.1.1. MoriaV1 now available in vegabch. Docs for devs: github.com/hosseinzoda/cashlab#documentation. vegabch cli readme for power users: github.com/hosseinzoda/vegabch."
        },
        {
          "question": "What frontend libraries recommended for BCH development?",
          "answer": "Libauth for working with BCH frontends - has validation for CashAddr function for typescript/javascript. mainnet-js if find libauth tricky to work with. Use tsx instead of ts-node for ESM - tsx 'just works' vs ts-node has many ESM problems. Latest LibAuth might require Node >= V22. V23 might have non-ESM with ESM mixing support but can't use top-level await which LibAuth needs for libsecp256 WASM initialization."
        },
        {
          "question": "What is NPM domain expiration password reset vulnerability?",
          "answer": "Farooq: For many packages on npm, the domains used for Email has expired. Someone else can register domain, launch mail server, then use reset password mechanism to get control of packages. This is major supply chain attack vector."
        },
        {
          "question": "What is benefit of OP_EVAL pulling functions from old transactions?",
          "answer": "Titanic efficiency and bug-reduction gain. People write needed thing once, everyone refers to it. Otherwise copy-pasting everywhere which is bug risk itself. Widely used functions get audited once, patched version released if bugs found (like npm packages). MORE bugs if everyone rewrites own or copy-pastes."
        },
        {
          "question": "What is community ownership problem with BCH documentation?",
          "answer": "Mathieu/emergent: Maintaining high quality docs is lot of work and for no personal benefit. At least code has personal benefits like github stars, npm downloads, showcase. Each copy owned by repo owner - if owner isn't committed to updates, no reasonable expectation for them to happen."
        },
        {
          "question": "What is mainnet.cash 2.7.0 update?",
          "answer": "Big update tackling many recent issues and modernizing the lib. github.com/mainnet-cash/mainnet-js/releases/tag/2.7.0. These changes will have positive impact on Cashonize and other integrations."
        },
        {
          "question": "What mainnet-js improvements for bundle size and features?",
          "answer": "Bundle size 737 kB -> 270 kB (gzip) - got lot slimmer by externalizing SBCH functionality and storage providers. Great for automatic UTXO selection and automatic change outputs - easiest solution in TS/JS for simple BCH/token sends. Example apps using different frameworks in github.com/mainnet-cash/mainnet-js/tree/master/demo. Fee handling abstracted away as feature."
        },
        {
          "question": "When should you use mainnet-js versus libauth for BCH dapp development?",
          "answer": "Mainnet-js is a high-level library best for most use cases - it's easier and internally powered by libauth. Use it if the functionality covers your needs. Libauth is low-level and provides more advanced control when you need fine-grained transaction construction or operations mainnet-js doesn't expose. Mainnet-js also allows extending the base wallet class for application-specific functionality."
        },
        {
          "question": "Why does Next.js show topLevelAwait warnings when using mainnet-js with libauth?",
          "answer": "Webpack generates warnings about async/await and topLevelAwait when Next.js doesn't fully understand the build configuration. These are usually safe to ignore if the mainnet-js demo's next.config.mjs is used correctly - the warnings don't prevent the code from working. Verify functionality by checking if wallet addresses generate correctly rather than focusing on build warnings."
        },
        {
          "question": "What are effective AI prompting strategies for deep analysis?",
          "answer": "Using deep think mode then deep search asking 'are you really sure?', then ignoring answer and presenting problem gives AI really good understanding. Second answer can be worse (overcomplicated) - by third reiteration things get out of whack. Best method: establish base with first question then provide complex details in second turn."
        },
        {
          "question": "What is Trezor Blockbook BCH naming and cosmetics approach?",
          "answer": "Implemented throughout Trezor code including coin name as 'bcash'. Attempt to change would only aggravate them. Not a hill worth dying on. Pat could apply cosmetics on top of contributed code for own deployments but would not push to upstream. Blockbook is maintained, well taken care of with no critical fixes - should be in healthier state now than 2020."
        }
      ]
    },
    {
      "name": "Wallets & User Experience",
      "description": "Wallet development, user interfaces, WalletConnect, payment UX, and end-user application integration",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How can BCH work without internet using merkle proofs?",
          "answer": "Wallets pass around merkle proofs to verify TX inputs are valid. Can't verify double spends without miners, but acceptable for small payments. TX chains get longer with no unconfirmed TX verifiability. Need regular chain sync to verify TXs actually valid. However, IMO lot of work for dwindling use-case - better solution is higher connection reliability."
        },
        {
          "question": "How do SPV wallets verify without being lied to?",
          "answer": "Tom: Any SPV wallet that wants to verify proofs needs headers - if they don't do that they're not verifying they're not being lied to. Electron Cash uses search indexers and does checks thus needs headers. Can query electrum server for checkpoint at any height N which will be root of all headers from 0 to N-1."
        },
        {
          "question": "How do you troubleshoot WalletConnect2 connection issues with BCH dapps like tapswap?",
          "answer": "If WalletConnect2 shows a persistent connection without wallet selection options, first try ending all sessions in the dapp's settings. If the disconnect button doesn't work, manually remove all localStorage items mentioning 'wc2' in your browser's developer tools. Clearing site-specific cache and data can also resolve stuck sessions between the dapp and wallet."
        },
        {
          "question": "How does BCH wallet with Nostr integration work?",
          "answer": "Web wallet generates 12-word mnemonic for user on first login. Auto-generate private key and BCH address at index 0 on 245 derivation path (standard for SLP-token aware wallets). From that private key can generate nsec and npub for Nostr account. In future, allow import of nsec from elsewhere to generate BCH address and hydrate web wallet."
        },
        {
          "question": "How does BitPay handle JSON Payment Protocol vs BIP70?",
          "answer": "Tom: While it does JSON-PP, it ALSO does protocol buffers PP. What your wallet handles depends on what your wallet asks BitPay to provide. Jim: They got Electron Cash to implement JPPv2 specifically for their service and UI uses Select Wallet dropdown now before you pay."
        },
        {
          "question": "How does SPV merkle block sync work?",
          "answer": "Tom: Wallet needs to ask any full node all merkle blocks once. If started 24 hours ago need to send 144 requests (some 40 bytes each). If ran 6 hours ago only ask 36 blocks. Benefit of merkle is network activity stable regardless size of wallet - doesn't matter if you used million addresses."
        },
        {
          "question": "How does StableHedge compare to Tether in terms of design goals?",
          "answer": "StableHedge is not designed as a Tether competitor for massive holdings. The bonus of not having millions in one entity is avoiding disproportionate threats against people (like $5 wrench attacks against team members or loved ones). No multisig helps against physical coercion. It's better to treat Paytaca team as precious people who shouldn't become big targets by holding excessive funds."
        },
        {
          "question": "How should wallet template verification work?",
          "answer": "Tom: Normal users won't be able to tell if template is going to rug them. Best approach is wallet will trust templates approved and verified by company and refuse to use any other templates. You move trust to wallet makers who have reputation."
        },
        {
          "question": "What Go libraries are available for BCH wallet development?",
          "answer": "For Go wallet development, bchwallet (github.com/gcash/bchwallet) provides the core wallet functionality. The BCHD project also includes wallet libs/utils and GRPC API. Neutrino wallet was implemented in Go with full functionality. Backends options include Fulcrum (Electrum protocol), BCHD GRPC, Chaingraph, or the BCHC indexer - all accessible from Go code."
        },
        {
          "question": "What are different wallet template security policies?",
          "answer": "Jonathan: High-security focused wallets will refuse to let users add new templates they haven't audited and signed for. High-versatility wallets let you add any template with nothing but stern warning between you and imminent loss of funds. Most wallets fall in between."
        },
        {
          "question": "What browser compatibility issues exist with WalletConnect2 on BCH?",
          "answer": "Brave browser has known issues with WalletConnect. If WalletConnect2 shows a persistent connection without wallet selection, remove all localStorage items mentioning 'wc2' via browser developer tools. Safari and Firefox have better compatibility. Edge lacks per-site cache clearing which complicates debugging connection issues."
        },
        {
          "question": "What is CashConnect vs WalletConnect for BCH?",
          "answer": "CashConnect used by BCH Guru, only implemented in one wallet. Supposed to solve for HD wallets. WalletConnect has relay servers to integrate apps and wallets. CashConnect promising but couldn't find much information or reference implementation anywhere."
        },
        {
          "question": "What is CashRPC protocol for BCH wallet-app communication?",
          "answer": "BCH Guru docs link to bitcoincashresearch.org/t/cashrpc-protocol-to-attempt-to-unify-wallet-app-comms/1201 but definitely early. CashConnect also uses WalletConnect currently as transport layer. Ideas to move to libp2p but big gap between end goal vs currently realistic."
        },
        {
          "question": "What is Flowee Pay module system for DApps?",
          "answer": "Flowee Pay mobile has modules that can be developed mostly separate from app. Gives developer power to make custom interface for specific purpose as screen in wallet. Full access to wallet and transaction builder. Great UI/UX pretty easy with Qt/QML tech. Plugin concept like Satoshi's core features."
        },
        {
          "question": "What is LibP2P for BCH wallet communication?",
          "answer": "BCA: LibP2P allows WalletConnect-like functionality - run web-accessible Fulcrum/backends from home, encrypts everything. If both app & wallet have same IP they could establish direct connection instead of sending data to centralized server only for it to come back to same machine."
        },
        {
          "question": "What is Nostr coordination layer for BCH wallets?",
          "answer": "Kallisti: Nostr as coordination layer for wallets is something very interesting to explore. Could implement wallet-app communication inside BCH client. Maybe Alice needs to tell Bob how many tokens to transfer without using centralized service like email or telegram."
        },
        {
          "question": "What is Paytaca's StableHedge stablecoin solution?",
          "answer": "StableHedge (bitcoincashresearch.org/t/stablehedge/1504) uses a centralized peg mechanism but with fully transparent treasury and permissionless minting/redemption. Treasury backing is 50% in BCH (from which anyone can 'pull' by calling the redeem function) and 50% in 2x AnyHedge shorts. Users trust Paytaca to maintain treasury correctly, but unlike centralized entities, they can't lie about the state - if they rug or lose backing, everyone will see on-chain."
        },
        {
          "question": "What is WalletConnect 2.0 complexity assessment?",
          "answer": "Shadow reviewed specs.walletconnect.com/2.0 - there are 5 types of different servers with damn high complexity! Zero chance this can be easily replicated with any generic open source replacement. Any replacement will require lot of work whether generic relay tech exists or not."
        },
        {
          "question": "What is cashaddress.org paper wallet feature request?",
          "answer": "Request for 6 paper wallets per page with about 0.11 inch margin. Would make it easier to cut and save paper. Currently generates single wallet per page."
        },
        {
          "question": "What is seedless wallet approach for BCH onboarding?",
          "answer": "Designated trusted party helps with recovery - requested quite often. May be good for heavy onboarding as stepping stone for people not comfortable with 100% self custody. Example: sideshift.ai uses random unique string (username) + another string (password) to deterministically determine deposit addresses so account can be rebuilt."
        },
        {
          "question": "What is status of WalletConnect BCH integration?",
          "answer": "Integration in limbo (github.com/WalletConnect/walletconnect-monorepo/issues/5672). Submitted but didn't know proper format. Registering chain with Explorer doesn't impact/improve wallet and dapp support ability - simply way for users to discover wallets and dapps supporting chain. Fuzzy on how integration actually works."
        },
        {
          "question": "What is template system approach for BCH dApp security?",
          "answer": "Jonathan: move complexity out from dapps into templating system. If wallet adds generalized templating system powerful enough to understand on-chain actions, dapps no longer need signatures. They ask what you want to do, you verify locally it matches, then you do it yourself. Moves trust from apps to templates."
        },
        {
          "question": "What is the WalletConnect official integration status for Bitcoin Cash?",
          "answer": "BCH was officially added to WalletConnect/Reown documentation (github.com/WalletConnect/walletconnect-monorepo/issues/5672). The correct CAIP-2 chainIDs are: 'bch:bitcoincash' for mainnet, 'bch:bchtest' for testnet, 'bch:bchreg' for regtest. This is defined in Pat's WalletConnect spec and differs from BIP122-based identifiers used for BTC."
        },
        {
          "question": "What paper wallet generators are available for BCH?",
          "answer": "Chris Troutner's latest paper wallet apps are at opensourcemetalwallet.com. The wallet.fullstack.cash can sweep BCH and SLP tokens from these paper wallets. For custom designs, generate an image and use HTML to float generated QR codes over the image. CashStamps also has best support for paper wallets with two QR codes: one to the stamps site (redirecting to app stores), another with bch-wif for claiming."
        },
        {
          "question": "What security warnings should paper wallets include to protect private keys?",
          "answer": "Paper wallets should warn users not to expose private keys to cameras, videos, or other people. The warning text should be comprehensive: 'Do not let any camera, video or person see this' rather than just 'no photos'. This protects against Google Glass, smartphones, and other recording devices. Users often don't realize that taking photos/videos stores data elsewhere with high probability of eventual third-party access."
        },
        {
          "question": "Why build separate BCH wallets instead of collaborating?",
          "answer": "Tom: biggest problem is not tech but trust and opportunity. People don't build on existing wallets, they start their own and after 2 years maybe release something years behind. Realized it's case of wanting control and maybe being unable to work together. If integrated they'd instantly gain users and profit from fees."
        },
        {
          "question": "Why do cold wallets with carved seeds have security risk?",
          "answer": "Jonathan: This kind of cold wallet moves all complexity for signing to user who commonly makes mistakes. Great for power users who are careful, bad for any user that is not. Even well-educated power users sometimes not careful when drunk, high, or under stress."
        },
        {
          "question": "Why hasn't Satoshi's SPV been more widely implemented in wallets?",
          "answer": "Implementing full cryptographically secure SPV (with all hash verification from the whitepaper) is a lot of work and not strictly necessary so far. Most light wallets check on a server, which is easier. Users have never requested \"totally cryptographically secure SPV\" - they prioritize other features. It's a global-scale \"nice to have\" rather than an essential feature for everyday end users given the massive wallet development backlog."
        },
        {
          "question": "Why use browser wallet plugin instead of WalletConnect?",
          "answer": "Tom argues WalletConnect super overkill - just want wallet in browser plugin or browser that ships with wallet. Web browser needs to add support for code 402 which is what we want. Don't want web protocols to make browser on phone talk to wallet on same phone."
        }
      ]
    },
    {
      "name": "Infrastructure & Nodes",
      "description": "Node implementations, indexers, network infrastructure, SPV, Fulcrum, Chaingraph, and backend services",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Do current BCH wallets implement SPV exactly as specified in the whitepaper?",
          "answer": "Both Electron Cash and Flowee Pay fulfill the description given in section 8 of the whitepaper regarding SPV (Simplified Payment Verification). They verify merkle proofs against headers as specified. The confusion often stems from whitepaper pruning - no node implements the pruning scheme from the whitepaper, but clients do implement SPV merkle proof verification against headers."
        },
        {
          "question": "How can Fulcrum and nginx be configured to prevent bandwidth abuse?",
          "answer": "Fulcrum has built-in rate limiting features that should be enabled. Nginx supports rate limiting via the `limit_rate` directive (e.g., `limit_rate 100k;` to limit connections to 100KB/s). For P2P bandwidth monitoring, create a cron job that checks BCHN RPC every 15 minutes to ban nodes consuming excessive data. OS-level tools typically don't track specific remote connections well."
        },
        {
          "question": "How does Chaingraph handle double spends vs Electrum?",
          "answer": "Richard/Jonathan: Electrum provides consistent view (changes mind between consistent views). Chaingraph will remember and serve double spends - if you want consistent view of chain need to write queries carefully to exclude double spends. Electrum won't give two UTXOs from conflicting transactions."
        },
        {
          "question": "How to fix LibAuth ESM compatibility issues with ts-node?",
          "answer": "LibAuth v3.0.0 has ESM compatibility issues with ts-node. Solutions: 1) Modify tsconfig.json settings, 2) Use tsx instead of ts-node - tsx 'just works' for ESM while ts-node has many problems, 3) Use Node V22 or higher (LibAuth requires >= V22), 4) Consider Deno or Bun as Node getting old architecturally. tsx is wrapper around NodeJS that runs TypeScript."
        },
        {
          "question": "What are Bloom filters and do they grow over time?",
          "answer": "Bloom filters (CBloomFilter in BCHN) are fixed-size data structures. At construction, a fixed-length bytearray is created. Inserting items toggles individual bits but doesn't change the size. They never grow - this is fundamental to how Bloom filters work as probabilistic set membership structures."
        },
        {
          "question": "What are realistic latency numbers for cross-continental block propagation?",
          "answer": "Tokyo-Paris ping shows ~593ms round-trip (300ms one-way for header delivery). However, most mining nodes have <100ms latency (US-China). Header is only ~100 bytes so bandwidth isn't relevant. Decentralization helps: miner only needs to reach 1-2 nodes quickly, those then forward the header, eliminating edge cases."
        },
        {
          "question": "What backend infrastructure should Go developers use for BCH applications?",
          "answer": "If using Go, BCHD is likely much easier to use as a backend than Fulcrum. While Fulcrum is great for Electrum protocol support, BCHD provides native Go libraries and APIs designed for Go development. The Knuth node had Go-specific features but has been obsoleted. BCHD represents the best-maintained Go-friendly BCH node implementation."
        },
        {
          "question": "What hardware and software optimizations enable fast BCH full node synchronization?",
          "answer": "BCHN can sync from 0-100% in 2-4 hours with: NVMe SSD storage, moderately fast CPU (Intel Xeon or equivalent), and fiber/1Gbit network connection. Bitcoin Verde offers a fast sync mode that can further speed up initial blockchain download. If syncing takes 24+ hours (like 24hrs for 50%), hardware bottlenecks or network issues are likely the cause."
        },
        {
          "question": "What infrastructure does chipnet.imaginary.cash run and what bandwidth challenges does it face?",
          "answer": "Chipnet runs BCHN (full node), Fulcrum (electrum indexer), and nginx (web server) exposed to the public. With a 3TB/month bandwidth allocation, normal chipnet usage is under 10GB/month. Bandwidth hogs can exhaust the monthly limit in days, requiring sophisticated OS or application-level rate limiting and IP tracking to prevent abuse."
        },
        {
          "question": "What is Electrum protocol header sync process?",
          "answer": "Tom/Kallisti/Bastian: Getting headers quite cheap and one-time thing. On p2p network any full node answers request with up to 2000 headers per request. Fulcrum has blockchain.block.headers method returning all headers between start_height and start_height+count. Header sync basically instantaneous."
        },
        {
          "question": "What is Infrastructure Blocks iBCH tail emission proposal?",
          "answer": "Possible solution to diminishing block reward problem is to use iBCH block reward when/if Infrastructure Blocks get implemented. They can have small tail emission, unlike BCH. Could be used for gigahashcoin pricing instead of BCH block reward which goes to zero."
        },
        {
          "question": "What is Python Telegram bot BCH payment integration stack?",
          "answer": "Use pybitcash (bitcash.dev well maintained by reputable person) to import/generate keys and create payment addresses with required amount. Run Fulcrum as SPV server connected to external full node. Scan mempool using blockchain.address.get_mempool for fast 0-conf detection. Fulcrum best in class indexer. Long-term: libauth may have rust implementation with python bindings."
        },
        {
          "question": "What is Schnorr signature size issue on BCH tempnet?",
          "answer": "Jonathan/Bastian: Signature is only 64 bytes but should be 65 bytes I think. Node keeps thinking it's ECDSA and rejects with 'Non-canonical DER signature' error. Working with signatures and hashes is always fun - any error turns into entirely invalid result."
        },
        {
          "question": "What is debate about increasing BCH OP_RETURN limits?",
          "answer": "Current 220 byte limit considered perfect by some. Proposed compromise for higher limits: increasing cost per byte above current limit to disincentivize but not prevent. Concern: higher limits cause chain growth with data, makes running full node harder, could crowd out money use case. Data bloat forces drastic infrastructure changes to scale (similar to EVM node challenges)."
        },
        {
          "question": "What is double-spend network topology research technique?",
          "answer": "2025 replication of 2015 CoinScope paper - send conflicting TXs to different nodes, see which gets mined, identifies influential nodes. Found 200 nodes close to 50% hashrate. mempool.space partitioned 91% of time. Uses first-seen policy: nodes respect first-seen, conflicts rejected by those who got alternative first. DSProofs would detect method for P2PKH but not P2SH. Differential measurement technique."
        },
        {
          "question": "What is the E2EE messaging web app for BCH?",
          "answer": "Message.psfoundation.info - web app that lets you send and receive E2EE encrypted messages to any BCH address. Uses Bitcoin Cash for addressing and encryption infrastructure."
        },
        {
          "question": "What is the recommended approach for implementing BCMR on-chain authchain resolution?",
          "answer": "Basing lookups on Fulcrum is super slow and creates excessive server burden. Nothing beats dedicated indexers: Chaingraph, Paytaca indexer (github.com/paytaca/bcmr-indexer), or Cauldron's rust indexer (indexer.cauldron.quest/bcmr). If using Rostrum electrum server, blockchain.utxo.get can help. Mainnet-js also has built-in BCMR support. Avoid implementing from scratch with Fulcrum."
        },
        {
          "question": "What is whitepaper pruning and why isn't it implemented?",
          "answer": "Whitepaper pruning would allow pruned nodes to serve historyless SPV wallets - keeping all transactions with UTXOs and creating SPV proofs for those transactions, while discarding spent transaction history. No node currently implements this. However, clients do implement SPV merkle proof verification against headers, which is the key security feature for light wallets."
        },
        {
          "question": "Which chipnet explorers and infrastructure are currently operational?",
          "answer": "Chipnet infrastructure status varies. loping.net (cbch.loping.net) runs its own servers and shows contract addresses correctly. bch.ninja and chaingraph.cash also run independent servers. Some explorers depended on im_uname's Fulcrum server which went down due to bandwidth abuse (3TB/month exceeded). Jason's chaingraph explorer likely has its own infrastructure since he mines chipnet blocks."
        },
        {
          "question": "Why use merkle blocks instead of indexer layers for wallets?",
          "answer": "Full nodes with merkle blocks already solve wallet sync in extremely cheap and scalable way. Problem: most wallets don't use this, instead use new layers which create new problems. Merkle blocks provide best user experience - so much more consistently fast and private updating when opening wallet. Rethinking SPV proposal moves cost from indexers to nodes, centralizing responsibility. Adding more layers possible but not optimal."
        }
      ]
    },
    {
      "name": "Payment Systems & Subscriptions",
      "description": "Payment protocols, recurring payments, subscription models, invoicing, and payment processing solutions",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Are payment channels used on BCH?",
          "answer": "Emergent/Chris/Tom: Payment channels possible on BCH since 2009. Nobody actively using standard libraries though. There is at least one party making thousands of payment channels on BCH regularly but they aren't using standard libraries. Double-spend proof feature is perfect for this use-case."
        },
        {
          "question": "How do BCH subscription payments with xpub work?",
          "answer": "Future idea: repeat payment request includes xpub instead of single address - allowing privacy friendly flow. Example: I have patreon, you're my customer. I sent you payment request. Instead of Bitcoin address I sent you xpub. You pay me every month from next address on that xpub. Without xpub you'd have to send something every month making man in middle needed."
        },
        {
          "question": "How do Mecenas-style recurring payment contracts work on BCH?",
          "answer": "Recurring payment contracts allow pre-funding a specific amount upfront - no further user actions needed. The recipient, another user, or a server can spend the pre-set amount at pre-set intervals by 'pulling' from the contract. This exists as an Electron Cash plugin (github.com/KarolTrzeszczkowski/Mecenas-recurring-payment-EC-plugin) but a WalletConnect version would enable Zapit, Paytaca, and Cashonize users to easily use it."
        },
        {
          "question": "How does x402 compare to payment channels for web browsing?",
          "answer": "When browsing website you'd pay once per page with x402. Single transaction for all pages would make more sense - Bitcoin related chains could open payment channel. Criticism: paying per page vs payment channel for whole session efficiency."
        },
        {
          "question": "How does x402 enable web payments ecosystem?",
          "answer": "Main way forward is more browser support for crypto. Ecosystem non-existent - if webserver returns 402 today browser says illegal state. Need something that works so ecosystem can start building. Wonderful to see progress for payments in webbrowsers."
        },
        {
          "question": "How does x402 protocol architecture work?",
          "answer": "Chris: Three entities - Server, Client, Facilitator. Facilitator is middleware server handling payment and settlement. Server can be normal API without blockchain-specific code. To adapt to BCH, Facilitator would have HD wallet, assign address to each user, accept batch payment and debit against it."
        },
        {
          "question": "What is ARCC and how does it relate to recurring payments?",
          "answer": "ARCC (github.com/kiok46/arcc) is an advanced recurring contract structure, more sophisticated than basic Mecenas-style contracts. Zapit was considering integrating it into their services. It would be a perfect integration for the BitCANN platform and represents more advanced smart contract patterns for recurring payments on BCH."
        },
        {
          "question": "What is Coinbase x402 protocol for crypto payments?",
          "answer": "Chain-agnostic protocol using HTTP 402 code for browser-based crypto payments. Simple scheme can build BCH economy around it. Prime example of cryptocurrency as money of the internet. Could replace dumb paywalls on websites and only be done with crypto."
        },
        {
          "question": "What is Flowee Pay serverless recurring payments approach?",
          "answer": "User doesn't manually resubmit each month. Wallet handles serverless repeated payments with auto-renewal by default unless user specifies not to renew for next period. One payment per period. Combines tech from xpub BIP47 payment codes with privacy-friendly recurring payment protocol."
        },
        {
          "question": "What is Paytaca Payment Hub and what features does it offer?",
          "answer": "Paytaca Payment Hub is a beta solution enabling online merchants to accept Bitcoin Cash payments directly without intermediaries (payment-hub.paytaca.com). Early adopters can use both manual and programmatic invoice creation. WooCommerce and other e-commerce platform plugins are currently in development."
        },
        {
          "question": "What is the authorization token approach to recurring payments without full pre-funding?",
          "answer": "Instead of pre-funding the full subscription amount, users store funds in a large pool, then issue authorization tokens with spending restrictions and hand them out as needed. The tradeoff is privacy - this model links payments through the shared pool. Implementation requires either specific wallet code to manage or a wallet that understands templates, planned for implementation with XO (CashScript execution opcodes)."
        },
        {
          "question": "What is x402 protocol for crypto payments?",
          "answer": "Chris: Coinbase developing x402 protocol - blockchain agnostic, uses HTTP 402 code for browser crypto payments. Whitepaper mentions 'batched settlements' on page 12 but just carve out for future work - nothing implemented or refined into specification yet."
        },
        {
          "question": "What is x402-bch protocol implementation?",
          "answer": "Chris: x402 protocol created by Coinbase leverages HTTP 402 'Payment Required' error. Coinbase implementation focuses on USDC on Base L2 blockchain. Created slight variation to protocol to support Bitcoin Cash - developers can implement own x402 server that accepts BCH for payments."
        },
        {
          "question": "What market demand exists for BCH-denominated subscriptions?",
          "answer": "TMU from running largest monthly recurring payment protocol 3+ years: zero market demand for coin-denominated subscription service. Never heard user say they want it. Why BCH getting dropped as option for v3 unspent annuities (subscriptions). MUSD might change this."
        },
        {
          "question": "What use cases require confirmations despite zero-conf availability?",
          "answer": "High-value transactions (house, car, >$2000) where amounts are too risky for zero-conf. Non-anonymous transactions with named invoices where instant finality isn't required (rent, monthly bills). These typically get checked after an hour or day. Zero-conf is mainly for anonymous transactions you'd do with cash today."
        },
        {
          "question": "What was CoinText and offline payment experiments?",
          "answer": "Vin Armani created CoinText - sent different cryptos via text message, tied joint-custody wallet to phone number (shut down years ago). Tobias Ruck developed be.cash offline-payment system - load RFID card with miner-confirmed UTXOs ($1, $5, $10 denominations), merchant needs internet but payer doesn't."
        },
        {
          "question": "Why do subscription services prefer pull over push payments?",
          "answer": "Pull schemes benefit from customer indifference to cancellation - significant revenue stream. Studies show customers don't cancel subscriptions they should. If user must take action each month to keep subscription, more likely to cancel than auto-renew."
        },
        {
          "question": "Why is BCH recurring payment system unique vs EVMs?",
          "answer": "No other p2p chains with introspection and no EVM with low fees as long-term plan. Can't hardcode MEV executor fee and expect to run on EVM chain long-term. Easy one-time fire-and-forget recurring payment solution running for years is unique BCH value prop. Only new BU chain might support same."
        }
      ]
    },
    {
      "name": "DeFi & DEX",
      "description": "Decentralized finance protocols, AMMs, liquidity pools, trading, and DeFi infrastructure including Cauldron, TapSwap, and derivatives",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can L1 transactions handle high-frequency trading on DEXes?",
          "answer": "Mempool processing chained TX every 200-300ms is fine - L1 TXs aren't suitable for HFT anyway. Jay Berg claims to have solved sequencing problem with Sidepit (docs.sidepit.com). Some solutions being explored involve miners running sequencers to keep it decentralized."
        },
        {
          "question": "How do BCH trading bots work without primary DEX websites?",
          "answer": "Trading bots already exist that do NOT use primary websites. Libraries for doing DeFi that aren't using websites exist like github.com/hosseinzoda/vegabch. Having central entity needing to sign off on each transaction is catastrophe waiting to happen - entity could just not sign and lock funds."
        },
        {
          "question": "How do Cardano sequencers (batchers) work and why does BCH need them?",
          "answer": "Cardano has sequencers called 'batchers' for DeFi ordering. BCH mempool is not good enough - can only process chained transaction every 200-300ms. Sequencing job for DeFi UTXOs could be done by miners to produce extra income. Main issue is real-time synchronization - users need to know latest UTXO set state before building transaction."
        },
        {
          "question": "How do subroutines handle recursion and indexing in the Subroutines CHIP?",
          "answer": "Subroutines declare at code start, receiving an index. All calls use this index (2 bytes per call), including recursive self-calls. The compiler maps this like shortening method names to integers. Subroutines read a fixed number of stack arguments defined at declaration. For variable argument counts, use loops instead of subroutines. OP_RUNSUB calls local subroutines; OP_RUNSUB2 calls subroutines from other inputs."
        },
        {
          "question": "What BCH contracts benefit from faster block times?",
          "answer": "Faster block times improve: (1) AMM DeFi - cannot use zeroconf, need faster confirmations. unspent.cash perpetuities, Cauldron AMM, and dozens of MEV contracts use anyone-can-spend transactions. (2) PR and psychological perception as 'snappier coin' due to more confirmations in shorter timeframe. Instant transactions (zeroconf) handle all other cases."
        },
        {
          "question": "What TVL metrics show BCH DeFi growth?",
          "answer": "TVL (Total Value Locked) graphs at tokenaut.cash/defi and defillama.com/chain/Bitcoincash show growth. Cauldron, anyhedge, bchbull, Moria all showing \"up and to the right\" pattern. TVL numbers not affected by transaction count inflation (unlike TX count which can be artificially inflated on low-fee chains)."
        },
        {
          "question": "What WalletConnect dapp ideas are sought by the BCH community?",
          "answer": "Key WalletConnect app ideas include: vault management, Last-Will inheritance, Mecenas recurring payments, 'Hodl' timelock, AnyHedge integration, airdrop/dividends distribution. Also sought: AMM DEX curve visualizer/simulator, CashScript-py SDK, address analyzer for privacy leaks, double spend proof (DSP) checker website, and TypeScript BCMR indexer."
        },
        {
          "question": "What is Small Index contract and how does it help DEX discovery?",
          "answer": "Small Index (bitcoincashresearch.org/t/1471) can tag many protocols per token category. Designed for CatDex but could handle Cauldron, Tapswap, and Dutch Auctions. Solves SPV wallet pool discovery if pools advertise using this method - would increase pool volume so they have incentive to adopt."
        },
        {
          "question": "What is Squid technology and how is it used with TapSwap?",
          "answer": "Squid is a blockchain indexing/query technology integrated into TapSwap at sqd.tapswap.cash/graphql. It provides a GraphQL interface for querying blockchain data related to the DEX. The technology enables efficient data access for the TapSwap application without requiring full node queries for every operation."
        },
        {
          "question": "What is TON blockchain malleability issue?",
          "answer": "Total Commander: Recently integrated TON and malleability in UTXO coins is nothing compared to what happens there - tx hash mutates on its own upon propagation. It's total nightmare when you don't use their proprietary indexers."
        },
        {
          "question": "What is alternative to executable bit for OP_EVAL?",
          "answer": "Have OP_DEFINE, then have to have OP_RUNDEFINED, then also have OP_GETDEFINED so can get definition on stack and hash it for verification. Then have to have OP_UNDEFINE maybe. Creates whole new stack for function definitions. Executable bit approach: use same opcodes to manage function stack rather than create whole new stack for function definitions."
        },
        {
          "question": "What is the DEX UTXO contention issue on Cauldron?",
          "answer": "Mempool conflicts occur due to arb bots competing - users create valid Cauldron transactions and push simultaneously to different node sets causing split. Trade not final until no mempool conflicts exist. With faster blocks, users wait for 1 confirmation which would be much shorter (2-4min vs 10-20min). Mempool is not good enough - needs better real-time synchronization or split rules for DeFi vs non-DeFi transactions."
        },
        {
          "question": "What is the DeFi-to-commerce 0-conf transition pain point?",
          "answer": "Suppose you do DeFi actions ending with 0-conf p2sh chain, then pay merchant with p2pkh - it has 0-conf p2sh ancestors so DSP score is 0 and merchant may demand 1 conf. With 10min target only 0.5% chance DeFi chain confirms during 1min user action lag, so 17min wait in 50% cases. With 1min blocks, DeFi likely confirmed - merchant accepts 0-conf, or worst case 1-3min wait."
        },
        {
          "question": "What is the deferred TXID assignment proposal for DEX transactions?",
          "answer": "Proposal: broadcast utxo+signature (checkdatasig) enabling asynchronous TX generation. User doesn't commit to specific TX/TXID - remains undefined until miner generates and mines transaction. TXID assigned once someone mines it. Only change required is in communication so miners can build TXs with this method."
        },
        {
          "question": "What is the permissioned vs permissionless DEX tradeoff?",
          "answer": "Server can increase UX (BCMR metadata, LP statistics, faster order books, secure reorder-free TX submission) and provide APIs with stability guarantees. Not all central servers are bad - only ones that lock you in. However, third-party signing requirement means operator can comply with government regulations. Alternative: thin indexers deployable by anyone with REST APIs for getting pools - treats Cauldron as protocol not service."
        },
        {
          "question": "What vulnerability did TapSwap nearly have?",
          "answer": "Almost blew up for silly reason: checked signature against pubkey provided in input but without authenticating it via committed hash. Example of footgun that has nothing to do with OP_EVAL - demonstrates fundamental contract safety doesn't change with eval."
        },
        {
          "question": "What was Pat's tapswap contract bug and fix?",
          "answer": "Pat's tapswap had bug: had spender provide pubkey but didn't have code to auth pubkey against hash - oops, now any key can unlock it. Bug quickly fixed - he swept them all and moved to new versions using the exploit haha. Shows contracts can ask for bytes in unsafe way, whether data or code."
        },
        {
          "question": "When is 0-conf considered final enough to proceed with DEX swaps?",
          "answer": "Users need to know there are no mempool conflicts. Issue exists for DeFi users who need certainty transactions won't reverse. Common case: user has tokens A,B,C, merchant wants token Z. Wallet creates p2sh swap chain to Z then p2pkh to merchant. P2PKH not DSP compatible due to unconfirmed p2sh parent."
        },
        {
          "question": "Why can't primary market maker use AMM for instant finality?",
          "answer": "If make up random number and it gets published to blockchain in completely decentralized way or used in perfectly decentralized protocol, decentralization after the fact doesn't change that source of data was single party. Primary market maker for crypto can profit from keeping lots of markets in sync - problem is, with current AMM and blocktime, can't get instant trade finality without also mining all the blocks."
        }
      ]
    },
    {
      "name": "Oracles & External Data",
      "description": "Oracle implementations, price feeds, external data integration, and off-chain data verification",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How do fiat-denominated recurring BCH payments work with oracles?",
          "answer": "For fiat-denominated recurring payments (e.g., $30/month), payouts use a specific fungible token (FT) with an oracle message as input. The oracle provides exchange rate data so contracts can calculate the correct BCH amount. Main limitation: contracts depend on oracle availability - if the oracle ends, the contract can't determine the correct conversion amount."
        },
        {
          "question": "How to achieve decentralized oracles?",
          "answer": "Ultimate answer: computers need to scan and certify real world information in way that cannot be faked (i.e. can be verified cryptographically). In each case, there is real human that does work to collect some data and provide it. This human is the centralized element. Replace that human, and you get decentralization."
        },
        {
          "question": "Is verifiable serializing AMM with centralized entity acceptable?",
          "answer": "Argument: verifiable serializing AMM using centralized entity is no-worse than price-oracles. Not possible to get USD/EUR prices using completely decentralized system because these currencies belong to centralized entities (governments). Even for on-blockchain tokens only, still centralized entity that extracts trade fees, so completely absolutely decentralized operation is impossible anyway."
        },
        {
          "question": "What are TXv5 read-only inputs and how do they benefit oracle protocols like d3lphi?",
          "answer": "Read-only inputs allow multiple transactions to reference the same UTXO without conflicting. For oracle protocols like d3lphi, this prevents users from fighting over oracle message UTXOs. Thousands of users can spend the same oracle UTXO (UTXO_A) read-only within minutes. This saves the intermediate transaction that would otherwise create multiple copies (B, C, D, E) of the oracle data."
        },
        {
          "question": "What are best practices for LLM-assisted BCH development?",
          "answer": "Crank up context window (32K tokens), stuff as much relevant information as possible into prompt. If have ZK code or Script examples, add those. Make scope very concise, provide feedback on error logs. Feed in external documentation for AI to review. Use one AI to generate code, feed to different AI to sanity check."
        },
        {
          "question": "What is gigahashcoin stable coin oracle mechanism?",
          "answer": "Gigahashcoin is ultimate 'stable' coin - price oracle as decentralized as mining. GH/BCH = (difficulty / block reward). With ASICs already far on development s-curve, should be less inflationary than fiat, but still inflationary. Others put up BCH collateral to mint GHC at oracle price."
        },
        {
          "question": "What oracle solution recommended for BCH prediction markets?",
          "answer": "Oracle itself is trivial (week's work for backend dev). Real challenge is data - entire business in itself. Financial data providers already exist with thousands of customers. Combining existing data businesses with oracle tech makes best approach for tens of thousands of tickers and prices. See read.cash/@TomZ/oracles-7bd61bb5 for details."
        }
      ]
    },
    {
      "name": "Zero-Knowledge Proofs & Privacy",
      "description": "ZKP implementation, privacy features, CashFusion, shielded transactions, and cryptographic privacy techniques",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can shielded addresses be implemented on BCH using ZK-STARKs?",
          "answer": "Shielded addresses that hide sender/receiver (but not amounts) are theoretically possible on BCH using existing opcodes without consensus changes. The challenge is that finding your funds requires testing every output with costly EC-mul operations. While a specialized ZK-STARK verifier opcode could improve efficiency, the polynomial arithmetic needed for zero-knowledge proofs can be implemented using current BCH Script opcodes."
        },
        {
          "question": "How do you set up DNS-over-HTTPS with Unbound and nginx?",
          "answer": "Running your own DNS-over-HTTPS resolver improves privacy and avoids ISP/government MITM. Melroy van den Berg provides config examples (gitlab.melroy.org/-/snippets/620) and blog series covering Unbound setup (blog.melroy.org/2025/dns-part-1/). This allows you to control DNS resolution instead of relying on potentially compromised public resolvers or ISP DNS."
        },
        {
          "question": "How does Tornado Cash ZKP mixer work?",
          "answer": "Fixed deposit tiers (1, 10, 100, 1000 BCH for indistinguishable amounts). On deposit get receipt. On withdraw: ZKP proves you own deposit cryptographically without revealing which specific deposit. Merkle trees track deposits. When withdrawing don't submit commitment for which you redeem - proves ownership of secret with data + keys, not specific receipt."
        },
        {
          "question": "How would ZK shielded transactions work on BCH?",
          "answer": "Users send BCH to a P2SH covenant address, receiving an NFT with random-looking 32 bytes in the commitment. To transact inside the shielded pool, provide a ZK proof as input script authorizing updates to NFT commitments. The covenant calculates/verifies encrypted balance updates according to ZK system math. To exit, provide a proof showing entitlement to BCH without revealing when you entered. All transactions look like one address transacting with itself to external observers."
        },
        {
          "question": "Is Tornado Cash possible on BCH with current tools?",
          "answer": "Yes with loops - possible to do ZKP verification. Other piece is merkle trees to track deposits. Would use OP_CHECKDATASIG for proof verification. See github.com/tornadocash/tornado-core/blob/master/contracts/Verifier.sol. Industry moved to ZKPs for sidechains, SPV 2-way peg proofs never took off."
        },
        {
          "question": "Is central signer for AMM trades comparable to CashFusion coordinator?",
          "answer": "Automated signature from centralized server that one can opt to use isn't that bad. Everything still public and has to be broadcast regardless. Attempts by service to cheat likely obvious with tx to sign not adding up if transaction(s) withheld. CashFusion has coordinator that has to be trusted to some degree - not much difference here."
        },
        {
          "question": "What are mobile background task limitations for BCH wallets?",
          "answer": "Android/iOS pedantic about conserving battery. Capacitor background runner is scheduled job running every X minutes (depends on platform, ~15min delay). Alternative: Push Notifications as 'wake up app' (requires Firebase for Google, ANS for Apple). Privacy tradeoff - backend needs to know addresses wallet monitors. Flowee Pay can run background without GUI for CashFusion when charging overnight."
        },
        {
          "question": "What are the advantages of ZK shielded pools over CashFusion?",
          "answer": "The main advantage is non-interactivity. With ZK pools, you can pay in, transact inside the shielded covenant, and pay out whenever you like without needing to wait for other participants. CashFusion requires coordination with other users to create coinjoin transactions. However, ZK proofs are large, resulting in big transactions. Optimal architecture (L1 per-user TXs vs privacy L2) remains undetermined."
        },
        {
          "question": "What are the differences between ZK-SNARKs and ZK-STARKs for BCH privacy?",
          "answer": "ZK-SNARKs require a trusted setup (potential backdoor) and use smaller proofs, while ZK-STARKs have no trusted setup, are quantum-resistant, but have larger proof sizes. The ZKP math is extremely complex - 100x harder to understand than Bitcoin's whitepaper. An average programmer with 20 years experience but no math-specific PhD won't understand ZKP whitepapers. This complexity raises concerns about implementing backdoors unintentionally."
        },
        {
          "question": "What challenges exist for BCH ZK privacy implementations?",
          "answer": "For Tornado Cash-style ZKPs, BCH needs a method to loop through all previously used nullifiers to prevent withdrawal replay/double-spends. ETH has global state and hash tables making this trivial, but BCH has no equivalent. Without this, implementations require challenge periods with bonds and merkle trees, making them less user-friendly than EVM chains. Additionally, proof sizes can't shrink without cryptographic breakthroughs."
        },
        {
          "question": "What is RPA (Reusable Payment Addresses) in Bitcoin Cash and how does it relate to privacy?",
          "answer": "RPA is a stealth address implementation on BCH that enables privacy-preserving reusable addresses. It works similarly to stealth addresses where the receiver can publish a single reusable address, but each payment goes to a unique on-chain address. Electron Cash supports RPA, though it's currently in alpha stage. RPA is more efficient and compatible than some alternatives and can work alongside CashFusion."
        },
        {
          "question": "What is Shadow's ZKAM-FMT for fiat verification?",
          "answer": "Shadow: ZKAM-FMT spec verifies browser TLS data and email data to confirm fiat payments have been made to onramp from FIAT. ZKP2P guys implemented similar idea. Can be done better - custom Firefox/Chromium variant watches for certain variables in document instead of browser plugin with proxies and TLS magic."
        },
        {
          "question": "What is Tom's advice for ZKP implementation on BCH?",
          "answer": "Doesn't make sense to want opcodes enabled on chain as first step. Instead work with team to make actual ZK script work by modifying full node privately. When it works fully and isn't hacked instantly, then look at what was needed and propose changes to main chain. Avoid wishful design behavior."
        },
        {
          "question": "What is ZKP2P hooks for BCH onramping?",
          "answer": "Luke/Shadow: ZKP2P hooks could be used with cross chain swaps like THORChain. Hook acts as robot - takes USDC from ZKP2P escrow and gives to THORChain with memo to swap for BCH and send to specific address. Could tap into zkp2p for trustless on/offramping into BCH."
        },
        {
          "question": "What is the difference between ZK-SNARKs and ZK-STARKs for BCH privacy?",
          "answer": "ZK-SNARKs require a trusted setup and use smaller proofs, while ZK-STARKs have no trusted setup, are quantum-resistant, but have larger proof sizes. For BCH, the discussion centers on using ZK-STARKs to hide sender and receiver addresses without hiding amounts. Implementation doesn't necessarily require new opcodes - existing math operations can perform the polynomial arithmetic needed."
        },
        {
          "question": "What privacy features are planned for BCH's May 2025 upgrade?",
          "answer": "Shielded transactions are being discussed as a possibility after the May 2025 network upgrade. This would complement existing privacy features like CashFusion and RPA (Reusable Payment Addresses). The shielded transaction capability would represent a significant enhancement to BCH's privacy toolkit beyond the current stealth address implementations."
        },
        {
          "question": "What wallet support exists for RPA (Reusable Payment Addresses) on BCH?",
          "answer": "Electron Cash currently supports RPA functionality. However, broader wallet adoption remains limited, with RPA still being considered an alpha product. Increased awareness and wallet provider adoption is needed before RPA becomes a mainstream privacy feature. Some wallets like Cake Wallet are being approached to add RPA and CashFusion support together."
        },
        {
          "question": "Why are advanced ZK systems currently impractical on BCH?",
          "answer": "While technically possible already, ZK verification is very impractical and expensive. Porting a zkVM's on-chain verification to 2025 BCH VM would cost ~10,000x typical BCH transaction fees with extremely limited wallet support. Most work involves workarounds rather than optimal implementations. Even building from scratch, the constraint differences encourage sub-optimal ZK constructions versus systems designed without program length concerns."
        },
        {
          "question": "Why is CashFusion trustless compared to other mixers?",
          "answer": "CashFusion requires no trust - needing to trust some parties is infinitely worse than not needing to trust any parties. This contrasts with staking-based approaches which add trust assumptions about who can replace commitments."
        }
      ]
    },
    {
      "name": "Mining & Consensus",
      "description": "Mining operations, consensus mechanisms, difficulty adjustment, block time, and miner economics",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can PoW difficulty serve as price oracle for fee adjustments?",
          "answer": "Research shows correlation between PoW difficulty and USD price (bitcoincashresearch.org/t/1426). Could be used for minimum relay fee algorithm - favorite angle for auto-adjusting fees because doesn't rely on third-party. Has some edges to work out but promising approach."
        },
        {
          "question": "Can miners bypass nSequence relative locktime enforcement?",
          "answer": "If nSequence is set, miners cannot mine the transaction until the input ages - this is consensus-level enforcement, not miner policy. However, if nSequence is not locked by signature, CSV, or introspection, a miner could change the value and mine the modified transaction ahead of time. Locking the nSequence value (via signature/script) is critical for trustless locktime enforcement."
        },
        {
          "question": "Can miners manipulate block fees for oracle pricing?",
          "answer": "Miners could mine blocks with extra unpublished transactions creating fees going back to themselves - 100% gameable. But other miners could try steal those fees via reorg. Packing fee is akin to wash trade - market buy and instant sell + risk of reorg and other miner taking your donation. If pack 10%-20% extra could skew feed without reorg risk."
        },
        {
          "question": "Do read-only inputs create MEV or attack vectors for miners?",
          "answer": "A miner could ignore transactions referencing a read-only UTXO while including a transaction that fully spends it, invalidating the read-only transactions. However, this is not economically incentivized - miners would be throwing away fees for no good reason. It's the same as existing double-spend scenarios, nothing fundamentally new regarding miner behavior."
        },
        {
          "question": "Does BCH have mining documentation for newbies?",
          "answer": "Shadow: Does not seem like BCH has documentation allowing newbies to start mining quickly. Last week there was guy who wanted to mine here and he could not find any precise docs plus nobody could help him directly. Certainly lacking but not extremely important issue."
        },
        {
          "question": "How can Starlink bandwidth be increased for mining operations?",
          "answer": "Multiple Starlink dishes can be used to increase bandwidth (starlink-enterprise-guide.readme.io/docs/using-multiple-starlinks). Starlink provides ~50ms latency which is sufficient for mining. Combined with improving LEO satellite constellations over 10-20 years, could bring everyone close to speed-of-light limits for global connectivity."
        },
        {
          "question": "How do miners and relay fees interact with fee markets?",
          "answer": "Lowering relay fee shouldn't require consensus - some miners already only mine TXs above certain fee (saw 7sat/byte minimum). Miners can accept lower fee TXs to include as space allows, though may put them at orphan disadvantage. If demand exists, miners will lower min fee with prodding if it gets them more revenue."
        },
        {
          "question": "How does ASERT DAA adapt to block time changes?",
          "answer": "ASERT is time-based, invariant of target block time. Adjustment won't be faster, just smoother - done in smaller increments/decrements. If had enough power to halve or double difficulty after 2 days - continues to be case with shorter blocks, just done in greater number of smaller adjustments. Same with ABLA - same 2x/year annualized rate limit in smaller steps. gitlab.com/0353F40E/fablous#difficulty-adjustment-algorithm-daa"
        },
        {
          "question": "How does network topology affect 1-conf reorg experience with first-seen rule?",
          "answer": "1-conf reorgs happen with 1st-seen rule due to connection quality disparities. Miners with worse connection have higher chance of losing the race. Users close to slow miners have higher chance of witnessing TX reorgs. Header-first mitigates bandwidth but not ping - if 80% hash is on one side of planet and 20% on opposite, the 20% has ~300ms disadvantage (0.05% orphan rate at 10min, 0.5% at 1min blocks)."
        },
        {
          "question": "How does the H(A||B) deterministic tiebreaker affect block replacement difficulty?",
          "answer": "To flip a known block A with block B requires satisfying BOTH network difficulty AND winning H(A||B) comparison - making it 2x harder than just satisfying network difficulty. This is a tie-breaker only for same-height contention, not an override. One block can't replace two blocks even if tip's hash would win."
        },
        {
          "question": "What are the hardware constraints that make header-first mining attractive?",
          "answer": "Miners face hardware problem: can't turn off mining during validation without damage. Going from zero to 100 ampere in milliseconds creates massive power fluctuations causing hardware reboots. Options: (1) keep mining old block (risk orphan), or (2) mine empty block on new header until validation completes. Most choose option 2 (header-first)."
        },
        {
          "question": "What attack vector exists with deterministic block tiebreaker for high-fee blocks?",
          "answer": "If a block has extraordinarily high fees (like 3x usual), miners could be incentivized to keep mining at same height since there's 50/50 chance their block wins H(A||B) and all other miners would switch. This creates unknown unknowns where miners might continue mining at tip-1 to hurt another miner with little risk instead of mining on tip."
        },
        {
          "question": "What is Infrastructure Blocks (iBCH) and how does it relate to BCH?",
          "answer": "iBCH is a CashToken that enables experimental features BCH cannot have (10s block time, higher inflation, higher orphan rate). BCH serves as gas, so you always need BCH to use iBCH. It's supplementary, not superior - intentionally flawed (higher orphan rate, more inflation) but does things BCH cannot do like controversial features without burdening main chain."
        },
        {
          "question": "What is header-first mining and why do some pools not use it?",
          "answer": "Header-first allows miners to immediately start mining on new block using just the header (before full validation) but must mine empty block to avoid invalid UTXO spending. Most pools use it, but Foundry doesn't. Reasons: BTC's 1MB limit makes bandwidth impact insignificant, Foundry is majority so doesn't lose much from validation time, and as fees dominate subsidy header-first becomes less attractive (empty blocks lose fee revenue)."
        },
        {
          "question": "What is the FUD concern about block time change?",
          "answer": "Changing block time creates FUD opportunity: 'changing block time will mean inflation goes up by same factor.' Vast majority never hit problems this solves, so it's a tax. Chain hasn't grown much in 5 years - doing this now could drain chance of winning."
        },
        {
          "question": "What is the argument about faster block times being contentious?",
          "answer": "Block time isn't technically specified in whitepaper (only referenced as example). Despite practical benefits, changing it could be contentious due to ecosystem inertia. Some argue existing permissionless solutions should be implemented first before considering consensus changes."
        },
        {
          "question": "What is the argument for adjustable block time?",
          "answer": "Proposal: reduce time to 1min now, make it adjustable without breaking again so future can go to 30s, 20s, maybe 10s once LEO sats ubiquitous - by just changing number in code and activating. Pay most of cost now, reap benefits forever."
        },
        {
          "question": "What is the deterministic tiebreaker proposal for Bitcoin block selection?",
          "answer": "Proposed solution (bitcoincashresearch.org/t/1532) uses H(A||B) hash comparison as objective tiebreaker for same-height blocks instead of subjective 1st-seen rule. When two blocks have equal chainwork, nodes would switch to the block that wins H(A||B) test. Aims to enhance fairness and convergence, particularly relevant for faster block times (1min blocks would have 0.5% orphan rate from 300ms ping difference)."
        },
        {
          "question": "What motivated research into deterministic block selection tiebreakers?",
          "answer": "Research started from asking: 'Why are orphan rates a problem?' and 'How high could we tolerate?' Key insight: if everyone had equal orphan rates they wouldn't be a problem. Led to question: 'If we have to have some orphans, is there a way to equalize orphan rates across pools?' Goal is enabling faster blocks (10s blocks possible in 10-20 years with better connectivity)."
        },
        {
          "question": "Why do orphan rates matter less if they're equal across all pools?",
          "answer": "If everyone had equal orphan rates, impact would be like a price drop - everyone affected equally. The inequality is what's dangerous for the network. Actual orphan rate is less than one block per week. With 2min blocks maybe 1 every few days. Formula for max orphan rates is just a limit - actual doesn't grow proportionally."
        },
        {
          "question": "Why is BCH not a good timestamp server?",
          "answer": "Bitcoin is *not* a good timestamp server but could be - if future time limit was more tight and monotonic timestamps enforced (zawy12 github issue). Block time used as extended nonce bits to find valid PoW. As difficulty goes up, timestamp used more in lieu of new block template resulting in new merkle proof."
        },
        {
          "question": "Why is block time benefit curve considered non-linear?",
          "answer": "2.5 minutes isn't twice as good as 5 minutes - it still sucks if waiting for confirmation. Real benefits seen at sub-10s where user can watch screen and take action if TX not confirmed. But sub-10s not reasonable with today's tech."
        },
        {
          "question": "Why is dust limit necessary and how should it work?",
          "answer": "Controls state bloat - critical for scaling. Should be enforced on UTXO creation but NOT on spending. No reason to prevent cleaning up 0 or 1 sat outputs - want easy state removal. Proposal: halve every 4 years conditional on difficulty at least doubling (difficulty = proxy for coin value growth vs real world)."
        },
        {
          "question": "Why is orphan rate inequality more problematic than the absolute orphan rate?",
          "answer": "If everyone had equal orphan rates, it would have the same impact as a price drop - everyone affected equally. The inequality is what's dangerous for the network. BCH's actual orphan rate is less than one block per week. The formula for max orphan rates is simply a limit, not the actual rate."
        }
      ]
    },
    {
      "name": "Networking & P2P",
      "description": "Peer-to-peer networking, protocol messages, mempool behavior, block propagation, and network topology",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "Can HTTP-based p2p networks form true mesh?",
          "answer": "Tom/BCA: VAST majority of http users are behind NAT and short-lived. Yes you can replicate Satoshi's design - clients connect and share IPs of other clients etc. But individual users very unlikely to actually be part of real mesh due to NAT and connection constraints."
        },
        {
          "question": "How common are double spends on BCH?",
          "answer": "Richard/Emergent: Double spends are normal and happen more often than one might think. Easy to accidentally create them in automated/procedural systems that aren't mature yet. Network rejects double spends and over electrum you'll always see consistent view of chain."
        },
        {
          "question": "How did BCA learn BCH p2p layer?",
          "answer": "Shadow: You sent TX manually using Linux console tools? You must have been really bored. BCA: I wanted to learn how p2p layer stuff works, it was good opportunity. Like I did this just by reading the spec - sent transaction manually via console."
        },
        {
          "question": "How do block size and latency relate to propagation bottlenecks?",
          "answer": "The smaller the blocks, the more weight latency has. The larger the blocks, the more weight bandwidth has. With small blocks (like BTC's 1MB), bandwidth's impact on propagation time is insignificant - latency dominates. For larger blocks, bandwidth becomes the bottleneck."
        },
        {
          "question": "How does 0-conf p2sh ancestor affect p2pkh safety?",
          "answer": "0-conf p2sh ancestor makes p2pkh 0-conf much less reliable. Problem can spread to other non-DeFi transactions. Either needs split in rules or better real-time synchronization. If propagation meets where conflicts exist, it stops and DSP is generated instead of propagating conflict."
        },
        {
          "question": "How does Nostr achieve censorship resistance?",
          "answer": "Kallisti: Nostr is a hydra. Censorship-resistant property comes from simplicity of protocol - spinning up relay is super simple. Even if you got banned from all popular relays or all maxi clients block your relay, you and your friends/followers can still use your relay/client or some neutral relay/client."
        },
        {
          "question": "How does Nostr relay architecture work?",
          "answer": "Kallisti: Nostr relays don't sync with each other. It's just client-server where client connects to many independent servers and client does what it will with whatever data those servers serve. All glued together by pubkey crypto."
        },
        {
          "question": "How does mintxfee parameter work in BCHN?",
          "answer": "Mintxfee setting (fees in BCH/kB smaller than this considered zero fee for transaction creation, default: 0.00001). Can be set lower than 1 sat/byte using fractional BCH/kB values. Creation != relay so that setting might not make transactions propagate without corresponding relay setting."
        },
        {
          "question": "How does nakamoto-cash handle MerkleBlock fetching?",
          "answer": "Uses concurrent approach mapping new peer after every 25k block range. May receive higher height blocks before lower ones. Can tweak rescan and BloomManager for different strategy. Added get MerkleBlocks button with sliders to adjust start/stop ranges in examples/ dir. 25k is 6 months of blocks - may be bit much."
        },
        {
          "question": "What factors affect network latency besides distance?",
          "answer": "Speed of light varies by medium (faster through air than glass). Total factors: routing overheads (number of hops), total distance, interference, and medium. Fiber has less interference and fewer hops but slower light speed than air. Starlink has ~50ms latency - terrible vs fiber, great vs many less-wired countries."
        },
        {
          "question": "What is LibP2P exploration for BCH WalletConnect alternative?",
          "answer": "Jim exploring LibP2P as generalized solution. Allows WC-like functionality plus perks: run web-accessible Fulcrum/Chaingraph/backends from home, run web-accessible BCH-P2P subnet on LibP2P (encrypts everything, effective against deep-packet inspection). Still have hesitations on LibP2P libs stability."
        },
        {
          "question": "What is Starlink's satellite-to-satellite low latency capability?",
          "answer": "Normal Starlink has ~50ms latency bouncing land uplink off nearest sat. They also have capability to offer very low bandwidth ultra low latency beaming between sats on their global sat-to-sat network links. Sats are redundant and disposable - 'just make them cheap and let them fall' approach to LEO orbit loss."
        },
        {
          "question": "What is Yggdrasil mesh networking?",
          "answer": "Tom: Yggdrasil is mesh networking tech that replaces tcp/ip layer. Excellent concept, needs to be used more. Reminds of power where app and wallet on same local network can communicate directly without centralized server."
        },
        {
          "question": "What is concern about DeFi vs peer-to-peer cash focus?",
          "answer": "Goal is peer to peer cash - without healthy growth there, chain will die. DeFi/tokens filling blocks only marginally better than ordinals on BTC. Use them as advertising for real game, but never lose sight of native token being real product. Need stability - currencies stabilized with sound derivatives."
        },
        {
          "question": "What is network effect strategy for BCH development?",
          "answer": "Focus on BCH first - don't prioritize retaining builders with foot out door or maintaining compatibility with other chains. Network effect comes from unique features others want to copy. Thriving BCH motivates others to integrate. Catering to integrators gets neither BCH improvements nor integration. Weighted network nodes (100% BCH focused) exponentially more impactful."
        },
        {
          "question": "What is the Rust nakamoto package p2p client example?",
          "answer": "A light p2p client example app (github.com/samrock5000/p2p-client/tree/master/examples) using rust nakamoto package. Toy app lets you update bloom filter from input form and send 'loadfilter' message to peers. Detects BCH addresses and hex encoded data. Future plans include merkleblock fetching and inclusion proof validation. Builds on Linux and macOS."
        },
        {
          "question": "What is the history of FindBitcoin.cash / GeoDrop.cash?",
          "answer": "FindBitcoin.cash (later GeoDrop.cash) was a proof-of-concept built during a hackathon by Chris Troutner, Daniel Humgon, Lightswarm, and architect/erik (devpost.com/software/purelypeer). It used SLP and was maintained by Chris afterward. The idea evolved to PurelyPeer.cash with a new team. It was a webapp inherently prone to geospoofing; PurelyPeer mobile-only execution helps prevent geospoofing."
        },
        {
          "question": "Why doesn't DSProof catch all double-spends?",
          "answer": "DSP won't catch nuked parent p2sh. Requirements: transaction must contain all P2PKH, must either spend only from confirmed UTXOs OR all mempool ancestors must also be all-P2PKH transactions. All inputs and mempool ancestor chain must be SIGHASH_ALL without ANYONECANPAY. P2sh ancestor means DSP score of 0 - NOT COVERED by DSPs."
        },
        {
          "question": "Why introduce sub-satoshi (millisat) precision and how does it affect miners?",
          "answer": "At $100M/BCH, 1 sat/byte fees would be $219 USD per transaction - too high for BCH's low-fee goal. Millisats allow 1 msat/byte ($0.219 USD) fees. The minrelayfee exists for network health (UTXO set size, economic value), not miner compensation. It doesn't change with subsats unless needed. Miners already control fee acceptance - they can mine empty blocks or accept below-minrelay fees via direct submission."
        }
      ]
    },
    {
      "name": "Scalability & Performance",
      "description": "Scaling solutions, transaction throughput, UTXO management, optimization techniques, and performance considerations",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How are UTXOs stored and managed?",
          "answer": "UTXO stored on disk, only loaded to memory when spending. Optimization of keeping old UTXOs on disk vs memory already implemented. Taking UTXOs not moved in years and keeping on disk reduces cost significantly, slightly more costly to load when needed (plus IBD with UTXO commitments)."
        },
        {
          "question": "How can multiple users use same DEX UTXOs without conflicts?",
          "answer": "Core question: multiple users want to use same set of UTXOs at same time - how without leading to ignored transactions? Could use blind limit orders so miners/platforms match them. Opens MEV opportunities but from user POV pays with MEV for execution success. Risk: user makes trades thinking profit only to have it removed."
        },
        {
          "question": "How to get UTXO composition info with mainnet-js?",
          "answer": "await wallet.getAddressUtxos() to see UTXO info directly. Fee handling abstracted away - this is feature. Depending on whether balance is 5 $100 bills or 100 $5 bills, bitcoin fee will be different. Need to know what fee to pay to know if have enough. JS library and REST service should have identical API to extent possible. Frontend supports watch wallets."
        },
        {
          "question": "Is UTXO contention a problem for BCH?",
          "answer": "Emergent/Tom: UTXO contention is real issue BCH going to need to face. Not clear yet exactly what tradeoffs are in various solutions. Wallet or app can create more UTXOs for nearly free. Worst case is regular mempool divergences, best case nothing burger."
        },
        {
          "question": "What are read-only UTXOs from TXv5 proposal?",
          "answer": "Jason's TXv5 idea: input that doesn't get spent. Any input can be marked as RO in transaction which causes UTXO to not be removed from UTXO set. Neat idea but many details to iron out before feasible."
        },
        {
          "question": "What mempool management challenges do read-only inputs create?",
          "answer": "Nodes must keep spent UTXOs in memory until mined because new valid transactions might reference them read-only. Example: UTXO_A has thousands of read-only spends plus one non-read-only spend creating UTXO_B (new oracle message). Before mining, miners are incentivized to accept more transactions spending UTXO_A since they don't conflict and all pay fees. This complicates mempool eviction and resource management."
        },
        {
          "question": "Why can't read-only UTXOs work with global state?",
          "answer": "Read-only UTXOs would be special: indestructible and non-contentious (many txs can spend same one). But it's hacky way to get global function table. Without ownership they can't be burnt, leading to UTXO set pollution. Can't make well-scaling coin with global state."
        }
      ]
    },
    {
      "name": "Security & Best Practices",
      "description": "Security considerations, common vulnerabilities, footguns, auditing, and contract safety patterns",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "What are the security tradeoffs of StableHedge's centralized treasury?",
          "answer": "A rug is possible with multisig treasury control, and hack/loss of controlling keys is also a risk. Improvements could include partial withdrawal with renewed timelocks (e.g., max 10% every 10 days) to slow down potential rugs. The risk is mostly taken by hedgers. Paytaca is expected to limit funds to what's needed for merchant onboarding, avoiding disproportionate $5 wrench attack risks to team members."
        },
        {
          "question": "What is Distrust chain of trust concept?",
          "answer": "Farooq reviews codebase and declares it good. Then Benjamin trusts Farooq and any code Farooq marked as reviewed, Benjamin also considers good. So if Simon trusts Benjamin, he automatically trusts Farooq too. Hierarchical web of trust for supply chain security."
        },
        {
          "question": "What was Kaspa state bloat attack and solution?",
          "answer": "Kaspa attacked by intentional state bloat. KIP-0009 introduced transaction mass function to limit state bloat. Previously had compute cost, added storage cost. BCH has generic per-byte fee (friction). See github.com/kaspanet/kips/blob/master/kip-0009.md"
        },
        {
          "question": "Why is not having OP_EVAL worse for security?",
          "answer": "People wanting eval functionality will emulate in convoluted ways harder to analyze than plain eval, with more footgunning opportunities. Same exotic uses already possible with introspection. Safety guardrails require convoluted methods to achieve simple things."
        },
        {
          "question": "Why was BCH targeted in npm supply chain attack?",
          "answer": "Scammers perceive BCH as big and important enough to attack. Good news in a way - no BCH wallets or services affected AFAIR. Jim: phishing mails comp'd so many projects past months becoming big problem. Sticky even patch versions of dev libraries now and run dev envs using docker-compose containers."
        }
      ]
    },
    {
      "name": "Testing & Debugging",
      "description": "Testing strategies, debugging tools, chipnet, testnet, and development workflows",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How do you run the mainnet-js REST API server?",
          "answer": "The mainnet-js REST API server setup is documented at mainnet.cash/tutorial/running-rest.html. By default it tries to use regtest, which requires running a local node. To use a public node instead for initial testing, you need to configure the network settings. For production, you should learn how to run a node and connect it to regtest or mainnet."
        },
        {
          "question": "How does testnet usage relate to formal proposal analysis?",
          "answer": "Have perfectly good testnet environment for formal analysis. With crowdfunding, wouldn't be hard to present findings in more academic way than chatting. Arguments better presented when accompanied by peer-reviewable hard data - sandbox testing feasible for proposals evaluation."
        },
        {
          "question": "How to use Electron Cash on chipnet?",
          "answer": "Start from command line with --chipnet flag. Example: electron-cash --chipnet. No GUI option - must use command line. Chipnet vs testnet4: chipnet for CHIP testing, testnet4 general purpose, chipnet upgrades 6mo before mainnet. Use chipnet by default for less issues with CashScript and other tools."
        },
        {
          "question": "What Blockbook fundraising proposal controversy?",
          "answer": "10 BCH for research codebase/database/build/test - Jeremy questioned if 15 minutes with Cursor. 5 BCH for QA - debate if bugs should fall under feature cost. Counter: understanding codebase can take week to build mental model, answering 'how to best architect this' takes time. AI iterations still needed."
        },
        {
          "question": "What are CashScript v0.11.0 major features?",
          "answer": "Debugging capabilities for new transaction builder - allows transaction builder to work with local testing/debugging using mocknet and inside Bitauth IDE. Half year in works with multiple pre-releases to iron out edge cases. Migration notes on docs website help deal with breaking changes."
        },
        {
          "question": "What is txvulcano and when is it useful?",
          "answer": "txvulcano (ships with Flowee) is tool for generating transactions - useful for new chains/regtest chains. Not as useful for newer chains since included wallet is too simplistic. Can fill blockchain with test transactions."
        },
        {
          "question": "What network should BCH contracts testing use?",
          "answer": "Use chipnet by default for less issues. Chipnet upgrades 6mo before mainnet. For time-based contracts use --regtest - can mine blocks in batches to regression test scripts in time automatically. mainnet-js, unspent.app, futurebitcoin.cash all use same docker-compose setup. Tom tests on mainnet or testnet4. Electron Cash: start with --chipnet flag."
        }
      ]
    },
    {
      "name": "Integration & Interoperability",
      "description": "Cross-platform integration, Nostr, other blockchain bridges, and external service connections",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How can BCH addresses be derived from Nostr pubkeys for tipping services?",
          "answer": "A server-side approach combines the Nostr pubkey with a secret to auto-generate a master BCH private key per pubkey. This master node then generates additional key pairs on demand for tracking content and tippers. This allows tracking UTXOs tied to each receiver's content, creating 'top lists' based on tips received, and posting signed Nostr reply messages showing the tip."
        },
        {
          "question": "How can BCH receive addresses be added to Nostr profile metadata?",
          "answer": "Nostr metadata already supports custom fields that can store BCH addresses. Add a 'bchAddr' or 'bitcoincash' tag to the profile's event 0 metadata JSON containing the BCH address. The infrastructure exists, but broad adoption requires Nostr clients to display and allow editing these fields. A coin-agnostic NIP using a 'tips' field with comma-separated addresses would enable multi-chain support."
        },
        {
          "question": "How to convert Nostr npub to BCH address?",
          "answer": "Nostr nsec are compatible with any secp256k1 chain. Draft NIP allows conversion of npub (addresses identifying Nostr users) to BCH address - enables direct payments and tipping between Nostr users with BCH. Example code: github.com/christroutner/nostr-sandbox/blob/master/16-npub-to-BCH-addr/npub-to-bch.js. Long term: wallets like Cashonize could add Nostr feature to social media directly and receive value on chain."
        },
        {
          "question": "How to generate BCH address from Nostr npub?",
          "answer": "Figured out how to generate BCH address directly from Nostr npub. Don't even need user to add BCH address to Kind 0 post. Can derive directly from npub and know they can spend using private key (nsec) used to generate npub. github.com/christroutner/nostr-sandbox/blob/master/16-npub-to-BCH-addr/npub-to-bch.js"
        },
        {
          "question": "Is Nostr protocol permissionless for BCH usage?",
          "answer": "Kallisti: You're not dependent on any BTC infrastructure at all and doesn't matter if they don't accept your NIPs. Just steal an event ID and do whatever you want lol it's just software. Nostr is permissionless."
        },
        {
          "question": "What are the adoption challenges for BCH integration in Nostr clients?",
          "answer": "Most native Android and iOS Nostr clients are managed by BTC maximalists unlikely to adopt BCH solutions. Beyond technical implementation, there are significant political and community hurdles. Building initial proof-of-concept custodial solutions that work across all clients can help demonstrate use cases before tackling the harder problem of convincing individual client developers to add wallet functionality."
        },
        {
          "question": "What are the challenges of integrating BCH wallets into Nostr clients?",
          "answer": "The main challenges are: 1) convincing Nostr client developers to add wallet library features when full wallet integration is a much larger project than typical clients, 2) receivers need to configure BCH addresses in advance before receiving funds, and 3) achieving adoption across multiple popular clients. A simpler approach uses custodial third-party services requiring minimal client-side integration work, similar to Lightning's model in Nostr."
        },
        {
          "question": "What are the tradeoffs between custodial and non-custodial BCH tipping on Nostr?",
          "answer": "Custodial solutions are simpler to implement and work out-of-the-box with all existing Nostr clients with minimal integration (just adding a link per note). Non-custodial solutions require extensive work integrating wallet functionality and node connectivity into multiple Nostr clients. While custodial approaches sacrifice trustlessness, they enable testing use cases and building userbase before tackling complex non-custodial implementations."
        },
        {
          "question": "What is Nostr Pumps and how does it integrate BCH with Nostr?",
          "answer": "Nostr Pumps (pump.coinmachin.es and pumpstr.coinmachin.es) is the first Nostr client with BCH tipping embedded, including a developer's guide for integration. It supports nsec/secret key login for mobile phones (iOS/Android) until better Nostr plugins are available. The client enables BCH-based 'pumps' (tips) tied to Nostr notes, testing BCH adoption within the Nostr community."
        },
        {
          "question": "What is SLP DEX Nostr integration roadmap?",
          "answer": "SLP DEX (dex.psfoundation.info) is BCH wallet with Nostr integrated. Has basic social media functions, recently added Likes. Figured out how to 'Like' SLP tokens and working on integrating that. Next will let people post directly on tokens - nice merging of BCH, Tokens, and Nostr technology."
        },
        {
          "question": "Why can't Nostr keypairs be used directly with BCH transactions?",
          "answer": "Nostr uses BIP-340 BTC-style Schnorr signatures while BCH uses a different keypair scheme. The same private key generates different public keys in each system. If you send BCH to a Nostr pubkey address, the recipient cannot spend it using their Nostr private key because the keypair derivation is incompatible between the two systems."
        }
      ]
    },
    {
      "name": "Use Cases & Applications",
      "description": "Real-world applications, use case examples, domain names (BitCANN), fundraising, and practical implementations",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How do time-locked vaults protect users from mistakes?",
          "answer": "Jonathan: Smart educated people sometimes make mistakes, but if they set up time-locked vault when in good state of mind and have time to be careful, it protects them in future when they are of poor state of mind, under stress or other influences."
        },
        {
          "question": "How do transaction dependency graphs work with read-only inputs?",
          "answer": "Dependencies remain a DAG (Directed Acyclic Graph). Spending output A to create B, C, D, E, then spending those is equivalent to referencing A four times read-only to create the same outputs. In either case, if A gets removed (e.g., reorg), the entire descendant graph must be removed. Read-only inputs save the intermediate transaction creating copies but maintain the same dependency invalidation semantics."
        },
        {
          "question": "What are common JSX syntax restrictions that cause React errors?",
          "answer": "HTML nesting rules apply in JSX. A common error is placing block elements like <ul> inside inline elements like <p> - this is invalid HTML and React will throw 'Hydration failed' errors. Replace <p> with <div> when nesting lists, or remove the <p> wrapper entirely. JSX enforces stricter HTML validity than browsers which may render invalid markup."
        },
        {
          "question": "What domain registration issues affect BCH ecosystem?",
          "answer": "Bitcoinfees.cash expired on namecheap (though renewed later). Domain squatters use services like sedo.com with high minimum bids. Dot .io domains aren't awesome due to colonial history (British Indian Ocean Territory). Need to track critical ecosystem domains to prevent loss."
        },
        {
          "question": "What is Ethereum blind signing problem?",
          "answer": "J Master Pig: In Ethereum, users can't really see exact functions being executed, they are blind signing and just trusting address and domain unless they do serious deep dive. Signing is last line of defense, but if not structurally clear what they're signing, hard to catch malicious logic."
        },
        {
          "question": "What is current state of NIP process?",
          "answer": "Tom/Chris: Fiatjaf posted about changing NIP process because it's basically frozen and dead. Whole NIP process moving to 'everything is a draft, nothing is official'. NIP28 gets hate, most mirrors don't include it, but it works and people built software around it."
        },
        {
          "question": "What is the 80/20 rule in software development?",
          "answer": "The Pareto Principle in software states that 80% of a program can be written in 20% of the allocated time. The remaining 20% of features and bug fixes consume 80% of development time. This explains why initial implementations are fast but polish and edge cases take disproportionately longer. It's why 'don't let perfect be the enemy of good' is a common engineering philosophy."
        },
        {
          "question": "What is the counter-argument favoring faster blocks now?",
          "answer": "Having more robust futureproofed template encourages devs. Chain with less issues used by more people is encouraging. This is great time to do it - before/while people build, not after massive ecosystems exist. Fixed time spent, reap benefits forever - infinite ROI."
        }
      ]
    },
    {
      "name": "Documentation & Learning",
      "description": "Educational resources, documentation, tutorials, community learning, and developer onboarding",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How should documentation be formatted for LLM RAG databases?",
          "answer": "Ideal size is 2-3 paragraphs for documents in RAG database. Can't just add single large document or code base - must break up into small chunks so LLM can retrieve 'reminder snippets'. Use AI to break large docs into multiple markdown docs as pre-processing step. See github.com/christroutner/ben-training-data for examples."
        },
        {
          "question": "What are the BCH Devs & Builders chat ground rules?",
          "answer": "High signal low noise chat focused on BCH development. Constructive criticism welcome. When discussion gets long, consider if hundreds want to read it - take elsewhere or agree to disagree. No beating dead horses. Learn to DNE (Do Not Engage) if someone engages in bad faith."
        },
        {
          "question": "What are the benefits and risks of using AI tools like Grok for technical documentation?",
          "answer": "Grok can be useful for polishing documentation and enabling shared context through conversation links - anyone can continue from an already-set-up context. However, you must check everything the AI produces, as LLMs hallucinate when they don't know something. The new Grok 3 generation is reportedly more impressive, but complete removal of hallucinations is impossible since LLMs cannot be debugged like normal code."
        },
        {
          "question": "Why is decentralized educational content better than one centralized hub?",
          "answer": "Multiple educational sites provide redundancy and reach more people. BTC and ETH don't have single giant educational websites - large communities naturally produce several perspectives on the same topics. A group of interlinked sites allows exploration as the web was designed. Also, starting with 'educational website' is an easy entry point that often leads developers to more complex projects."
        }
      ]
    },
    {
      "name": "Community & Governance",
      "description": "Community processes, funding mechanisms, Flipstarter, governance, and ecosystem coordination",
      "source": "BCH Devs & Builders",
      "faqs": [
        {
          "question": "How does community DAO funding work with BCH?",
          "answer": "BCA: Main problem with DAOs was they invite intermediaries but there's a way to hold dao accountable. Everyone's payment into dao is tracked, when dao pays out it takes same % from everyone's original payment. If not happy with what dao funds anymore - can pull out remainder of your money. Prevents money trapping."
        },
        {
          "question": "What alternative approaches exist for managing chat quality?",
          "answer": "Could require BCH bond in suitable/escalating amount which gets forfeit to community if continue to receive pushback (via regular vote). Could add cap of number/length of posts/words per time unit for people unable to observe social norms or obsessive about trivial nonsense."
        },
        {
          "question": "What are OpenCashDAO npm packages?",
          "answer": "Initial unstable versions: @opencashdao/contracts (github.com/OpenCashDAO/opencashdao-contracts) and @opencashdao/core (github.com/OpenCashDAO/opencashdao-core). Available on npm. Repos open for contributions. Telegram: t.me/opencashdao"
        },
        {
          "question": "What are tax implications of Flipstarter vs NFT fundraising?",
          "answer": "Flipstarter contributions are gifts (tax hassle, gift tax rules apply in US). Data analysis companies don't identify Flipstarter TXs automatically. Buying NFT for 5-10 BCH much less hassle than Flipstarter. UK example: can only gift 3000/year before affecting inheritance. Buying NFT for 10k doesn't trigger this - if sell for 5 it's cap gains loss."
        },
        {
          "question": "What is OpenCashDAO and what features does it provide?",
          "answer": "OpenCashDAO (bitcoincashresearch.org/t/opencashdao/1521, github.com/OpenCashDAO/contracts) is a DAO template with voting, proposals, and upgradable contract system. The base design pattern enables many applications like BitCANN. It demonstrates advanced covenant patterns for decentralized governance on BCH. Discussion group: t.me/opencashdao."
        },
        {
          "question": "What legal issues affect token distribution in crowdfunding?",
          "answer": "Creating tokens as part of campaign's claim TX easily done - on list for new cashstarter contract after bliss. However, putting limiter on collecting funding (target goal) might still classify as crowdfund bringing legal issues. Canada has crowdfunding-specific laws assuming custodial control. Worst-case: same regulation requirements as major bank."
        },
        {
          "question": "Why is concern trolling problematic in development chats?",
          "answer": "Concern trollers prolific in low moderation groups. 1 poorly adjusted person can cause grief for 10,000 others. Community must decide: change global reserve currency, or protect feelings of every socially maladjusted person. Exceptional cases must be treated exceptionally."
        },
        {
          "question": "What is the moderation philosophy for technical communities?",
          "answer": "Prefer not to heavily police chat - self-regulate and move off-topic discussions elsewhere. However, repeat offenders who drag chat down will be muted/banned. Generally had great signal-to-noise ratio with people keeping things professional and focused."
        }
      ]
    },
    {
      "name": "CashTokens Fundamentals",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is the fundamental difference between CashTokens and SLP tokens?",
          "answer": "CashTokens are part of the UTXO data model - they're native consensus-layer tokens embedded directly in transaction outputs. SLP tokens are an off-chain data convention that uses OP_RETURN metadata interpreted by indexers. CashTokens have native validation by all nodes, while SLP requires specialized indexers to track validity."
        },
        {
          "question": "How do CashTokens solve SLP's indexing problem?",
          "answer": "CashTokens fix the major SLP indexing problem by being consensus-validated at the UTXO level. SLP required specialized indexers to track validity across transactions, creating reliability issues. CashTokens are native to the UTXO data model with on-chain validation. However, CashTokens are currently harder to work with for developers than SLP was, as SLP had extensive tooling developed over time."
        },
        {
          "question": "What is the relationship between category IDs and fungible/non-fungible tokens?",
          "answer": "Category IDs are the parent of any combination of fungible and non-fungible tokens. A single category can contain both FTs and NFTs simultaneously. Common developer mistake: not understanding that category ID is the umbrella identifier, and different token types (FT, NFT with different commitments) can coexist under one category. The category ID comes from the genesis transaction's VOUT 0."
        },
        {
          "question": "Can you have both an NFT and fungible tokens in the same UTXO?",
          "answer": "Yes, you can have both an NFT and fungible tokens on the same UTXO as long as they share the same token category (tokenId). Each UTXO can hold exactly 1 token category, but that category can contain both NFT and FT components simultaneously. Example implementations include Popcorn and various covenant patterns."
        },
        {
          "question": "What is required for CashToken genesis transactions?",
          "answer": "Token genesis requires a VOUT 0 output. The new tokens will have tokenId equal to the TxId of that Vout0 UTXO. This creates the category ID that all tokens/NFTs in that category will share. See spec graphic at cashtokens.org/docs/spec/chip/#token-categories. The genesis transaction is the only time new token categories can be created."
        },
        {
          "question": "Can CashToken genesis transactions send to multiple addresses?",
          "answer": "Yes, CashToken genesis transactions can send newly minted tokens to multiple different addresses in a single transaction. This allows distributing the initial token supply across multiple recipients atomically during genesis."
        },
        {
          "question": "What is the proposed naming convention for token atomic units on BCH?",
          "answer": "The proposed term is 'tau' (plural 'taus'), derived from 'token-atomic-unit' which happens to be a Greek letter. For example: '100 taus of musd' equals 1.00 MUSD. The community agreed NOT to use 'sats' as the term to differentiate from Bitcoin terminology."
        },
        {
          "question": "Where are CashToken supply concepts (total, circulating, reserve) officially defined?",
          "answer": "Defined in the CashTokens CHIP at cashtokens.org/docs/spec/chip#fungible-token-supply-definitions. Total supply is all minted tokens, reserve supply is held in AuthUTXO (not circulating), circulating supply is total minus reserves. Reserves must be in the single AuthUTXO to count properly, not just any UTXO at authguard address."
        },
        {
          "question": "How do BCH and CashTokens on the same UTXO prevent state bloat?",
          "answer": "Having BCH and CashTokens on the same UTXO elegantly solves UTXO bloat - the BCH locked with the state acts as the ongoing payment/storage fee. This economic mechanism prevents spam by requiring value commitment. Converting all sats to tokens was considered but rejected because contracts need to hold both state (tokens) and value (BCH) simultaneously for this bloat-prevention mechanism."
        },
        {
          "question": "Why can't BCH be converted into a CashToken to unify sats and tokens?",
          "answer": "It's a crucially important feature for contracts to hold state (CashTokens) and BCH value simultaneously. Removing this would break the ability to create stateful contracts with native value, crippling covenant functionality. Contracts wanting to abstract BCH can already use Wrapped BCH (wrapped.cash) for token-only scenarios like token-to-token DEXes."
        },
        {
          "question": "Can CashToken NFTs contain arbitrary on-chain data or must they reference external storage?",
          "answer": "NFTs can contain up to 40 bytes of arbitrary data on-chain in the commitment field. This data is part of the UTXO and doesn't require IPFS/external storage. For larger data (metadata, images, etc.), use BCMR which references external storage. The 40-byte commitment can store small data directly (hashes, identifiers, compact state) or point to larger external data."
        },
        {
          "question": "Why does Moria USD show as 'is_nft: true' when it's a fungible token?",
          "answer": "Moria USD (MUSD) category contains both fungible tokens and NFTs. MUSD itself is the fungible token, but the category also has NFTs used internally by the loan contract to track state (positions, collateral, etc.). Indexers detecting any NFT in a category may flag 'is_nft: true' even though the primary token is fungible. One category can have both FTs and NFTs."
        }
      ]
    },
    {
      "name": "Trading & DEX",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is the difference between PSBT trading approach and covenant-based trading?",
          "answer": "PSBT (Partially Signed Bitcoin Transaction) trading is an off-chain offer that never gets on chain unless taken by someone. The maker creates an imbalanced transaction that the taker completes by adding inputs and outputs to balance it. Trades are essentially coinjoins. This differs from covenant approaches where the contract logic is enforced on-chain. BCH can implement PSBT-style trades using SIGHASH_SINGLE."
        },
        {
          "question": "What is CatDex and how does it work?",
          "answer": "CatDex is a Token Category Authorized Decentralized Exchange. It uses an authorization NFT category (authCat) to control trading. Makers create NFTs with commitment data encoding their offers and send them with assets to a contract address. A separate key-value index contract enables aggregation and discoverability across multiple DEX instances. Makers pay to publish their DEX as a value on the token's key, allowing anyone to query and discover available trades."
        },
        {
          "question": "How does CatDex discovery work through the key-value index contract?",
          "answer": "To make a DEX discoverable, publish it to the key-value index by sending an NFT with protocol identifier and authCat ID as commitment to contract index(bytes tokenCategory). To find all MUSD exchanges: query all UTXOs at the index address for that token category, parse for NFTs containing authCat IDs, then query contract CatDex(bytes32 authCat, bytes32 tokenId) addresses. Anti-spam: increase listing cost to reduce fake/unfunded exchanges."
        },
        {
          "question": "What libraries exist for interacting with Cauldron DEX contracts programmatically?",
          "answer": "Two independent libraries for on-chain contract interaction: vegabch (https://github.com/hosseinzoda/vegabch) and Cauldron_Swap_Test (https://github.com/mr-zwets/Cauldron_Swap_Test). These enable programmatic access to Cauldron DEX without using the website, supporting CLI/API integration for automated trading and liquidity management."
        },
        {
          "question": "How do you use vegabch CLI to interact with Cauldron DEX?",
          "answer": "Architecture: daemon/client RPC model. 1) Generate config with `daemon:gen-rpcauth`, 2) Run daemon: `vegabch daemon:run --config server-config.json`, 3) Set client config: `export VEGABCH_CONFIG=/path/to/client-config.json`, 4) Send RPC commands to daemon. Example configs at github.com/hosseinzoda/vegabch/tree/beta/share/examples. Wallet generation requires derivation_path parameter."
        },
        {
          "question": "What is the vegabch CLI workflow for executing Cauldron DEX trades?",
          "answer": "Two-step process: 1) `cauldron:construct-trade --target-demand --decimal-amounts BCH MUSD 1.00 trade.json` constructs trade showing rate/fee/supply/demand (fee is included, don't deduct), 2) `cauldron:fund-trade trade.json --broadcast` funds, builds & broadcasts. Set `VEGABCH_CONFIG=client-config.json` environment variable. Run daemon separately with daemon-config.json, send commands with client-config.json."
        },
        {
          "question": "What causes txn-mempool-conflict errors when trading on Cauldron?",
          "answer": "Two causes: 1) Someone traded before you pushed your transaction (pool state changed), 2) Broadcasting same transaction twice. Each constructed trade is only valid for building one transaction. If someone trades before you, must construct a fresh trade with updated pool state. This is inherent to on-chain AMM racing - first valid transaction wins."
        },
        {
          "question": "What's the current state of order types on Cauldron DEX?",
          "answer": "Cauldron currently only supports AMM pool trading (swap against liquidity pools). Limit orders are not yet implemented. All trades execute immediately at current pool rate. For deeper liquidity, use MUSD (MUSDv0 is retired). The construct-trade command calculates optimal routing across available pools."
        },
        {
          "question": "How do you list a new token on Cauldron DEX?",
          "answer": "Self-listing: Connect wallet and create liquidity pool for the token. Verification: Contact Cauldron team to get token verified/whitelisted. Documentation at docs.riftenlabs.com/cauldron/claim/. May be possible to list directly via script but no easy UI helper currently. Verification requires team approval for quality/scam filtering."
        },
        {
          "question": "How do flash loans work on BCH with CashTokens?",
          "answer": "Flash loans are implemented using BCH covenants and CashTokens. Implementation available at github.com/kiok46/flash-loans. Flash loans enable borrowing tokens within a single transaction with the requirement that they're returned (plus fee) before transaction completion, otherwise the transaction is invalid. Enabled by BCH's covenant capabilities allowing within-transaction state validation."
        },
        {
          "question": "What cross-chain atomic swap implementations exist for BCH?",
          "answer": "Three implementations: 1) cross-chain-swap-ves (general framework), 2) AxeSwap (BCH-XMR swaps), 3) BasicSwapDEX (BCH recently added). Challenge: Hard to get volume - atomic swaps have poor UX compared to alternatives. For better convenience and liquidity, ThorChain-like approach needed with liquidity pools rather than direct peer-to-peer atomic swaps. Current atomic swap UX is 'shitty' compared to pooled liquidity."
        },
        {
          "question": "Why don't atomic swaps gain more adoption despite being trustless?",
          "answer": "Atomic swaps have terrible UX compared to pooled liquidity solutions. They require both parties to be online simultaneously, matching exact amounts, and dealing with timelock complexities. Everything else (ThorChain, centralized exchanges) is 'way more convenient' despite trust tradeoffs. To compete, BCH would need a ThorChain-like dedicated project with liquidity pools, not just atomic swap infrastructure."
        }
      ]
    },
    {
      "name": "Smart Contracts & Covenants",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "Can NFTs have built-in royalties on BCH that enforce creator fees on every resale?",
          "answer": "Yes, BCH smart contracts can enforce royalties on NFT resales. The fee receiver can be a pay-to-NFT address, making the payout rights themselves tradeable. Use cases include concert tickets where resale is price-limited and the original creator gets a cut of every sale. The contract can restrict resale price and automatically send a percentage to the creator on each trade."
        },
        {
          "question": "How does the single-UTXO auction pattern work?",
          "answer": "Each bid pays out the previous highest bid, keeping the auction in a single UTXO until the item is sold. This makes the under-bidder whole to bid again. Can be enhanced with incentives where part of the new bid pays the previous bidder to encourage early bidding, eliminating the 'wait until last second' problem. Improves price discovery as people bid on underpriced items to collect the next bidder's fee."
        },
        {
          "question": "What is the Unspent protocol and how do perpetuity/annuity contracts work?",
          "answer": "Unspent is a PUSH-based recurring payment system where recipients are paid automatically without wallet interaction or signing. Perpetuity and annuity contracts create recurring payments already working in production. They represent ultimate commitment - transparent, on-chain, and cannot be redirected once created. You allocate a budget that flows over time. Ideal for contractor payments as it stabilizes spending and working behaviors."
        },
        {
          "question": "How do unspent protocol contracts execute and terminate?",
          "answer": "Unspent perpetuity and annuity contracts cannot be modified once created and automatically stop when the balance is depleted. They use the 'S' selector in the unspent protocol, allowing payments to be picked up and executed as anyone-can-spend MEV. The protocol enables Hodl, Subscriptions, and Wills through phi v3 timelocking and token-aware contracts."
        },
        {
          "question": "What are the technical challenges of USD-denominated recurring payment contracts?",
          "answer": "Fiat-denominated contracts require oracle data and face two key risks: if the contract extends past oracle lifetime it must be liquidated, and if BCH price increases significantly the installment becomes trivial and can't draw down principal properly. BCH-denominated perpetuity/annuity contracts avoid this by valuing BCH itself. A cancellable BCH-denominated subscription is considered an easy upgrade to existing contracts."
        },
        {
          "question": "What is the recommended approach to building recurring payment dapps?",
          "answer": "It's easier to develop many similar dapps within one protocol rather than one-offs. The key challenge is removing friction for adoption - while dapps have existed for half a decade with on-chain usage, making something that grows requires excellent UX. The vision includes wallet integration where users can subscribe to creators with customizable amounts and payment schedules."
        },
        {
          "question": "How do time-locked CashToken transfers work?",
          "answer": "Unspent V3 (currently being coded) will support time-locked transfers of both BCH and CashTokens. Important: tokens don't move automatically - the party locking the coins/tokens must publish a job that someone else can call to execute the transfer. This is timelocking with manual execution, not fully autonomous transfers."
        },
        {
          "question": "How does the EIP-2535 Diamond pattern adapt to BCH smart contracts?",
          "answer": "Similar to Ethereum's Diamond/Multi-Facet Proxy pattern, BCH contracts can use a plugin/facet architecture where auxiliary contracts provide 'code' while the main contract maintains 'storage/utxo'. This enables: pluggable systems (e.g., Lease Contract plugging into Domain system), borrowing against tokens, multi-party ownership, upgradable contract systems, and chainlink-like structures. All facets are just code providers to the core storage contract."
        },
        {
          "question": "What is the BitCANN domain registration system architecture?",
          "answer": "BitCANN is a complete decentralized domain system with auctions, expiry, transferability, record updating, and multiple TLDs. One authchain equals one TLD, with external convention determining which instance is authoritative. It's asynchronous (doesn't keep all state in one UTXO merkle tree), enforces charset validation, and uses guard contracts with incentive structures. Contract code is laid out to mirror transaction structure (preamble, inputs, outputs)."
        },
        {
          "question": "What's the difference between pre-native and native introspection in BCH contracts?",
          "answer": "Last-will and some older contracts use introspection from before 'native introspection' became available. These older designs are no longer optimal and tooling isn't cross-compatible between Spedn and CashScript. Simpler contracts like 2-of-3 multisig don't require introspection at all and make good candidates for WalletConnect apps."
        },
        {
          "question": "Why can't smart contracts measure coin-days for UTXOs not held by the contract?",
          "answer": "Contracts can only introspect their own inputs and cannot measure the age of UTXOs that weren't previously locked by the same contract. This prevents implementing rewards based on age  value for arbitrary UTXOs. The blockchain doesn't expose UTXO age/block height to script, making coin-days calculation impossible for external UTXOs without an oracle."
        },
        {
          "question": "What is BCHess and how does on-chain chess work with BCH covenants?",
          "answer": "BCHess is covenant-based chess implementation using CashTokens for game state. Older version available at github.com/SayoshiNakamario/BCHess with most basic logic. Presented at Bliss'25 - demonstrates complex game state management on-chain using covenant introspection. Updated version coming later with bug fixes and improvements."
        }
      ]
    },
    {
      "name": "Infrastructure & Indexing",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What infrastructure is needed beyond a full BCH node to build a wallet?",
          "answer": "A full node alone is insufficient for wallet creation. You need an indexer like Fulcrum to get address balances. However, Fulcrum currently doesn't work as a Token Indexer - it's anchored around wallet addresses. For general-purpose token queries (finding all addresses containing a specific category ID), use Chaingraph instead. Fulcrum can view tokens on addresses you already know about."
        },
        {
          "question": "When should you use Fulcrum vs Chaingraph for CashToken applications?",
          "answer": "Use Fulcrum for wallet-centric applications - it's perfect for querying balances and tokens on known addresses. Use Chaingraph for token-centric applications - it enables looking up a category ID to find all addresses/UTXOs containing those tokens. Fulcrum is address-indexed, Chaingraph is token-indexed. For wallet creation with known addresses, Fulcrum works perfectly."
        },
        {
          "question": "Do you need an indexer to use CashTokens with your own BCHN node?",
          "answer": "For basic CashToken functionality with libraries like mainnet.cash-js, you can connect directly to your BCHN node without a dedicated indexer. However, for advanced queries (finding all addresses holding a token, tracking NFT locations, etc.), you'll need an indexer like Fulcrum or Chaingraph. Simple send/receive works node-only."
        },
        {
          "question": "Why is BlockBook indexer important for CashToken adoption?",
          "answer": "BlockBook is a multicoin indexer (written in Go, maintained by Trezor) used by Edge wallet, Trust wallet (Binance), and possibly Exodus. Adding CashToken support to BlockBook would enable: CashToken support in multiple major wallets, Trezor hardware wallet support, and serve as public-good infrastructure. Success depends on convincing maintainers that CashTokens are native BCH features and minimizing API changes. Could be flipstarter funded."
        },
        {
          "question": "What BCMR indexers and explorers are available for CashTokens?",
          "answer": "Public resources: 1) Paytaca indexer (bcmr.paytaca.com) - indexes chain-resolved BCMR registries, 2) TokenExplorer.cash - on-chain resolution metadata lookup, 3) BlockBook explorer (blockbook.pat.mn/token/[categoryId]) - added to Cashonize, 4) Static registries: otr.cash (outdated, missing MUSD), badgers.cash, futurebitcoin.cash. Opportunity exists for better partitioned-per-category static registry (OpenTokenRegistry issue #9)."
        },
        {
          "question": "What is the OP_RETURN scanner utility and how does it work?",
          "answer": "The OP_RETURN scanner is a tool that finds all occurrences of specific OP_RETURN markers on-chain by scanning for protocol identifiers like 'BCMR' or LOKAD IDs. For example, searching for 'BCMR' returns 3417 transaction IDs. It's useful for discovering all instances of a particular protocol or smart contract app, as markers are a recommended place to store contract details."
        },
        {
          "question": "How can you scale mainnet-js when using your own Fulcrum indexer?",
          "answer": "mainnet-js requires websocket connections directly to Fulcrum, unlike bch-js which uses REST (enabling AWS queue routing). Solution: use fulcrum-http (github.com/mainnet-pat/fulcrum-http) - provides HTTP wrapper for Fulcrum, enabling load balancing and queue-based scaling architectures similar to bch-js REST approach."
        }
      ]
    },
    {
      "name": "Wallet Development",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "How can a wallet hold only CashTokens with zero BCH for fees?",
          "answer": "Three approaches: 1) Post Office pattern - centralized service adds fee input in exchange for tokens, 2) Cauldron pool swap - craft transaction that swaps tokens for just enough BCH to cover fee, then makes payment, 3) Combined tx - single transaction that performs Cauldron swap (picking up only txfee from pool) while splitting CashToken into payment output and change output. All avoid requiring BCH in the wallet."
        },
        {
          "question": "How feasible is building a token-only wallet that pays fees via Cauldron swaps?",
          "answer": "Very feasible - estimated one day of work. Create a wallet that exposes a single token (e.g., MUSD) and transparently pays transaction fees through Cauldron pool swaps. Can be implemented as an SDK that other platforms can use. The transaction combines a Cauldron swap (picking up just enough BCH for txfee from pool) with splitting the CashToken into payment output and change output."
        },
        {
          "question": "What is the recommended fee management strategy for token-only wallets?",
          "answer": "Wallets should maintain a fee stash of approximately 10 UTXOs of 800 sats each, managed behind-the-scenes. When user sends tokens, wallet automatically extends the transaction to swap tokens for a new 800sat output via DEX. Critically, make the DEX swap a 0-conf child rather than parent to avoid DSP (Double Spend Proof) coverage issues. Automatically replenish the BCH stash when depleted, so users don't manually manage the BCH pot."
        },
        {
          "question": "What are the privacy implications of fee management strategies for CashToken wallets?",
          "answer": "Reusable separate BCH UTXOs for fees destroy privacy through address reuse and linkability. Three privacy-preserving alternatives: 1) Single-use fee UTXOs (new UTXO each time), 2) Preload CashToken UTXOs with sats for spending during CashFusion process, 3) Just-in-time swap trick (DEX swap as 0-conf child). Also: mobile wallet push notifications travel through Google, exposing all deposits/payments - should default to disabled."
        },
        {
          "question": "What are the main development tooling options for CashTokens across different languages?",
          "answer": "JavaScript developers use mainnet-js and CashScript (or libauth directly for lower-level operations). Python developers can use bitcash library. For CashScript, this includes contract compilation, transaction building, and WalletConnect integration. Libauth provides the foundational primitives that other libraries build on."
        },
        {
          "question": "How do you enable CashToken support in Electron Cash?",
          "answer": "Use Electron Cash (regular), not Electron Cash SLP (which is for SLP tokens only). Enable CashTokens tab via View menu - it's hidden by default. Better wallets exist for CashTokens (Selene, Cashonize, Paytaca) but they don't necessarily support testnets. For testnet work, Electron Cash is reliable option once tabs enabled."
        },
        {
          "question": "Which wallets support WalletConnect on mobile devices?",
          "answer": "Paytaca and Cashonize support WalletConnect on mobile. For same-device connections, press QR code icon below close button to copy/paste WalletConnect info. Electron Cash doesn't have native WalletConnect functionality - the plugin is desktop-only. This limits Electron Cash's ability to interact with WalletConnect-based dapps on mobile."
        },
        {
          "question": "What are the security concerns with WalletConnect integration in BCH dapps?",
          "answer": "WalletConnect is just a transport layer for communication between dapp and wallet. Primary security concern is adding a middleman that can censor or know IP info - not cryptographic vulnerabilities. CashScript v0.11.1 added native WalletConnect support via TransactionBuilder method that generates WC transaction objects for signing. Overall security risk is minimal beyond typical relay/transport concerns."
        },
        {
          "question": "What breaking changes occurred in WalletConnect v2.21.0 affecting BCH wallets?",
          "answer": "@walletconnect/utils@2.21.0 deprecated `requiredNamespaces` - values are now automatically assigned to `optionalNamespaces` instead. This breaks BCH wallet implementations using requiredNamespaces. Warning: Don't upgrade @reown/walletkit or @walletconnect/core without testing. Fix: Use optionalNamespaces or pin to older versions (see bch-hodl-dapp package.json). Cashonize fix: github.com/cashonize/cashonize-wallet/commit/696daa49."
        }
      ]
    },
    {
      "name": "BCMR & Metadata",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is a BCMR authchain and why does 'Invalid authchain transaction' error occur?",
          "answer": "An authchain is a series of spends from a vout 0 UTXO, forming a zeroth descendant transaction chain. The error 'does not spend 0th output of previous transaction' occurs when providing a transaction without a vout 0 UTXO. To fetch BCMR metadata, use the token's categoryId as argument, NOT the transfer transaction ID. Each link in the authchain must spend output 0 from the previous transaction."
        },
        {
          "question": "How are CashToken decimal places determined and what happens without BCMR data?",
          "answer": "Decimals are NOT on-chain - they're determined by the 'decimal' field in BCMR (Bitcoin Cash Metadata Registry), an off-chain registry. Without BCMR data, wallets and explorers display raw integer amounts and category ID only. Example: 1000 tokens with 2 decimals shows as 100000 in BCMR-unaware wallets. This differs from ERC-20 where decimals are on-chain (Ethereum uses 18 decimals by design). Electron Cash supports BCMR lookup, with easier/automatic lookup coming."
        },
        {
          "question": "Can token decimals cause confusion when sending CashTokens between different wallets?",
          "answer": "Yes - if sender uses BCMR-aware wallet (like CashTokens Studio) and receiver uses BCMR-unaware wallet (older Electron Cash), decimal display differs dramatically. Sender sees 1000 tokens (with 2 decimals), receiver sees 100000 (raw amount). This can enable disputes where sender claims they sent more than received. Base-layer always shows ID and raw value correctly - only decimal presentation differs based on BCMR access."
        },
        {
          "question": "Can BCMR authchain owners manipulate token decimals to scam users?",
          "answer": "Yes - token authors have extensive power by design. Attacker with Auth access could change 500.00 to 50000 by removing 2 decimals. Protections: 1) Verified token lists (Cauldron integration) would delist scamming tokens, 2) Only trust issuers with strong reputations who would destroy themselves scamming, 3) Consider DAO governance for decentralized verified tokens. This area needs investigation and coordination - Selene doesn't adequately show verified/unverified status."
        },
        {
          "question": "Why do CashToken authors have the power to update logos and metadata?",
          "answer": "Updatable metadata is necessary for legitimate use cases: improving image quality, rebranding, or annual events like BLISS conference. Token authors have extensive control by design - this is intentional, not a bug. The solution is social: only trust tokens from issuers with strong reputations who would face severe consequences from abuse. Immutable metadata would prevent legitimate updates."
        },
        {
          "question": "What are the available public BCMR registries?",
          "answer": "Public registries: otr.cash, badgers.cash, futurebitcoin.cash, and wrapped.cash (location uncertain). Paytaca operates a public indexer that indexes chain-resolved BCMR registries. No comprehensive registry exists that captures all tokens - many appear to be private/project-specific. Chain resolution via DNS and app-embedded metadata provide alternatives to centralized registries."
        },
        {
          "question": "Why do some wallets not display SVG icons from BCMR metadata?",
          "answer": "Inconsistent SVG support across wallets despite BCMR spec recommending 'data:image/svg+xml,' URI format. Electron Cash and Selene don't load SVG icons, while Cashonize and salemkode explorer do. Implementation-dependent - wallets must explicitly add SVG rendering support. Test compatibility with BPT tokens on tapswap."
        },
        {
          "question": "Can IPFS URLs be used for BCMR metadata, or must it be HTTPS?",
          "answer": "HTTPS requirement is Electron Cash-specific ('only EC thing'), not a spec-wide mandate. Other wallets and tools may support IPFS or other URI schemes. The BCMR spec itself is flexible, but wallet implementation determines what protocols work. Check specific wallet/tool documentation for supported URI schemes."
        },
        {
          "question": "Can BCMR icons be embedded directly in the URI instead of using IPFS?",
          "answer": "Yes - BCMR supports 'data:image/svg+xml,' URIs for embedding SVG icons directly in metadata without IPFS. Example: BPTS token has SVG embedded in BCMR URI, eliminating external dependency. This improves reliability (no IPFS gateway failures) but increases BCMR file size. Trade-off between decentralization/persistence (IPFS) vs. inline embedding."
        },
        {
          "question": "What is the 'set it and forget it' metadata scheme for CashTokens?",
          "answer": "Proposed approach for permanent metadata storage without constant IPFS pinning requirements. Instead of IPFS (requires ongoing pinning), use permanent storage solutions where data is uploaded once and persists indefinitely. Reduces operational hassle for NFT/token projects. Alternative to traditional IPFS: Arweave, data URIs, or other permanent storage. Makes token metadata maintenance-free."
        }
      ]
    },
    {
      "name": "Network & Testing",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "Why can't you just swap address prefixes between mainnet and testnet?",
          "answer": "The prefix is included in the address checksum, so you cannot simply replace 'bitcoincash:' with 'bchtest:' - the checksum will be invalid. While lockscripts are identical across networks, addresses differ due to checksum recalculation. Use tools like stack.xo.cash/tools/primitives.html#address to properly translate addresses between networks (mainnet, testnet, chipnet)."
        },
        {
          "question": "How do you convert a regular BCH address to a CashToken-capable address?",
          "answer": "Use kth.cash/wasm.html tool to convert regular BCH addresses to CashToken receive addresses. Token addresses indicate support for tokens - ideally all addresses become token addresses eventually. Addresses encode support via checksum/format but underlying lockscript is identical. Tool enables sending tokens to legacy address format by converting to token-aware equivalent."
        },
        {
          "question": "How do you enable testnet4 or chipnet on different BCH wallets?",
          "answer": "Electron Cash: Start with `--chipnet` or `--testnet4` command-line flags. Selene: Tap the logo 6 times rapidly on the credits screen (settings  green version button) to access debug menu, then select testnet4. Paytaca and Cashonize both support chipnet. For development, CashScript Playground defaults to mocknet which is recommended over mainnet testing."
        },
        {
          "question": "What are the methods for broadcasting raw BCH transactions without a public RPC node?",
          "answer": "Four methods: 1) Connect directly to BCH P2P network (language-dependent, Bash scripts possible with known node IP), 2) Use Electrum protocol's blockchain.transaction.broadcast method via electrum-cash NPM library, 3) Use Electron-Cash GUI (Tools > Load transaction > From text), 4) Write custom P2P network script. No widely available public RPC nodes exist for sendrawtransaction."
        },
        {
          "question": "How can you look up a P2SH (Pay-to-Script-Hash) address on BCH block explorers?",
          "answer": "Use this bash script to generate a 3xpl/blockchair URL for any P2S address: `hex=0xAC; echo \"https://3xpl.com/bitcoin-cash/address/script-\"$(echo -n $hex | sed -s 's/^0x//' | tr 'A-F' 'a-f' | sha256sum | cut -b 1-32)`. Replace 0xAC with your script hex. This hashes the script and formats it for block explorer lookups."
        }
      ]
    },
    {
      "name": "CashScript & Development Tools",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What CashScript optimization anti-patterns should be avoided?",
          "answer": "Two key anti-patterns: 1) Never use 'else require(false)' - it wastes 9 bytes and adds unnecessary operations. Instead, put the require condition in the else block directly: 'else { require(condition, \"error\") }'. 2) Avoid deeply nested if statements - they increase bytecode size and complexity. Use early returns or flatter logic structures instead."
        },
        {
          "question": "What does 'stack item exceeded maximum length (520 bytes)' error mean in CashScript?",
          "answer": "This error occurs when a program attempts to push a stack item larger than 520 bytes (BCH's MAX_SCRIPT_ELEMENT_SIZE limit) even if total script size and opcount are within limits. This was reported as a potential compiler issue in CashScript v0.10.0 - reverting to v0.8.0 resolved it. Individual stack elements have stricter size limits than the overall script."
        },
        {
          "question": "What is the CashScript v0.10.0 simple transaction builder bug and how to fix it?",
          "answer": "CashScript v0.10.0 has a bug in the debugging tooling for the simple transaction builder causing 'stack item exceeded maximum length' errors even when script size and opcount are within limits. Workaround: Use v0.9.0 or v0.8.0. The issue will be fixed in v0.11, where the old simple transaction builder will be marked deprecated. The bug affects the SDK when running contract functions."
        },
        {
          "question": "What are the key features of CashScript v0.11.0?",
          "answer": "Major release after 6+ months development. Highlight: debugging capabilities for new transaction builder, enabling local testing/debugging with mocknet and Bitauth IDE integration. Contains breaking changes with migration notes provided. Significantly improves developer experience. Allows transaction builder to be used for development testing rather than just production. Presented in Rosco's Bliss talk."
        },
        {
          "question": "What new BCH development guides were added to CashScript documentation?",
          "answer": "Two fundamental guides added: 1) 'Transaction Lifecycle' (cashscript.org/docs/guides/lifecycle) - explains transaction progression through network, 2) 'Adversarial Analysis' (cashscript.org/docs/guides/adversarial) - security analysis framework. Both are general BCH development knowledge that was assumed but never documented before, making them essential reading for all BCH developers regardless of CashScript usage."
        }
      ]
    },
    {
      "name": "Cross-chain & Bridges",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "Can BCH smart contracts trigger based on BTC blockchain events?",
          "answer": "No, BCH blockchain cannot natively monitor BTC transactions or addresses - chains cannot see each other without external data. This is the trustless two-way bridge problem, 'one of the biggest unsolved problems in crypto.' The only solution is using an oracle service that reports BTC chain events to the BCH contract, introducing trust assumptions."
        },
        {
          "question": "Why can't proof-of-work verification solve trustless cross-chain bridges?",
          "answer": "While similar to drivechains/ThorChain concepts, PoW verification faces critical problems: handling reorgs and calculating the highest PoW chain when adversaries feed the contract data from minority hashrate branches. The technical complexity of on-chain SPV light client verification, combined with potential for dishonest oracle data, makes two-way peg SPV a 'graveyard idea' - heavily discussed but never successfully implemented."
        },
        {
          "question": "What are the practical approaches to wrapped BTC on BCH?",
          "answer": "Three approaches: 1) Tokenized BTC via CashTokens backed by custodial service (centralized trust, could use proof-of-reserves), 2) BCH Bull's battle-tested oracle service for BTC-pegged financial products (cash-settled instruments, not redeemable tokens), 3) WBTC CashToken bridge (possible today). All require trust assumptions - depositing BTC for truly trustless wrapped-BTC is impossible without BTC covenant support (unlikely). Usually solved with multisig custody."
        },
        {
          "question": "What is the difference between cash-settled instruments and redeemable wrapped tokens?",
          "answer": "Cash-settled instruments (like BCH Bull products) track BTC price via oracle and settle in BCH - you never get actual BTC. Redeemable wrapped tokens (like traditional WBTC) represent claims on real BTC held in custody that can be redeemed 1:1. These are entirely different animals - one is a derivative, the other is tokenized custody."
        },
        {
          "question": "What CashToken integrations are being pursued with ThorChain?",
          "answer": "Active collaboration to add MUSD, PUSD, and potentially other CashTokens to ThorChain for cross-chain trading. This would enable BCH CashTokens to be swapped with assets from other chains (BTC, ETH, etc.) through ThorChain's liquidity pools. Contact has been established between BCH CashToken developers and ThorChain team."
        }
      ]
    },
    {
      "name": "Exchange & Integration",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is the main barrier to CEX (centralized exchange) CashToken adoption?",
          "answer": "Almost all exchanges use node software directly to support token ecosystems. The BCH ecosystem 'botched it' by not implementing 100% token-aware support (receive/send CashTokens) in full node software from the start. After 5 years, no CEX has implemented CashTokens because they need complete native node support to easily integrate token trading, just like they do for other chains' token standards."
        },
        {
          "question": "What happens if a pre-CashTokens wallet tries to spend a CashToken UTXO?",
          "answer": "Pre-CashTokens wallets cannot spend CashToken inputs - signing for CashTokens inputs is designed to prevent this, protecting against accidental burns. However, if a CashToken-aware wallet spends a token UTXO without including tokens in outputs, the transaction is valid and tokens are implicitly destroyed (burned). Quote from spec: 'Tokens can be implicitly destroyed by omission from a transaction's outputs.'"
        },
        {
          "question": "What happens when a non-CashToken-aware wallet receives a CashToken deposit?",
          "answer": "Token-unaware wallets won't recognize UTXOs containing tokens - they don't know how to spend them. If exchange attempts consolidation including CashToken UTXO, transaction will fail due to signature generation error. The token_prefix must be included in sighash preimage construction. Solutions: 1) Mark CashToken deposits as 'failed' to exclude from UTXO selector, 2) Update sighash preimage to properly handle token_prefix (decode from UTXO data)."
        },
        {
          "question": "What's the technical requirement for signing CashToken inputs in custom BCH implementations?",
          "answer": "Sighash preimage construction must include token_prefix field (not hardcode as empty b''). Preimage structure: version + hashPrevouts + hashSequence + txid + txindex + token_prefix + scriptCode_len + scriptCode + amount + SEQUENCE + hashOutputs + lock_time + hash_type. Pre-CashTokens signing code fails because token_prefix is missing/empty. Must decode token prefix from UTXO and include in preimage."
        },
        {
          "question": "Can bch-js or mainnet-js accidentally burn CashTokens?",
          "answer": "bch-js cannot accidentally burn CashTokens - it doesn't know how to sign token input transactions. Without explicit support for token signing in sighash preimage construction, accidental burning is impossible. However, mainnet-js could accidentally burn SLP tokens if you use both. Pre-CashTokens wallets cannot spend CashToken inputs due to signature mechanism protection."
        },
        {
          "question": "What is the recommended exchange policy for handling unsupported CashToken deposits?",
          "answer": "No clear consensus policy exists yet. Challenge: even if exchange supports X tokens, users can deposit unsupported ones. Options: 1) Treat as simple BCH deposit (risks accidentally burning tokens), 2) Quarantine UTXOs containing unsupported tokens (prevents burns, requires extra infrastructure). Most exchanges haven't implemented CashTokens yet, so best practices still emerging."
        },
        {
          "question": "How should exchanges handle CashToken deposits to non-token-aware systems?",
          "answer": "Recommended approach: 1) Policy - Quarantine CashToken UTXOs to retain manual recovery option if user covers fees, 2) Implementation - Override block parser to construct pruned block containing only BCH txs for parent class processing, 3) Create token vouts in database with FAILED status, 4) Exclude FAILED status from UTXO selection queries. This prevents spend failures while preserving recovery capability."
        }
      ]
    },
    {
      "name": "Applications & Use Cases",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "How can BCH dapps avoid needing an application server?",
          "answer": "By putting contract details on-chain, dapps can be client-only with no backend server required. The BCH Hodl Dapp demonstrates this pattern - it's a fully functional smart contract application that runs entirely in the browser. The goal is to create a 'BCH Dapp Template' enabling developers to launch simple smart contract apps within 24 hours using this serverless architecture."
        },
        {
          "question": "What WalletConnect applications are desired for BCH CashToken development?",
          "answer": "Desired WalletConnect apps include: vault app for secure storage, last-will inheritance app for estate planning, Mecenas recurring payments app for subscriptions, 'Hodl' time-locked savings app, AnyHedge app for hedging, and airdrop/dividends app for token distribution. These would enable covenant-based financial primitives through user-friendly interfaces."
        },
        {
          "question": "How would a diversified CashToken index fund work on BCH?",
          "answer": "A FUND token could monitor completed tokens from BCH Pump and reset allocation each time a new Nth token completes, distributing 1/N to each completed token. Starting with the 2nd completed token (1/2 each), then adjusting to 1/3 when the 3rd completes, etc. Key challenges include programmability, custody of decision-making, determining initial group composition, and managing dynamic rebalancing intervals."
        },
        {
          "question": "What is the Vox platform architecture?",
          "answer": "Vox is a basket of CashToken-enabled contract apps with a distributed database connecting them, where the database itself is a CashToken contract. The architecture uses contracts with references to other contracts, creating an interconnected system that unifies multiple applications in one UI. This demonstrates contracts-as-database infrastructure on BCH."
        },
        {
          "question": "How does Vox's on-chain chat pricing and censorship resistance work?",
          "answer": "Anyone can post for 250 sats/character. Anyone can 'censor' (remove) any message for 2500 sats/character (10x cost). Authors can edit their messages for 1 sat/byte. Messages are deleted after ~1 week - NFT commitments are burned from active UTXO set, preserved in full node history but removed from pruned nodes. Identities link to address that issued identity token, enabling cross-device profiles."
        },
        {
          "question": "How does CashStarter use CashTokens for crowdfunding?",
          "answer": "CashStarter (circa 2023) is open source crowdfunding platform using CashTokens to track donations on-chain. Similar to Flipstarter but uses CashToken NFTs/FTs for donor tracking and campaign management. Code available at github.com/SayoshiNakamario/CashStarter/blob/main/CashStarter.cash. Demonstrates using tokens as accounting mechanism for complex multi-party applications."
        },
        {
          "question": "What are the existing gamified BCH faucet implementations?",
          "answer": "Three implementations: 1) bugs.cash (potential open source code for reference), 2) afifthofgaming.com (gamified faucet), 3) purelypeer.cash (geolocated cashdrops - users go on quests/campaigns to find BCH at physical locations). Primary challenge is marketing rather than technical implementation. These demonstrate BCH faucets with game mechanics for user engagement."
        },
        {
          "question": "What would a Double Spend Proof (DSP) checker website do?",
          "answer": "A DSP checker would take a transaction ID and show its status, plus display a history of recent double-spend attempts and their generated DSPs. The goal is to make double-spend proofs visible and accessible, as currently they're hidden technology at the node layer with no easy way to 'see' them."
        },
        {
          "question": "What are the limitations of Double Spend Proofs (DSP) for P2SH transactions?",
          "answer": "DSP won't catch a double-spend with P2SH ancestors. P2SH ancestor means DSP score of 0 (NOT COVERED). Spec requires transactions be all P2PKH, or all mempool ancestors must be all-P2PKH, signed SIGHASH_ALL without ANYONECANPAY. This creates problems for payments using DEX swaps to convert tokens to BCH for fees on-the-fly - if 0-conf ancestor is Cauldron pool, child could get dropped when parent drops. Not all 0-conf is equal."
        }
      ]
    },
    {
      "name": "Token Management",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What is the difference between reserve supply and burned tokens, and how do you manage them?",
          "answer": "Reserve supply is held in the AuthUTXO (not just 'original minter address' - no such concept in BCMR spec). Only AuthUTXO can update metadata and hold reserved supply. To move tokens to reserve: send to AuthUTXO. Burning is different: transaction has tokens as input and none as output - 'missing' tokens are permanently deleted. Use tokenburner.cash or CashTokens.Studio AuthGuard Contract Address."
        },
        {
          "question": "How do you properly return tokens to reserve supply versus just burning them?",
          "answer": "Reserve supply must be in the single AuthUTXO, not just any UTXO at the authguard address. To return to reserve: spend AuthUTXO together with circulating tokens, consolidate output back to single AuthUTXO. Just sending tokens to authguard creates multiple UTXOs that pollute it - not true reserve. Difficult if tokens owned by different wallets. For permanent removal, burn instead (CashTokens Studio now sends burns to tokenburner.cash)."
        },
        {
          "question": "What tools exist for batch managing unwanted CashTokens?",
          "answer": "Requested feature ('shitcoin autodumper'): tool to list FTs with checkboxes, prepare Cauldron transactions for selected tokens, show total value summary. Currently on Selene wallet todo list. For tokens without Cauldron liquidity pools, use dropship.cash to send/airdrop them. No complete solution exists yet - manual cleanup via individual Cauldron trades or burning required."
        },
        {
          "question": "How do you send payments to specific NFT holders?",
          "answer": "To send BCH to an address holding a specific NFT: you need to find which address currently holds that NFT (by querying blockchain for the NFT's UTXO), then send BCH to that address. NFTs don't have individual tokenIds - they share the category's tokenId but have unique commitments. Can add receiving address in NFT metadata, or query explorer/indexer to find current holder's address."
        },
        {
          "question": "What are the approaches for paying to specific NFT holders?",
          "answer": "Three approaches: 1) Backend service that scans/tracks UTXO set to find current NFT holder address, 2) Adding receiver address in NFT metadata (requires trust - creator can change it, must update on every transfer), 3) Contract redeemable only when specific NFT included in transaction (verification challenging - need indexer/BCMR check + redeem script verification). P2NFT CHIP discussed for future improvements. Cannot burn metadata modification rights for individual NFTs."
        }
      ]
    },
    {
      "name": "Standards & Protocols",
      "description": "",
      "source": "CashTokens",
      "faqs": [
        {
          "question": "What are the BIP21 query parameters for requesting CashTokens in payment URIs?",
          "answer": "Standard: bitcoincashresearch.org/t/bip21-query-parameters-for-cashtokens/1015. Parameters: &c=<categoryId_hex> for token category, &ft=<amount> for fungible token amount (Paytaca uses &f=). Example: bitcoincash:address?c=e38d7f8e85da78943b3d7766e94c5560522ad67758402ae8f31765412b746292&f=3000000. Different wallets use 'ft', 'f', or 't' parameters. Request 100.00 MUSD: &c=<hex>&ft=10000."
        },
        {
          "question": "What's the current state of BIP21 URI support for CashTokens?",
          "answer": "PayPro proposal exists (github.com/bitjson/chip-paypro) but not implemented anywhere. Key challenges: backwards compatibility ('s' param breaks old wallets, adding 'amount' violates spec), risk of wallets ignoring token params (c, f) and sending BCH-only. Potential solution: 'bch:' prefix for PayPro instead of 'bitcoincash:' to prevent accidental partial sends. Token addresses don't require tokens - can send BCH-only to them."
        }
      ]
    },
    {
      "name": "CashScript Language & Compilation",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "What is the proposed compileScript() function for CashScript?",
          "answer": "A proposed function that compiles small CashScript code segments into CashASM without requiring a full contract wrapper. Example: compileScript('a + b', {a: 'int', b: 'int'}) would output '<a> <b> OP_ADD'. This enables easier template creation by allowing developers to write complex field calculations in CashScript and compile them to CashASM at build time."
        },
        {
          "question": "What syntax is proposed for standalone CashScript function compilation?",
          "answer": "Instead of requiring full contract definitions, the proposal suggests compiling standalone functions like: compileScript(`function checkLockingBytecode(bytes lockingBytecode) { require(lockingBytecode.length == 25); }`) or using arrow function syntax: `(int a, int b) => { return a + b }`. This skips the contract wrapper overhead while maintaining function parameter definitions."
        },
        {
          "question": "Are standalone CashScript functions on the roadmap?",
          "answer": "Yes, creating self-contained functions is on the CashScript roadmap. When implemented, they will be compilable independently for use cases like template field injection. Adding CashASM as an explicit compilation target (separate from regular hex bytecode/asm) is also planned to support template generation workflows."
        },
        {
          "question": "Is there a Python version of the CashScript SDK?",
          "answer": "CashScript-py is being developed and recently received funding. It will be feature-compatible with the JavaScript SDK. However, it's not a solution for OP_CHECKMULTISIG support since the Python version will have the same SDK limitations as the JS version (no collaborative transaction building)."
        },
        {
          "question": "What is Spedn and how does it compare to CashScript?",
          "answer": "Spedn is an alternative BCH smart contract compiler with different syntax from CashScript. While CashScript is more widely adopted with active development and extensive ecosystem support, Spedn offers an alternative approach. Developers can experiment with Spedn using community test repositories, though tooling and documentation are less mature."
        }
      ]
    },
    {
      "name": "Template Design & Standards",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Should BCH templates use CashScript, CashASM, or bytecode?",
          "answer": "Templates should use CashASM (assembly), not CashScript or bytecode. CashScript at build-time compiles to CashASM for the final template. CashASM is human-readable, syntactically simple to port across languages, and already supported by LibAuth-based wallets (Paytaca, Selene, Cashonize, ZapIt). Bytecode would save bandwidth but requires all wallets to implement assemblers."
        },
        {
          "question": "Why not embed CashScript source code in final templates?",
          "answer": "Embedding CashScript would force all wallets and dapps to incorporate a CashScript parser, creating version incompatibility issues when CashScript optimizations change the output CashASM. It also limits cross-platform adoption since non-JavaScript implementations would be difficult. Templates with only CashASM avoid these problems."
        },
        {
          "question": "What are LibAuth WalletTemplates and how do they relate to BCH templates?",
          "answer": "LibAuth WalletTemplates provide a standardized format for describing BCH transactions using CashASM. Templates leverage this by embedding sandboxed CashASM evaluation instructions that wallets execute, enabling dynamic field calculations like nested evaluations: '$($(<value> <1000> OP_SUB) <2> OP_DIV)'. This allows complex transaction templates without requiring CashScript runtime support."
        },
        {
          "question": "What is the trade-off between CashASM and bytecode in templates?",
          "answer": "Bytecode advantages: smaller file size, bandwidth savings (important for NFC). CashASM advantages: human-readable, simpler parser implementation, easier cross-language porting, already supported in LibAuth wallets. The consensus is CashASM provides better versatility and portability while keeping complexity manageable, with bytecode reserved for specific use cases like NFC."
        },
        {
          "question": "How does template design balance versatility vs simplicity?",
          "answer": "CashASM is chosen as a mid-ground: syntactically simple enough to port to other languages but versatile enough for complex contract use-cases. Nested evaluation capabilities are needed for transaction shape definitions and signing operations. The philosophy is to handle complexity in tooling (build-time) rather than requiring wallets to support complicated features."
        },
        {
          "question": "What is the debug symbols approach for BCH smart contracts?",
          "answer": "Similar to traditional compiled languages, contracts use external metadata files (debug symbols) that accompany compiled scripts. Production templates contain only CashASM/bytecode, keeping them lightweight. Debug symbols (\"byte N is variable A\") are stored separately for development/debugging only. This separates complexity from production requirements."
        },
        {
          "question": "Why is CashASM evaluation executed within wallets in templates?",
          "answer": "Templates embed CashASM evaluation instructions that wallets execute in a sandboxed environment. This allows templates to perform dynamic calculations (like computing leverage ratios or concatenating NFT commitments) without requiring pre-compiled values. The wallet evaluates the CashASM expressions using its BCH VM capabilities to build the final transaction."
        }
      ]
    },
    {
      "name": "Wallet Support & Ecosystem",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Which BCH wallets currently support CashASM?",
          "answer": "At least four ecosystem wallets use LibAuth under the hood and thus support CashASM: Paytaca, Selene, Cashonize, and ZapIt. Electron Cash may have ported it with the new WalletConnect plugin. This existing support makes CashASM a practical choice for template standardization."
        },
        {
          "question": "How is the CashConnect wallet transaction building API designed?",
          "answer": "CashConnect uses a partial TransactionTemplate approach where users provide outputs (with lockingBytecode, valueSatoshis, and optional token data), and the wallet automatically appends required inputs and change outputs. The TransactionBuilder follows the tokens-first, satoshis-last pattern internally, handling fee calculation and change construction transparently."
        }
      ]
    },
    {
      "name": "Transaction Building",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Does the CashScript TransactionBuilder automatically add change outputs?",
          "answer": "No, the advanced TransactionBuilder does nothing automatically - you must manually add satoshi change outputs and token change outputs. This design gives full control but requires developers to handle fee calculation and change output construction themselves."
        },
        {
          "question": "What is the correct order for handling tokens and satoshis when building transactions?",
          "answer": "Tokens first, satoshis last. Correct sequence: addTokensFromUnspents()  addTokenChangeOutputs()  addSatoshisFromUnspents()  addSatoshiChangeOutput(). This is critical because satoshi change amount depends on the final transaction fee, which can only be calculated after token outputs are finalized."
        },
        {
          "question": "How do you calculate transaction fees when spending from multiple contracts?",
          "answer": "Fee calculation is non-trivial for multi-contract spends because input sizes aren't known until unlockers are defined. Options include: 1) Use getCurrentByteSize() or build() then check rawTxHex.length/2 to get transaction size, 2) Create utility functions to estimate output sizes, 3) Build the transaction, parse with libauth to check sizes, then add balancing outputs (which may require extra inputs)."
        },
        {
          "question": "What transaction builder utilities are proposed for fee management?",
          "answer": "Proposals include: getCurrentByteSize() to get current transaction size, and calculateOutputSizes() to estimate change output sizes for different types (like P2PKH with tokens). The current method is building the transaction and checking rawTxHex.length/2, but more sophisticated utilities would help with multi-contract spends."
        },
        {
          "question": "How can you get intermediate transaction information before finalizing?",
          "answer": "After adding contract spends with defined unlockers, you could extract intermediate information like input sizes from the prebuilt transaction. Since spending args are provided to unlockers, the final input shape is known. This would help calculate change outputs before fully building and sending the transaction."
        },
        {
          "question": "What fee estimation utilities exist for CashScript transactions?",
          "answer": "bch-js has getByteCount() for simple cases: `bchjs.BitcoinCash.getByteCount({ P2PKH: 1 }, { P2PKH: 1 })`. However, this is too simple for CashScript multi-contract spends. More sophisticated utilities to check bytecount for different transaction shapes with varying input/output types would be valuable."
        },
        {
          "question": "Can NFT inputs be auto-populated in transaction builders?",
          "answer": "No elegant solution exists yet for auto-populating NFT inputs. NFTs must be explicitly passed in the template rather than populated automatically. Most transactions requiring NFTs need to specify a particular outpoint anyway (\"use this exact UTXO\"), making auto-selection less useful than with fungible assets."
        },
        {
          "question": "What features does the Flowee API transaction builder provide?",
          "answer": "The Flowee API transaction builder includes: automatic byte count calculation, output adjustment to achieve specific fee-per-byte targets, and BIP69 anonymity features (deterministic input/output ordering). These are reference implementations for transaction building best practices."
        }
      ]
    },
    {
      "name": "Debugging & Development Tools",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "What debugging capabilities does CashScript v0.11.0+ provide?",
          "answer": "CashScript v0.11.0+ adds debugging support for the new transaction builder, allowing use with mocknet for local testing and integration with the Bitauth IDE. You can call .debug() on failed transactions or .bitauthUri() to manually inspect. The debugging works with the contract's optimized bytecode, so dev and prod contracts are identical, eliminating the dev/prod discrepancy that could hide bugs."
        },
        {
          "question": "Can you debug transactions that spend from multiple different smart contracts?",
          "answer": "Yes, in CashScript v0.11.0+. Use the new transaction builder to combine multiple contracts in a single transaction, then call .debug() or .bitauthUri() on it. The Bitauth IDE allows you to click through and debug each input individually, making multi-contract transaction debugging straightforward."
        },
        {
          "question": "Can you select specific inputs to debug in TransactionBuilder.debug()?",
          "answer": "No, debug() automatically debugs the entire transaction. When you open the Bitauth URI (logged on debug failure or via bitauthUri()), you can click through different inputs one by one in the IDE. This allows inspecting each input individually even though debugging operates on the complete transaction."
        },
        {
          "question": "What is CashScript Arena?",
          "answer": "CashScript Arena (arena.layer1.cash) is an interactive learning platform with challenges based on exploitable or broken smart contracts. It's designed for both complete beginners (first challenge just requires setting up the environment) and experienced developers to practice contract security and CashScript fundamentals."
        }
      ]
    },
    {
      "name": "Version-Specific Features & Updates",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "What new features does CashScript v0.11.0 introduce?",
          "answer": "v0.11.0's highlight is debugging capabilities for the new transaction builder, allowing use with mocknet for local testing and Bitauth IDE integration. The old simple transaction builder is deprecated. The release includes sourcemaps that work with optimized bytecode so dev and prod contracts are identical. See migration-notes in docs for breaking changes."
        },
        {
          "question": "What new features does CashScript v0.11.4 include?",
          "answer": "v0.11.4 includes a bug fix for P2PKH-only transactions and enhanced MockNetworkProvider functionality that allows simulating a real network more closely during testing. Both features were contributed by the community (mainnet_pat)."
        },
        {
          "question": "What new features does CashScript v0.12.0 introduce?",
          "answer": "v0.12.0 removes the old deprecated transaction builder and adds: 1) getVmResourceUsage() function to measure VM resource consumption, 2) New TransactionBuilder safety options, 3) Several breaking changes requiring migration (see migration-notes in docs)."
        },
        {
          "question": "What new guides are available in the CashScript documentation?",
          "answer": "The CashScript docs now include two essential BCH development guides that document assumed knowledge: 1) \"Transaction Lifecycle\" guide explaining how transactions are created, validated, and propagated, and 2) \"Adversarial Analysis\" guide covering security considerations and attack vectors in smart contract development."
        }
      ]
    },
    {
      "name": "Common Issues & Troubleshooting",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Why does my CashScript transaction hang when using ElectrumNetworkProvider?",
          "answer": "If using CashScript v0.10.0 with chipnet, the old default electrum server is down. Either pass a custom server like chipnet.bch.ninja when instantiating ElectrumNetworkProvider, or upgrade to the @next pre-release which has updated default servers."
        }
      ]
    },
    {
      "name": "Protocol Features & Capabilities",
      "description": "",
      "source": "BCH Compilers",
      "faqs": [
        {
          "question": "Does Bitcoin Cash have MAST or Taproot?",
          "answer": "No, BCH does not currently have MAST or Taproot. However, there's an ongoing CHIP proposal for OP_EVAL which would enable MAST-like constructions. Additionally, MAST functionality can be emulated today using BCH's native introspection opcodes, specifically OP_UTXOBYTECODE, without requiring a protocol upgrade."
        },
        {
          "question": "Does the CashScript SDK support OP_CHECKMULTISIG?",
          "answer": "No, the language supports it but the SDK does not. OP_CHECKMULTISIG requires collaborative transaction building support which isn't currently implemented. The recommended alternative is using NFTs for multisig authorization - for 1-of-M scenarios, NFT ownership proves authorization; for N-of-M, participants can merge NFTs non-interactively to accumulate the required N signatures."
        },
        {
          "question": "What advantages does NFT-based multisig offer over traditional OP_CHECKMULTISIG?",
          "answer": "NFT-based multisig provides better discoverability and easier backup recovery. Since NFT ownership is on-chain and queryable, wallets can discover multisig authorization tokens by scanning the blockchain. Traditional multisig requires coordinating public keys off-chain. For N-of-M scenarios, NFTs can be merged non-interactively to accumulate signatures."
        }
      ]
    },
    {
      "name": "BCH Fundamentals & Philosophy",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "Why don't smart contracts need human intermediaries?",
          "answer": "Smart contracts hold funds in a trustless manner where even the contract creator cannot access them. Funds are controlled by code logic that executes deterministically on the blockchain. This removes human custody risk - no one can unilaterally change the rules, steal funds, or fail to execute. While many applications still require a 'transaction server' to invoke contract functions, the critical difference is custody: the server cannot steal funds, only help construct valid transactions according to immutable contract rules."
        },
        {
          "question": "What is the main difference between a server-controlled wallet and a smart contract?",
          "answer": "The critical difference is custody and immutability. Smart contracts commit to constraints that even the contract creator cannot change - e.g., if a contract requires 10% to go to address A, it will do so forever. A server-controlled wallet relies on a private key and code that can be updated anytime to change payout rules. The question isn't about needing a server, it's about who controls the funds."
        },
        {
          "question": "What is the correct mental model for CashScript contract deployments?",
          "answer": "Think of all CashScript contracts as elaborate spending conditions rather than deployments. Some contracts have unique 'deployments' (a UTXO authenticated by a tokenid) like Moria and ParityUSD, but others are just spending scripts like multisig or vaults. Contracts that share the same spending conditions without unique parts get a stable address over time. Depending on your contract type, you care about total 'balance' or specific UTXOs on the address."
        },
        {
          "question": "What mental model should you have for UTXO covenants?",
          "answer": "Each UTXO has its own program/script that can specify the full required transaction shape. A UTXO can require other specific scripts to be present in the same transaction. This enables complex multi-party transaction patterns where different inputs enforce different spending conditions that must all be satisfied simultaneously."
        },
        {
          "question": "How is data storage different between CashScript/BCH and Solidity/Ethereum?",
          "answer": "BCH doesn't have global state like Ethereum. Instead, you store data in CashToken NFT commitments - currently limited to 40 bytes, expanding to 128 bytes on May 15, 2025. This gives you local transferrable state that your contract can introspect and update. You can even store functions themselves in token commitments (if they fit in 128 bytes), creating 'local transferrable functions'."
        }
      ]
    },
    {
      "name": "Language Features & Syntax",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What language improvements are planned for CashScript?",
          "answer": "Near-term improvements include: 1) Enforcing correct bytesX types for .split() assignments, 2) Disallowing bytesX in function arguments (untrusted/unenforced), 3) Renaming tx.age to this.activeInputAge, 4) New activeInput syntax (this.activeInput instead of tx.inputs[this.activeInputIndex]), 5) Syntactic sugar for slice operations, 6) Source maps for optimized bytecode, 7) Struct functionality for naming bytestring parts. Longer-term: Template syntax for constructor arguments to insert them exactly where needed rather than always at the start."
        },
        {
          "question": "What two types of structs are being considered for CashScript?",
          "answer": "Two types are planned: 1) Fixed-size bytestructs that only support bytesX types for simple bytestring parsing, and 2) General variable-size structs that support all types (bytes, int, string). With bigint support, casting to fixed bytesize adds overhead, so both types will likely be needed. Variable-size structs would store length prefixes for each field, similar to how some contracts manually pack data today."
        },
        {
          "question": "Will CashScript support global constants?",
          "answer": "Yes, global constants are planned and tracked in an open issue. Unlike local constants which currently get pushed onto the stack, global constants would be inlined at compile time, avoiding unnecessary opcode overhead. This is a common feature in other languages and would improve contract efficiency. Breaking changes like this would only be introduced with major version updates."
        },
        {
          "question": "What does renaming tx.age to this.age clarify?",
          "answer": "The rename from tx.age to this.age clarifies that this field represents a UTXO-level property (the age of the specific input being evaluated), not a transaction-level property. This follows the pattern where 'this' refers to properties of the active input, making the code more intuitive and preventing confusion about what age actually measures."
        },
        {
          "question": "What new syntax did CashScript v0.11.3 add?",
          "answer": "Version 0.11.3 added a new .slice(start, end) syntax for extracting byte ranges from byte arrays, along with improved type safety around both .split and .slice operations. This provides more intuitive substring-like operations on bytes data, similar to array slicing in other languages."
        },
        {
          "question": "Does CashScript support do-while loops?",
          "answer": "Yes, CashScript@next has do-while loop support using OP_BEGIN and OP_UNTIL opcodes. Install cashc@next to compile contracts with do-while loops, or try the preview playground at next.cashscript.org. Version 0.13.0-next.1 fixed edge cases when using do-while loops with the SDK debug tooling. This implements bounded loops to maintain deterministic execution and enables iteration over transaction inputs/outputs and other bounded operations."
        },
        {
          "question": "What emergent patterns have CashScript users developed?",
          "answer": "Three key patterns emerged: 1) Defining structs as comments to track bytearray splitting, 2) Creating abstractions for macros/reusable functions and constants across contract files (like Fex.cash does), 3) Defining transaction shapes inside contract logic files to clarify what introspection indexes refer to. These patterns are being studied for potential native language support."
        },
        {
          "question": "Why is defining transaction shapes in contract files unique to CashScript?",
          "answer": "This pattern is unique to programming in the UTXO model with introspection. No other programming language has this because BCH is advancing the state of the art - pioneering UTXO-based smart contracts with transaction introspection. This requires inventing new UTXO-specific language features, which requires significant research to get right."
        }
      ]
    },
    {
      "name": "Type System & Casting",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "How does integer to bytes casting work in CashScript without a length argument?",
          "answer": "When casting `bytes(n)` without a length argument, it's simply a no-op - no call to OP_NUM2BIN is needed. The variable remains in scriptnumber format (minimal encoding). Only when you specify a length like `bytes8(n)` does CashScript generate OP_NUM2BIN with the explicit length parameter."
        },
        {
          "question": "Why is casting integers to fixed-size bytes important in CashScript?",
          "answer": "Casting integers to fixed-size byte-length is critical when storing local state in an NFT commitment. If you have multiple values concatenated in one field, you need fixed length for most items to be able to split them. BCH script uses scriptnumbers which have variable-length encoding, so explicit casting to bytesX ensures predictable byte offsets for parsing."
        },
        {
          "question": "What happens with OP_NUM2BIN overflow in BCH?",
          "answer": "Currently, OP_NUM2BIN can overflow if you cast to a byte size too small for the number (e.g., trying to fit a large number into bytes1). However, with the BigInt upgrade (May 2025), maxint equals maxstack, eliminating overflow issues. After the upgrade, any valid stack item will be convertible to a valid int through BIN2NUM without overflow, though you may still hit VM resource limits."
        },
        {
          "question": "What is BigInt support in CashScript?",
          "answer": "As part of the VM limits upgrade preparation, CashScript can now test for proper BigInt support. This allows contracts to work with arbitrarily large integers beyond the previous limits. BigInt support affects struct design since casting to fixed bytesize adds overhead, requiring both fixed-size and variable-size struct types."
        }
      ]
    },
    {
      "name": "CashScript SDK & Development Tools",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What makes CashScript unique compared to other smart contract languages?",
          "answer": "CashScript's uniqueness isn't just advanced language features - it's the ecosystem: 1) SDK with a fully overhauled transaction builder API and integrated debugging functionality, 2) Mocknet support for local testing, 3) Bitauth IDE integration for visual debugging, 4) Online playground for experimentation, 5) Contract testing suite, 6) Syntax highlighting and auto-completion in editors. This comprehensive tooling makes BCH covenant development accessible despite the complexity of the UTXO model."
        },
        {
          "question": "Why should you use TypeScript with CashScript instead of JavaScript?",
          "answer": "TypeScript catches type errors at compile time that would otherwise cause runtime failures. The CashScript team worked hard to provide full type checking from start to finish - TS artifacts automatically integrate unlocking types, function signatures, and parameter validation. Many common errors like wrong argument counts, incorrect UTXO structure, or invalid API calls are immediately caught by the TypeScript compiler."
        },
        {
          "question": "How should you compile CashScript artifacts for TypeScript projects?",
          "answer": "For best TypeScript integration, compile artifacts to .ts format instead of .json. This provides full type checking including automatic unlocking types for contract functions. Use the cashc compiler's TypeScript output option. The TypeScript artifacts enable the IDE to catch type errors at compile time rather than runtime."
        },
        {
          "question": "What is the correct way to access contract functions in the SDK?",
          "answer": "Use `contract.functions.functionName(args)` to create unlockers. For example: `contract.functions.refund(signatureTemplate)`. The older `contract.unlock` API is deprecated. Each function call returns an unlocker that you pass to TransactionBuilder.addInput() or addInputs() as the second parameter."
        },
        {
          "question": "What parameters does TransactionBuilder constructor accept?",
          "answer": "TransactionBuilder requires a `{ provider }` parameter with a NetworkProvider instance, not `{ addressType }`. For example: `new TransactionBuilder({ provider: new ElectrumNetworkProvider() })`. The addressType is specified when instantiating the Contract, not the TransactionBuilder. For testing, use MockNetworkProvider."
        },
        {
          "question": "Is TransactionBuilder.build() an async function?",
          "answer": "No, txb.build() is synchronous and returns a string immediately. You don't need to await it. Simply call `const txHex = txb.build();` without the await keyword. This is a common mistake when migrating from other transaction building libraries."
        },
        {
          "question": "Should you prefix hex strings with '0x' in CashScript contract constructor parameters?",
          "answer": "No, don't prefix hex strings with '0x' when passing them as contract constructor arguments. CashScript handles hex strings directly without the prefix. For example, pass the hash as `params.otpHashHex` not `'0x' + params.otpHashHex`. The '0x' prefix is only used in certain contexts like literal bytes in contract code."
        },
        {
          "question": "Should you mix libauth transaction building with CashScript TransactionBuilder?",
          "answer": "No, don't tinker with libauth transaction building when using the CashScript TransactionBuilder. CashScript provides a higher-level abstraction that handles transaction encoding internally. Mixing the two creates confusion and errors. Use CashScript's TransactionBuilder API exclusively for contract transactions unless you have very specific low-level requirements."
        },
        {
          "question": "How do you integrate CashScript TransactionBuilder with WalletConnect?",
          "answer": "Use the generateWcSourceOutputs utility function to convert from CashScript TransactionBuilder to WalletConnect object in 4 lines: Build the unsigned transaction, decode it with decodeTransaction(hexToBin(unsignedRawTransactionHex)), then call generateWcSourceOutputs(transactionBuilder.inputs, decodedTransaction). This standardized pattern simplifies WalletConnect integration for dapp developers."
        },
        {
          "question": "How does CashScript v0.11.1 integrate with BCH WalletConnect?",
          "answer": "CashScript v0.11.1 added a TransactionBuilder method to generate BCH WalletConnect transaction objects. Developers can build transactions using the SDK's TransactionBuilder, then call a method to convert it to a WalletConnect-compatible format that can be sent to a WC client for signing. This simplifies dapp development by standardizing wallet integration."
        }
      ]
    },
    {
      "name": "Debugging & Testing",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What debugging capabilities did CashScript v0.11.0 add?",
          "answer": "Version 0.11.0 added debugging capabilities for the transaction builder, allowing it to be used with local testing via MockNetworkProvider and inside the Bitauth IDE. The release was in development for over 6 months with multiple pre-releases to handle edge cases. This greatly improved the developer experience by enabling visual debugging and local contract testing."
        },
        {
          "question": "Why do you need to upgrade both cashc compiler and cashscript SDK to use improved debugging?",
          "answer": "The cashc compiler v0.11 outputs additional debug data in the artifact JSON that the SDK's debugging tooling requires. If you use cashc v0.8 with cashscript SDK v0.11, the debugging tooling won't work as well because the artifact lacks the necessary debug metadata. Both must be v0.11+ to get full benefits of mocknet testing and Bitauth IDE integration."
        },
        {
          "question": "What MockNetworkProvider improvements were added in CashScript v0.11.4?",
          "answer": "Version 0.11.4 added features to MockNetworkProvider that allow it to simulate a real network more closely, making local testing more realistic. The release also included a bug fix for P2PKH-only transactions. Both features were contributed by the community (mainnet_pat)."
        },
        {
          "question": "What debugging improvements did CashScript v0.11.5 add?",
          "answer": "Version 0.11.5 enhanced debugging by including the input index in console.log statements, making it easier to identify which input is being evaluated in multi-input transactions. It also improved type inference for function and constructor arguments in the Contract class, and cleaned up dependencies by removing accidental @types/node inclusion."
        },
        {
          "question": "How can you visualize the CashScript to opcode mapping for debugging?",
          "answer": "Use the Bitauth IDE debugging integration via `const uri = await transactionBuilder.getBitauthUri();`. This generates a URI that opens in Bitauth IDE showing: CashScript source code as comments in the middle panel, compiled opcodes color-highlighted, and execution results for each opcode on the right panel. This requires the full transaction context from TransactionBuilder, not available with compiler-only operations."
        },
        {
          "question": "Does CashScript mocknet support upcoming BCH upgrades like Layla (BCH 2026)?",
          "answer": "Yes, MockNetworkProvider allows you to configure which virtual machine version is used for evaluation. You can test against BCH 2026 (Layla upgrade) features locally. The CashScript@next branch has BCH 2026 set as the default mocknet configuration, enabling developers to test loop constructs and other new opcodes before the May 2025 network upgrade."
        }
      ]
    },
    {
      "name": "Contract Bytecode & Advanced Patterns",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What is this.activeBytecode in CashScript and what does it contain?",
          "answer": "this.activeBytecode represents the complete contract bytecode of the input currently being evaluated, consisting of constructor arguments (prepended in reverse order) + contract body. Critically, it does NOT contain the unlocking arguments (function parameters). This is different from tx.inputs[i].unlockingBytecode which represents the scriptSig that includes function arguments, constructor arguments, and contract body."
        },
        {
          "question": "What is 'simulated state' in CashScript contracts?",
          "answer": "Simulated state is a pattern where contracts modify their own constructor arguments to simulate state changes across transactions. The contract strips out old constructor arguments from this.activeBytecode, prepends new ones (with proper push byte encoding like 0x14 for 20-byte pushes), hashes the result, and requires the output to lock to this new bytecode. The major drawback is that each state change creates a new contract address, making it difficult to track the 'current' contract location."
        },
        {
          "question": "Why is simulated state considered an antipattern in modern BCH contracts?",
          "answer": "Simulated state changes the contract address with each state transition, requiring off-chain tracking of the current active contract. It's also complex to implement - you must carefully calculate constructor argument sizes, strip them from bytecode, add new ones with proper push byte encoding, then derive the new locking bytecode before building the transaction. Modern contracts use CashTokens NFT commitments to store state instead, keeping a stable contract address while allowing state to evolve in the token's commitment field."
        },
        {
          "question": "How do you manually encode constructor arguments when modifying contract bytecode?",
          "answer": "Constructor arguments must be prepended to the contract body in reverse order with push byte encoding. For example, a 20-byte argument requires the prefix 0x14 (hex for decimal 20) followed by the 20 bytes of data. A bytes32 would use 0x20. This encoding tells the BCH VM how many bytes to push onto the stack. You can see examples in contracts that use simulated state, like the Refresh contract which reconstructs itself with new constructor arguments."
        },
        {
          "question": "What is the hidden function selector argument in multi-function contracts?",
          "answer": "If you have more than one function in a contract, there is a hidden/implicit input argument for the function selector. This is related to the if/else opcodes before/after each function that route execution to the correct function. You need to be aware of this when calculating byte offsets for bytecode manipulation. However, the function selector is not part of this.activeBytecode - it's part of the unlocking bytecode."
        },
        {
          "question": "What is the difference between optimized and unoptimized contract bytecode in CashScript?",
          "answer": "CashScript produces optimized bytecode for production use (smaller, more efficient). The artifact also contains unoptimized bytecode under 'debug.bytecode' for debugging purposes. In v0.11.0+ debugging tooling, the dev and prod contracts were made identical - both use optimized bytecode. However, factory contracts creating child contracts must match the bytecode type (optimized vs unoptimized) to generate correct addresses."
        },
        {
          "question": "How do you handle factory contracts that create child contracts with matching addresses?",
          "answer": "To ensure factory-created contract addresses match SDK-compiled contracts, use the optimized bytecode from Contract.bytecode (not the raw artifact debug bytecode) as the parameter in your factory contract. The factory should concatenate constructor args + optimized bytecode, hash it, and create the P2SH32 address. This ensures addresses match when you later instantiate the child contract with new Contract()."
        },
        {
          "question": "What is the optimization boundary problem for reusable CashScript functions?",
          "answer": "When CashScript functions are compiled in different contexts (e.g., main contract vs. XO templates), the optimizer may produce slightly or greatly different opcode outputs due to cross-function optimization. This creates audit burden - the same high-level code may compile to different bytecode depending on context. The proposed solution is a facility to mark functions for isolated optimization, ensuring consistent opcode output across usages. This is tracked in GitHub issue #256."
        }
      ]
    },
    {
      "name": "CashTokens",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "How do you create CashToken genesis transactions with the CashScript SDK?",
          "answer": "Creating CashToken genesis is easy with the advanced transaction builder. Simply add a token parameter field to your output: `token: { amount: 100n, category: contractUtxos[0].txid }`. The category must be the txid of the input being spent (at index 0 for genesis). The SDK handles all the complexity - you just specify the token amount and category in your transaction outputs array."
        },
        {
          "question": "How do you burn CashTokens (NFTs or fungible tokens) in a transaction?",
          "answer": "Simply leave the token out of your transaction outputs - any tokens in inputs that don't appear in outputs are automatically burned. This is a common gotcha: developers are sometimes surprised that omitting a token from outputs destroys it. There's no explicit 'burn' operation; non-preservation equals burning."
        }
      ]
    },
    {
      "name": "Transaction Building & Fees",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "Can you introspect the transaction fee inside a BCH smart contract?",
          "answer": "No, transaction fee is not directly introspectable in BCH script. You must calculate it yourself by summing all input and output values. Contracts often hardcode an expected fee amount (like minerFee = 1000 satoshis in the Mecenas example), but this only represents the actual fee if the contract also restricts the number of inputs/outputs (e.g., require(tx.inputs.length == 1)). Without loops, contracts typically require a fixed or limited number of ins/outs to make fee calculation feasible."
        },
        {
          "question": "Why can't contracts precisely control transaction fees for arbitrary numbers of inputs/outputs?",
          "answer": "Calculating the exact transaction fee requires summing all input values and all output values. Since BCH script doesn't have loops, you cannot iterate over an arbitrary number of inputs and outputs to compute this sum. Contracts work around this by requiring a fixed number of inputs/outputs or very limited variability, making the fee calculable with explicit additions rather than loops."
        },
        {
          "question": "How do you require two different parties to sign inputs in a single transaction?",
          "answer": "You need two separate scripts/contracts, not a single multisig. Script1: \"I can only be spent by person A and need to be next to an input with script2\". Script2: \"I can only be spent by person B and need to be next to an input with script1\". These create two different P2SH addresses, and both UTXOs must be present as inputs in the same transaction, each providing its required signature."
        },
        {
          "question": "What is Median Time Past (MTP) and why does BCH use it for time-based locktimes?",
          "answer": "Median Time Past (MTP) is a trailing measure of the median timestamp from the previous 11 blocks. BCH uses MTP for time-based locktimes because it's a decentralized system without a real-time concept of accurate time. This means your CLTV time-locked transaction may not be accepted immediately when your wall clock shows the locktime has passed - you must wait for MTP to advance past your locktime value."
        }
      ]
    },
    {
      "name": "Common Errors & Debugging",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What does the 'missing inputs' error mean and how do you debug it?",
          "answer": "The 'missing inputs' error means your transaction is literally missing one or more inputs - it's a transaction building issue, not a signing issue. Debug by console.log-ing the UTXO before calling transactionBuilder.addInput(someUtxo, someUnlocker) to verify it's not undefined. You're likely passing undefined values to addInput or addInputs, possibly from failed UTXO lookups."
        },
        {
          "question": "How do you properly pass function arguments (unlockers) to TransactionBuilder?",
          "answer": "There is no `setUnlocker()` method. You pass the unlocker directly to `addInput()` as the second parameter: `txb.addInput(utxo, contract.functions.refund(signatureTemplate))`. Each input can have its own unlocker specifying which contract function to call and with what arguments. Refer to the transaction builder documentation examples for correct API usage."
        },
        {
          "question": "What does 'bad-txns-nonfinal, non-final transaction (code 64)' error mean?",
          "answer": "This error means you set a blockheight as locktime that hasn't been reached yet by the blockchain. The transaction is non-final and cannot be broadcast until the specified blockheight is reached. Debug by logging your locktime value and comparing it to the current blockheight: `console.log(await provider.getBlockHeight())`. For time-based CLTV, ensure you're using Unix timestamps (not block heights) and the time has passed."
        },
        {
          "question": "Why shouldn't you rely on AI (ChatGPT/Claude) to generate CashScript code?",
          "answer": "AI frequently hallucinates non-existent CashScript methods and APIs. For example, ChatGPT generated code using `txb.setUnlocker()` which doesn't exist in the TransactionBuilder API. As noted by CashScript maintainers: 'AI is just making shit up here.' Always refer to the official CashScript documentation at cashscript.org instead of trusting AI-generated code snippets."
        }
      ]
    },
    {
      "name": "Advanced Topics & CHIP Proposals",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What is the relationship between CashScript and OP_EVAL proposals?",
          "answer": "CashScript developers are actively engaged with OP_EVAL CHIP proposals, providing feedback on how function evaluation would work in the language. OP_EVAL would enable MAST-like constructions and potentially enhance CashScript's capabilities for complex contract patterns."
        },
        {
          "question": "Is there a CHIP proposal for adding loops to BCH script?",
          "answer": "Yes, there is a CHIP (2021-05) for bounded looping operations. The proposal was last updated in 2024. Bounded loops would allow iteration over transaction inputs/outputs and other structures while maintaining deterministic execution and preventing infinite loops through iteration count limits."
        },
        {
          "question": "How can Schnorr signatures improve smart contract privacy on BCH?",
          "answer": "Schnorr signatures enable multi-party key aggregation schemes where multiple parties cooperatively 'add together' their public keys to produce one aggregated pubkey and one aggregated signature. This allows smart contracts to settle on-chain as simple P2PKH transactions rather than revealing the contract script. Mark Lundeberg calls this 'Hiding as P2PKH' - it uses interactive cryptography to regain privacy by making smart contract settlements indistinguishable from regular transfers."
        }
      ]
    },
    {
      "name": "Use Cases & DeFi",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "How can smart contracts enable trustless inheritance on Bitcoin Cash?",
          "answer": "Instead of giving someone custody of your BCH funds to process inheritance, you can use a smart contract where you retain custody but after some idle time your relatives can claim funds according to contract rules. This removes the risk of the custodian stealing or mismanaging the funds. The LastWill contract pattern allows heirs to claim funds after a specified inactivity period while the owner can reset the timer."
        },
        {
          "question": "Can BCH smart contracts enable ratio swaps and derivatives trading?",
          "answer": "Yes, BCH can enable ratio swaps and derivatives through smart contracts. AnyHedge (accessible via bchbull.com) demonstrates this - you can gain or lose BCH based on price changes against supported assets like USD or BTC. If BTC goes up and BCH goes up more, you capture the full benefit of the ratio change. This enables long/short positions on price ratios between assets."
        },
        {
          "question": "Can BCH smart contracts enable trading on non-BCH asset pairs like XMR/BTC?",
          "answer": "Yes, you can use BCH as a proxy between two assets. If BCH Bull supported XMR but didn't support BTC-XMR pairs directly, you could theoretically set up two different AnyHedge-style contracts to achieve near the same result - one for BCH/XMR and another for BCH/BTC. This leverages BCH's smart contract capabilities to trade ratios between assets that don't have their own DeFi infrastructure."
        },
        {
          "question": "What 2-party atomic swap pattern exists for BCH?",
          "answer": "The 2-party atomic swap contract setup pioneered by bitcoincashautist backs tapswap.cash NFT marketplace. It uses coordinated UTXOs where both parties must provide inputs to complete the swap atomically. The pattern is documented in the simple-swap repository and demonstrates multi-party transaction coordination."
        }
      ]
    },
    {
      "name": "Ecosystem & Learning Resources",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What is CashScript Arena and how does it help developers learn?",
          "answer": "CashScript Arena (arena.layer1.cash) is a learning platform where developers challenge each other with intentionally broken or exploitable smart contracts. It targets complete beginners, starting with environment setup challenges and progressing through vulnerability exploitation exercises. This CTF-style approach teaches CashScript security patterns through hands-on experience finding and exploiting contract flaws."
        },
        {
          "question": "What general BCH development guides did CashScript documentation add?",
          "answer": "CashScript added Transaction Lifecycle (cashscript.org/docs/guides/lifecycle) and Adversarial Analysis (cashscript.org/docs/guides/adversarial) guides. These cover general BCH development concepts that were previously assumed knowledge but never formally documented. They help developers understand transaction processing stages and potential attack vectors when designing contracts."
        },
        {
          "question": "What is CashScript-Py and why is it important?",
          "answer": "CashScript-Py is a Python version of the CashScript SDK being developed to bring BCH smart contract programming to Python developers. Python is one of the world's most popular languages, but Python developers currently have few tooling options for BCH smart contracts. CashScript-Py aims to attract new developers and enable new application categories."
        },
        {
          "question": "Why doesn't the CashScript VSCode extension appear in Cursor's extension marketplace?",
          "answer": "Cursor uses the open-vsx marketplace instead of Microsoft's VSCode marketplace due to licensing restrictions. Extensions must be published separately to open-vsx to appear in Cursor. The workaround is either to download the VSIX file manually from open-vsx.org and install it, or wait for the extension to propagate after the developer publishes it to open-vsx."
        },
        {
          "question": "Can the CashScript playground be pre-populated with contract code via URL parameters?",
          "answer": "This capability was discussed as a feature request for CashScript Arena integration. The idea is to add an 'open in playground' button that would open the playground with a specific contract pre-loaded, instantiated, and with parameters prepared. This would make it super easy for beginners to start working with contracts. Implementation is feasible but wasn't available at the time of discussion."
        },
        {
          "question": "How can you create unique contract addresses for faucets without changing contract logic?",
          "answer": "Use an index parameter as a constructor argument that doesn't affect contract behavior. Example: `require(index >= 0);` - this uses the index to avoid compiler warnings about unused variables while allowing each user to generate a unique address by choosing their own index. This pattern lets faucets fund unique addresses for different users without changing contract rules."
        }
      ]
    },
    {
      "name": "Version History & Major Releases",
      "description": "",
      "source": "CashScript",
      "faqs": [
        {
          "question": "What major changes were in CashScript v0.12.0?",
          "answer": "Version 0.12.0 removed the old deprecated TransactionBuilder, introduced getVmResourceUsage() to measure VM resource usage, added new TransactionBuilder safety options, and included several small breaking changes. This was a maintenance-focused major release cleaning up deprecated functionality and improving developer safety features."
        }
      ]
    },
    {
      "name": "CashFusion",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Can CashFusion run in EC daemon mode without GUI?",
          "answer": "Not out-of-the-box, but theoretically possible with configuration. Josh asks: 'can fusions happen when running EC as a daemon?' to work around Wayland crash issues. Pierre K's assessment: 'I don't think fusing can work out of the box in daemon mode, but adding a daemon command for it is not too difficult.' His 2022 research: 'i needed to add a daemon command to the cash fusion plug-in to call the plugin's enable_autofusing method for each loaded wallet and then start tor.' JF provides workaround: 'there's a wallet level param cashfusion_autofuse' - if set to true in wallet file, might enable fusion. Dustin elaborates: 'when you leave it on in the wallet and close it, it is still on when you re-open, so maybe if you load the wallet in daemon mode it would fuse.' Key insight: Fusion state persists in wallet file, so enabling via GUI once, then running daemon might work. Pierre: 'Maybe there is a way just by hacking the config file or the wallet file prior to starting the daemon that i missed.' Community needs testing to confirm."
        },
        {
          "question": "Why doesn't CashFusion work in daemon mode and what's the workaround?",
          "answer": "Daemon mode lacks automatic fusion initialization. Josh tested: 'When running in daemon mode, I open another terminal and run AppImages/electron_cash.appimage daemon -C cashfusion_autofuse just to see if it'd do something but nope...just start, stop, status, load_wallet, and close_wallet.' Pierre K's research from 2022: 'i needed to add a daemon command to the cash fusion plug-in to call the plugin's enable_autofusing method for each loaded wallet and then start tor.' No existing CLI command triggers fusion. Possible workaround: JF notes wallet stores 'cashfusion_autofuse' boolean - if enabled via GUI first, might persist. Dustin: 'when you leave it on in the wallet and close it, it is still on when you re-open, so maybe if you load the wallet in daemon mode it would fuse.' Pierre: 'Maybe there is a way just by hacking the config file or the wallet file prior to starting the daemon that i missed.' Not confirmed to work. Real fix needs daemon command addition - Jonas jokes: 'Lmk when you add it to ABC so I can steal it!' Workaround for Wayland crash: Run GUI once to enable, then use daemon."
        },
        {
          "question": "Can CashFusion freeze coins causing problems with other wallet instances?",
          "answer": "Yes on same machine/wallet file, NO across different machines. Adaptive Blocksize Limit: 'I couldn't pledge to fundme until i went home and close my EC wallet to shutdown cashfusion... i used paytaca and Selene.' JF explains: 'CF freezes coins temporarily while doing fusions, so you might not be able to use them for a pledge... If you're talking about different machines, it doesn't make sense. one machine doesn't know what the other is doing.' Key distinction: Same wallet file access = conflict. Same seed on different machines = no conflict. Adaptive: 'Same wallet different machine, one desktop ec the other is Paytaca or selene on mobile trying to pledge.' Dustin: 'Nothing on chain knows about the cashfusion round until the tx is broadcast... Stopping EC immediately allowing it to work is going to have to do with something environmental outside of EC / blockchain.' Possible explanation: Unconfirmed CashFusion transactions spending UTXOs that mobile wallet tries to use. Mobile wallet sees UTXOs as available, tries to spend, but they're already in mempool. Workaround: Wait for CF round to complete or disable CashFusion temporarily."
        }
      ]
    },
    {
      "name": "CashTokens & NFTs",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Is there a CashTokens transaction history export feature in Electron Cash?",
          "answer": "No, currently there is no dedicated CashTokens history export function in Electron Cash. Regular BCH transaction history can be exported, but token-specific transaction data export is not yet implemented as a built-in feature."
        },
        {
          "question": "How do I view CashToken metadata (names, icons) in Electron Cash?",
          "answer": "Currently, BCMR (Bitcoin Cash Metadata Registry) resolution requires explicit user action via a context menu in CashToken-related tabs. Right-click on a token and select 'Resolve Metadata'. This was intentional to prevent fraud (someone could mint fake tokens with misleading metadata). However, many users don't know about this feature and only see cryptic token IDs. The EC team is considering: 1) Auto-resolve with opt-in/opt-out toggle, 2) Show metadata but mark tokens as 'unknown' until user approves. Note: EC's BCMR resolver doesn't fully support the spec yet and doesn't follow auth-chains for updates."
        },
        {
          "question": "Why don't CashToken tabs show by default in Electron Cash?",
          "answer": "The CashToken tabs are currently hidden by default and must be enabled manually in preferences. To enable them: go to Tools > Preferences > General and check the option to show token tabs. The development team is considering enabling these tabs by default in future versions since CashTokens are now a core part of the BCH ecosystem. Until then, users need to manually enable them to see their tokens."
        },
        {
          "question": "What is the Paytaca BCMR Indexer and can Electron Cash use it?",
          "answer": "The Paytaca BCMR Indexer (https://github.com/paytaca/bcmr-indexer) is a service that indexes Bitcoin Cash Metadata Registry information for CashTokens. It provides API endpoints for resolving token metadata. While EC currently does its own BCMR resolution (with limitations), developers are considering using Paytaca's indexer as an alternative since it's more complete and follows auth-chains properly. The trade-off is that it's a centralized service, but it's easier and more reliable than EC's current implementation."
        },
        {
          "question": "How do I fetch NFT-specific metadata (icons, names) in Electron Cash?",
          "answer": "As of Feb 2025, EC supports NFT-specific BCMR metadata. Right-click on an NFT in the tokens tab and select 'Fetch NFT Metadata' to download and apply the token's icon and name. This is different from category-level metadata - NFTs can have individual images/names. EC now uses Paytaca's BCMR indexer for fast metadata downloads, with blockchain lookup as fallback. Note: Icons appear small in the current UI but the data is accurate. The 'Category Properties...' context menu is for token category metadata, not individual NFTs."
        },
        {
          "question": "Can I configure Electron Cash to use my own BCMR indexer instead of Paytaca's?",
          "answer": "Not yet configurable via UI (as of Feb 2025). EC hardcodes Paytaca's indexer with blockchain fallback. To use custom indexer, it must follow Paytaca's API format (there's no universal standard yet). Options for custom metadata: DNS-resolved BCMR (part of spec but less supported) or matching Paytaca's API. The authority/registry providing metadata should ideally be shown in UI for transparency, but this isn't implemented yet."
        },
        {
          "question": "Does Electron Cash support BIP21 URI format for CashTokens?",
          "answer": "As of Feb 2025, EC does not yet implement the proposed BIP21-style query parameters for CashTokens. The proposal (documented at bitcoincashresearch.org) suggests adding token information to bitcoincash: URIs, like: bitcoincash:addr?token_category=xxx&token_amount=yyy. This would enable QR codes and payment links to request specific token payments. Feature is on the radar but not implemented. For now, CashToken transfers require manual entry of token category and amount in EC's token sending interface."
        },
        {
          "question": "Does Electron Cash support SLP tokens?",
          "answer": "No, Electron Cash does not support SLP (Simple Ledger Protocol) tokens. SLP tokens were an earlier token standard on BCH that has been largely superseded by CashTokens. SLP is considered a 'failed experiment' with very limited exchange support remaining. EC focuses on CashTokens as the native token protocol. If you have SLP tokens, you'll need to use specialized SLP-compatible software (though options are limited). CashTokens provide better functionality and are built directly into the BCH protocol."
        },
        {
          "question": "What is the 'Fetch Category Metadata' option in CashTokens tab?",
          "answer": "This is a newer feature (added to master branch around March 2025) that allows you to fetch BCMR metadata for token categories directly from the Token History tab. Right-click on a token transaction or category and select 'Fetch Category Metadata' to download names, icons, and descriptions. This is more convenient than the older method of going into 'Category Properties' and clicking 'Apply'. The feature uses Paytaca's BCMR indexer to quickly resolve token information. Future versions may include 'Update All' functionality to fetch metadata for all tokens at once."
        },
        {
          "question": "What are the requirements for a CashToken to show BCMR metadata in Electron Cash?",
          "answer": "For your token's metadata to be resolvable in EC: 1) Register your token's BCMR (Bitcoin Cash Metadata Registry) JSON file according to the spec, 2) Have it indexed by Paytaca's BCMR indexer (EC's primary source), 3) For DNS-based resolution: publish BCMR at specific DNS location. The metadata JSON includes: token name, symbol, icon URLs, decimals, and other properties. EC fetches this data when user right-clicks token and selects 'Fetch Category Metadata' or 'Fetch NFT Metadata'. Not all BCMR spec features are supported yet (e.g., auth-chain following for updates)."
        },
        {
          "question": "Why don't all BCH wallets properly display balance when CashToken change outputs contain both tokens and satoshis?",
          "answer": "When a transaction creates a change output containing both remaining tokens AND remaining satoshis (common with airdrop tools), some wallets fail to recognize the satoshis portion in their balance. EC was actually one of the few wallets that showed the change output, but even EC didn't list those satoshis in the normal balance or allow spending them via 'send max'. Fix: Send all tokens from that output back to yourself, which forces creation of a separate BCH-only output that wallets recognize. You may need to send yourself some satoshis first to cover the transaction fee. This is a wallet UI/accounting issue, not a protocol problem - the satoshis are safe on-chain."
        },
        {
          "question": "Why does my BCMR token show 'no metadata available' in Electron Cash?",
          "answer": "EC fetches BCMR metadata primarily from Paytaca's indexer. If your token shows 'no BCMR data available': 1) Token's BCMR JSON file may not be properly registered according to BCMR spec, 2) Paytaca's indexer hasn't indexed it yet, 3) DNS-based resolution isn't configured correctly. Verification steps: check if token metadata appears on tokenexplorer.cash (if yes, indexer problem; if no, registration problem). Solutions: ensure BCMR JSON is published at correct location per spec, contact Paytaca about indexer inclusion, verify token was minted with proper genesis metadata. Not all tokens have BCMR metadata - it must be explicitly set up by the token creator."
        },
        {
          "question": "Does Electron Cash support QR codes for CashToken addresses?",
          "answer": "Currently no - EC doesn't have built-in option to generate QR codes for token-aware address format (prefixed with 'bitcoincash:z' instead of 'bitcoincash:q'). Important clarification: Token addresses and regular addresses are the SAME underlying address, just displayed differently. The 'z' prefix indicates to wallets that this address can receive tokens. If you send tokens to regular QR code (q-prefix), they still arrive at same address and EC will see them fine. For other wallets, they should also find the tokens since it's same key derivation. Workaround: Use external QR code generator with your token address string. GitHub issue #3096 tracks this feature request. Not many users have needed it yet."
        },
        {
          "question": "How do I burn unwanted tokens or dust in Electron Cash?",
          "answer": "Token burning creates transaction where tokens are inputs but not outputs - they cease to exist. Current EC doesn't have one-click burn feature (removed sending to OP_RETURN for tokens). Methods: 1) Wait for PRs adding burn functionality to merge, 2) Use CLI with text editor to craft transaction manually, 3) Send tokens to provably unspendable address. For BCH dust (tagged addresses from dusting attacks): Can still send to OP_RETURN in EC. Note: OP_RETURN itself is unneeded for burning - any transaction that doesn't include token in outputs destroys it. The OP_RETURN aspect just documents the intent. Feature request: Simpler burn UI for tokens."
        },
        {
          "question": "Why doesn't Electron Cash show the CashTokens tab by default?",
          "answer": "In EC version 4.4.x releases, CashTokens functionality exists but requires manual enabling via View menu. This confuses new users expecting token support. Good news: The fix to show CashTokens tab by default is already in the codebase (master branch), just awaiting next official release. JF: 'its already in the codebase, we just haven't done a release in a while.' For immediate access: 1) Enable via View > Show Tokens (current releases), 2) Use EC SLP edition (different wallet, not recommended for CashTokens), 3) Build from source to get latest features, 4) Wait for upcoming release (planned for late 2025). Note: EC SLP edition is different product optimized for SLP tokens, not CashTokens. For testnet token experimentation, building from source or waiting for release is recommended over EC SLP."
        },
        {
          "question": "Why doesn't Electron Cash address search find CashTokens addresses?",
          "answer": "Known bug: Address tab Ctrl+F search only finds legacy (non-token) addresses, not token addresses. Damascene reports: 'if I go to Receive tab and copy Token address then go to Address tab and hit Ctrl+F... it doesn't show.' emergent_reasons confirms: 'right. I think it's just a miss in the tokens upgrade.' Issue opened as GitHub #2641 two years prior. Workaround: Switch to legacy address format from bottom status bar, then search works for legacy addresses. Root cause: CashTokens upgrade added token-aware addresses but search functionality wasn't updated to handle new format. Low priority bug since most users access addresses directly rather than searching. Fix would require updating address_list.py search logic to normalize addresses before comparison. emergent_reasons suggests filing on GitHub issues for tracking."
        },
        {
          "question": "How do you detect CashTokens transactions programmatically in EC?",
          "answer": "Multiple methods available. Adaptive Blocksize Limit's research: 'You can detect token transactions by checking for a tokenData field in BCHN or Fulcrum responses, or by scanning for the 0xEF prefix in raw transaction outputs.' Event handling: 'The payment_received event still fires normally because CT outputs include BCH dust, so the wallet recognizes them as valid UTXO you just need to inspect the tokenData to confirm it's a token payment.' Wallet setup: 'The standard restore_wallet_from_seed() works fine for receiving and detecting tokens, so basically you only need a build if you want to mint, send or burn CT.' BCHN RPC: 'BCHN exposes a tokenData object for every output carrying tokens' - documented at docs.bitcoincashnode.org. Key insight: CashTokens always include BCH dust (minimum sat amount), so normal UTXO detection works - you just need additional parsing for token-specific fields. This enables services like BitCartCC (payment processor) to support CashTokens."
        },
        {
          "question": "What gaps exist in EC's CashTokens payment request support?",
          "answer": "Payment request feature doesn't fully support CashTokens yet.  (MrNaif_bel) discovered: 'payment requests feature doesn't support cashtokens, and that's what we use for invoices feature.' Issue details: 'what I just noticed in the output is the tokenreq property, but it's a boolean which is set only by the kotlin gui, and it doesn't do anything in code (maybe only visual filtering).' Events work: 'it indeed fires new_transaction and payment_received events' - basic detection fine. Missing functionality: 1) No way to specify required token amount in payment request, 2) No automatic verification that enough tokens were sent, 3) tokenreq boolean is unused placeholder. Impact: Payment processors like BitCartCC can't easily create invoices requiring specific CashToken amounts. Next step: 'I'll need to create a PR to add cashtokens support for payment requests.' This is infrastructure gap needing community contribution - basic plumbing exists but higher-level features need implementation."
        },
        {
          "question": "How does CashTokens detection work at the protocol level?",
          "answer": "Uses 0xEF prefix marker in transaction outputs. Adaptive Blocksize Limit explains: 'scanning for the 0xEF prefix in raw transaction outputs' identifies token transactions. Technical details: Standard BCH transaction outputs use locking script starting with standard opcodes. CashTokens prepends 0xEF byte followed by token data (category ID, fungible amount, NFT commitment). This prefix is consensus-validated - nodes recognize it as token marker. Fulcrum/BCHN parsing: 'BCHN exposes a tokenData object for every output carrying tokens' in JSON-RPC responses, containing category (token type ID, 32 bytes), amount (fungible token quantity), hasNFT (boolean), commitment (NFT data). Why BCH dust required: Every CashToken output must include at least 546 satoshis (dust limit) so it's valid UTXO. This means wallet's standard UTXO scanning finds tokens, but needs extra parsing to extract token metadata. Electron Cash 4.3+ has 'transaction parsing, and backend compatibility with Fulcrum' for full programmatic access to this data."
        },
        {
          "question": "How do CashTokens differ from Ethereum ERC20 tokens architecturally?",
          "answer": "Fundamentally different: UTXO-based vs account/contract model.  (MrNaif_bel) comparing while implementing BitCartCC support: 'a cashtoken transaction is a BCH transaction... with extra token metadata embedded. there's no such thing as contract methods, right?' Key differences: 1) No approve/allowance pattern - in ERC20 you approve spending before transfer, CashTokens uses direct UTXO spending, 2) No transferFrom - you can only spend UTXOs you own, 3) No gas problems - 'in eth if you receive a token to an empty address, you need to send eth there first to get it out but here because it's utxo, you can just spend it right away', 4) Metadata via BCMR registry instead of contract calls - decimals(), name() replaced by off-chain/on-chain registry lookups. Adaptive Blocksize Limit: 'its utxo VM pure utxo logic better than eth.' Simplicity benefit: 'so there is no concept of allowance? if yes, great, less complexity :D' - cleaner token model without approval vulnerabilities common in ERC20."
        },
        {
          "question": "How does EC resolve CashToken metadata (name, decimals, icon)?",
          "answer": "Multi-level fallback system prioritizing on-chain data.  discovered: 'somewhere deep in the code it uses paytaca indexer bcmr.paytaca.com and if not, it then tries to parse from token genesis tx or something.' Resolution order: 1) Try Paytaca BCMR indexer (centralized aggregator), 2) Fall back to on-chain BCMR embedded in genesis transaction, 3) Check DNS-based BCMR at /.well-known/bitcoin-cash-metadata-registry.json. Mathieu G clarifies: 'Most CashTokens use on-chain resolution, not DNS resolution.' On-chain embedding: Token creator can put BCMR JSON in OP_RETURN of genesis tx - fully decentralized, no external dependencies. Example registries: otr.cash/.well-known/bitcoin-cash-metadata-registry.json, meta.moria.money/m1.json (MUSD specific). For programmatic use: 'use the try_to_download_metadata function from token_meta, and save to cache' - EC provides this abstraction. 2qx notes: 'FBCH uses DNS' showing both approaches coexist."
        },
        {
          "question": "What core functions are needed to integrate CashTokens into a payment processor?",
          "answer": "'s implementation plan for BitCartCC identifies three essentials: 'we only need 3 things: detect payments (invoicing), get balance, send.' Detailed approach: 1) DETECT PAYMENTS: new_payment event fires for token receipts, filter by enabled tokens, parse token_data for amounts, 2) GET BALANCE: wallet.get_utxos(tokens_only=True), group by category_id, use token_meta.format_amount() for decimal handling, 3) SEND TOKENS: make_token_send_spec() to create data structure, wallet.make_token_send_tx(), wallet.sign_transaction(). Metadata handling: Create BasicTokenMeta class, call try_to_download_metadata() to get name/decimals, cache results. Storage: 'store only category id, name, decimals' - minimal footprint. Payment requests gap: tokenreq boolean exists but unused in code - needs PR to fully support requesting specific token amounts. Note: 'don't support NFT tokens' - focus on fungible tokens for payment use case makes sense."
        },
        {
          "question": "What is on-chain BCMR resolution vs DNS-based BCMR?",
          "answer": "Two approaches for CashToken metadata discovery. DNS-based: Token project hosts JSON at domain/.well-known/bitcoin-cash-metadata-registry.json - relies on web infrastructure, simpler to update but introduces external dependency. On-chain: BCMR JSON embedded directly in token's genesis transaction OP_RETURN - fully decentralized, immutable, no external lookups needed. Mathieu G: 'Most CashTokens use on-chain resolution, not DNS resolution.' 2qx counters: 'FBCH uses DNS. All the series weren't issued at once, but if they had been, it would have been about half the CashTokens issued.' Trade-offs: On-chain is censorship-resistant and permanent but harder to update metadata. DNS is flexible but requires maintaining web infrastructure. Practical impact: Wallets like EC query Paytaca indexer first (aggregates both), then fall back to on-chain parsing. Token explorers like tokenexplorer.cash resolve from chain. For payment processors: Can use EC's try_to_download_metadata() which handles both resolution types automatically."
        },
        {
          "question": "Why are BCMR registries decentralized rather than having single canonical source?",
          "answer": "Intentional design choice for censorship resistance and permissionlessness. Adaptive Blocksize Limit: 'Electron Cash doesn't hardcode any BCMR registry URLs but its just by design, BCMR is fully decentralized anyone can publish one.'  initially expected central registry: 'all current stablecoins and stuff, surely they are published somewhere?' Reality: Each token project publishes own BCMR, aggregators (Paytaca indexer) collect them but aren't canonical. Examples of fragmentation: otr.cash registry doesn't include MUSD, meta.moria.money/m1.json is MUSD-specific, tokenexplorer.cash aggregates from chain. For developers: Must handle multiple sources or rely on aggregator. 's solution: 'use try_to_download_metadata function from electroncash' which tries Paytaca then falls back to on-chain parsing - abstraction handles complexity. Trade-off: More robust (no single point of failure) but requires discovery logic. Similar to how Bitcoin doesn't have 'official' explorers - decentralization means redundancy and independence."
        },
        {
          "question": "What's the difference between CashToken category ID and token name?",
          "answer": "Category ID is cryptographic identifier, name is human-readable metadata. Category ID: 32-byte hash (genesis transaction ID), globally unique, immutable - this is what blockchain sees. Example: b38a33f750f84c5c169a6f23cb873e6e79605021585d4f3408789689ed87f366 (MUSD). Name: Human string like 'MUSD' or 'Moria USD' - stored in BCMR metadata, can theoretically be duplicated by different tokens. 's storage model: 'store only category id, name, decimals' - category_id is the key, name is display convenience. When integrating: 'wallet.get_utxos(tokens_only=True) tokens = group by category id' - always use category_id for logic, name only for UI. Decimals crucial: Different tokens have different decimal places, BCMR provides this info. Why this matters: You might have tokens with same name but different category_ids (one could be scam), always verify by category_id. Similar to how contracts on Ethereum have address as true identifier, not name."
        },
        {
          "question": "How does EC's payment_received event work with CashTokens?",
          "answer": "Standard event fires because CashToken outputs include BCH dust. Adaptive Blocksize Limit explains: 'The payment_received event still fires normally because CT outputs include BCH dust, so the wallet recognizes them as valid UTXO you just need to inspect the tokenData to confirm it's a token payment.'  confirms after testing: 'it indeed fires new_transaction and payment_received events.' Why dust required: Every CashToken UTXO must include minimum 546 satoshis (BCH dust limit) - consensus rule ensures tokens are valid UTXOs. Implementation: Event handler receives standard UTXO notification, then parse token_data field to check if it's token transfer. Filtering: 'we just filter by those enabled in the daemon' - only process tokens you care about. Gap discovered: 'payment requests feature doesn't support cashtokens... but I am not sure how to make it detect if I sent just enough tokens' - verification of correct token amount needs additional logic beyond event handling. This design elegance: Reuses existing UTXO infrastructure rather than creating parallel token-specific event system."
        },
        {
          "question": "Does EC cache CashToken metadata differently in GUI vs CLI mode?",
          "answer": "Yes, significant difference discovered. Dustin explains GUI behavior: 'EC keeps the metadata, though, at least in the GUI, you only have to download it once per token... it'll show the category ID only until you right click and fetch category metadata. Close and re-open before and after doing that, it's fetched when you hit fetch.' However,  found CLI limitation: 'in all usages of cli it doesn't save the cache back to disk :D' - metadata downloads but isn't persisted. Details: GUI stores in simple config after manual fetch, persists across sessions. CLI loads cache if exists but doesn't write new entries. : 'well if I checked correctly that's the point, it silently fetches it in background but still doesn't cache anywhere.' Dustin suggests: 'I wonder if the CLI uses the cache when it exists...'  confirms: 'it does, but if I checked correctly, in all usages of cli it doesn't save the cache back to disk.' This inconsistency affects payment processor integrations - need to implement own caching layer or fix EC's CLI caching."
        },
        {
          "question": "How should CashToken amounts be represented in payment request CLI commands?",
          "answer": "Integer base units preferred for backend, formatted amounts for display. 's analysis: 'amount is integer in whatever unit it is and it works but amount (BCH) makes no sense for cashtokens.' Problem: Payment requests show 'amount (BCH)' field with formatted decimal value - meaningless for tokens with different decimals. Options: 1) Add 'token_amount' field with raw integer (no formatting), 2) Query BCMR for decimals and format as 'amount (TOKEN_NAME)', 3) Let consumers handle formatting themselves.  prefers: 'basically if I want to format the payment request I need to request it's BCMR metadata via paytaca indexer/search in blockchain, which might be an expensive operation.' His approach: Cache decimals on his side (BitCartCC), not burden EC with additional caching. Dustin suggests: 'I would leave amount (BCH) but you could add token_amount and not worry about token_amount (whatever)' - backwards compatible. Consensus: Raw amounts in smallest unit (like satoshis) internally, formatting is presentation layer concern. No standard term for CashToken's smallest unit (satoshi equivalent) yet established."
        },
        {
          "question": "What PR added CashTokens support to EC payment requests?",
          "answer": "PR #3144 by  (MrNaif_bel from BitCartCC). Announcement: 'The PR for cashtokens in paymentrequests is up: github.com/Electron-Cash/Electron-Cash/pull/3144.' Implementation details: 'I didn't add amount formatting because didn't get a reply here' - uses raw integer amounts (like satoshis) rather than decimal-formatted token amounts. Decision was intentional to avoid BCMR metadata caching complexity. Additional discovery: 'Also noticed another bug I'll submit a fix for later - if to pay a payment request of let's say 1 BCH in 2 payments, first of 0.1 BCH, second of 1 BCH, initially it returns first tx hash. after paying 1 BCH it returns only the second tx hash, but not both.' Fix exists in upstream Electrum to backport. Context: BitCartCC (BCH payment processor) integrating CashTokens support, needs this EC feature for invoicing. Shows ecosystem development: Third-party services contributing back to core wallet infrastructure. Community appreciates: Shadow gives thumbs up. PR under review by maintainers."
        },
        {
          "question": "What payment request testing did BitCartCC developer contribute?",
          "answer": " (MrNaif_bel) integrated and tested CashTokens in payment requests. JF asks: 'does anyone have time to give this a quick test?'  responds: 'I did test it with my integration with electroncash, but not many people use paymentrequests directly. Though I think it's used by the GUI in the receive tab indirectly.' Context: BitCartCC is payment processor service (similar to BTCPay Server for BTC). Integration testing: Covered daemon API usage (addrequest/getrequest commands), token detection in payment events, amount handling without decimal formatting. JF's response: 'cool. thanks for the contribution! Would be good to get one more person to test it out if anyone is around. happy to merge it.' Best practice demonstrated: Third-party service developers contributing back to wallet infrastructure. Their production use cases reveal gaps (like missing CashTokens support). Testing scope:  noted GUI testing needed since receive tab uses payment requests internally. His use case is CLI/daemon primarily. Shows healthy ecosystem: External developers finding issues, writing fixes, testing against real-world usage patterns."
        }
      ]
    },
    {
      "name": "Community & Resources",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "What happened to the official Electron Cash Twitter/X account?",
          "answer": "The @electroncash X/Twitter account was lost due to dormancy lockout - X/Twitter wouldn't allow login after a period of inactivity. The account has ~2k followers but no one can access it. Recovery attempts are being made with X support, but success is uncertain. In the meantime, the EC community needs volunteers to manage social media if the account is recovered or if a new one is created. The handle and existing followers make recovery valuable, but X support is difficult to reach."
        },
        {
          "question": "Who are the current Electron Cash maintainers with GitHub merge privileges?",
          "answer": "As of February 2025, only two people have GitHub merge privileges: Calin Culianu (cculianu) and JF (Jf010). The project is open to more contributors joining with merge access. For social media accounts, Twitter/X accounts can be delegated without sharing passwords. The team follows a trust-based model where social media managers should be accountable and transparent about their identity. Anyone wanting to contribute code should submit pull requests which will be reviewed by these maintainers."
        },
        {
          "question": "How do I report a bug in Electron Cash?",
          "answer": "Submit bug tickets to GitHub: https://github.com/Electron-Cash/Electron-Cash/issues. Include: 1) Steps to reproduce the bug, 2) Operating system and version (iOS, Android, Windows, Linux distro), 3) EC version number, 4) Screenshots if applicable, 5) Any error messages. For mobile-specific bugs (iOS/Android), mention device model and OS version. Test on different platforms if possible to narrow down the issue. The community appreciates detailed bug reports as they help developers fix issues faster."
        },
        {
          "question": "What happened to cashfusion.org's SSL certificate?",
          "answer": "The SSL certificate for cashfusion.org expired on March 30, 2025 due to lack of automatic renewal. This is a common issue with manually managed certificates. Solution for site operators: use certbot with automatic renewal via cron job or systemd timer to run the cert tool periodically. Sites like Let's Encrypt provide free certificates but require regular renewal (every 90 days). This doesn't affect CashFusion functionality in EC itself, just the informational website."
        },
        {
          "question": "Why haven't exchanges adopted CashAddr format yet?",
          "answer": "Despite CashAddr being standard since 2018, many exchanges still only support legacy (Base58/BTC-compatible) addresses. Reasons: 1) Low priority - BCH is small market cap coin for them, 2) Development resources allocated elsewhere, 3) Legacy addresses still work (wallets auto-convert), 4) No strong business incentive to update. This affects RPA/stealth address adoption prospects - if exchanges won't even support basic CashAddr, expecting them to implement complex stealth address infrastructure is unrealistic. Community expectation: adoption will follow market cap growth. When BCH reaches top 5-10, exchanges will prioritize BCH features. Until then, advanced features like RPA will remain wallet-to-wallet primarily."
        },
        {
          "question": "What is the Point-of-Sale (POS) gap in the Bitcoin Cash ecosystem?",
          "answer": "The BCH ecosystem lacks a well-developed point-of-sale system for HD wallets. Ideal POS requirements: 1) Open source for trust and customization, 2) Easy to deploy (no complex server setup), 3) Native app (not browser-based for performance), 4) Multi-platform: desktop, tablet, mobile, 5) HD wallet support (unique address per transaction), 6) Invoice generation with QR codes, 7) Payment detection and confirmation. Current solutions are fragmented - some browser-based, some closed source, some require server infrastructure. This remains a 'sore point' that RPA could partially address (static QR codes), but a proper POS solution with HD support is still needed for retail adoption."
        },
        {
          "question": "How do I convert BCH from Electron Cash to my bank account?",
          "answer": "EC is a non-custodial wallet - it doesn't handle fiat conversion. Process: 1) Create account on exchange (Coinbase, Kraken, Binance, etc.), 2) Complete KYC verification, 3) Get deposit address from exchange for BCH, 4) Send BCH from EC to that deposit address, 5) Wait for confirmations (varies by exchange), 6) Sell BCH for fiat on exchange, 7) Withdraw fiat to bank account. Important: Exchanges have withdrawal limits, fees, and processing times. Alternative: Peer-to-peer sales (LocalBitcoin.cash, etc.) for more privacy but more risk. EC just holds and sends BCH - all fiat conversion happens on external services."
        },
        {
          "question": "Why doesn't Google banning custodial wallets affect Electron Cash?",
          "answer": "Google's crypto wallet licensing requirements target custodial services (exchanges, services holding user funds) not non-custodial wallets (user controls keys). Key distinction: EC is non-custodial - your keys stay on device, EC never controls your funds. Custodial services need licensing because they operate as financial institutions. This is actually positive: 1) Forces users/regulators to understand custodial vs non-custodial difference, 2) May cause exchanges to be labeled differently than wallets, 3) Highlights that EC is true self-custody. However, community remains vigilant - Google could still change policies. Alternative distribution (F-Droid, direct APK) remains important backup."
        },
        {
          "question": "Can BCH integrate with Nostr protocol for tipping and payments?",
          "answer": "Yes, and easier than previously thought! Initial concern: BCH uses secp256k1 ECDSA while Nostr uses Schnorr signatures - different signature algorithms would produce incompatible keypairs. Reality: Bastian Carmichael's proof-of-concept showed you CAN derive BCH address from Nostr npub (public key) directly. Same elliptic curve (secp256k1) underlies both, just different signature schemes. Implication: No NIP (Nostr Improvement Proposal) needed - can pay directly to BCH address derived from someone's Nostr identity. Use cases: Tip content creators, zap-style payments, social media micropayments. Current status: Proof-of-concept exists, needs wallet integration. Nostr currently uses Lightning Network but creator (fiatjaf) dislikes it - BCH could be better fit for instant payments."
        },
        {
          "question": "How does BCH-Nostr integration work for tipping and social media payments?",
          "answer": "BCH and Nostr share the same elliptic curve (secp256k1), enabling direct integration. Key insight: The npub (Nostr public key) is calculated from same private key that generates BCH address. Implementation: 1) User's Nostr identity directly maps to BCH address, 2) Tips can be sent without separate wallet setup, 3) No need for additional protocols (unlike Lightning Network zaps). Chris Troutner's slpdex.com demonstrates: group chat, Telegram bridge, E2EE DMs, profiles, leaderboards - all using Nostr with BCH payment capability. Benefits: Social media tipping without custodial service, accessible via VPN/Tor without captchas, decentralized identity tied to payment capability. Current implementations use web apps for accessibility, with BCH transactions happening on-chain. This contrasts with Lightning Network which Nostr currently uses - BCH offers simpler integration and aligns with creator (fiatjaf) who dislikes Lightning complexity."
        },
        {
          "question": "What are OstrichGram and Pumpstr in the BCH ecosystem?",
          "answer": "Both are Nostr clients with BCH integration: 1) OstrichGram - Cross-platform (desktop, mobile) Flutter-based Nostr client created by JF. Supports basic DM and group chat, with vision of adding Telegram bridge and wallet functionality. Open source: github.com/OstrichGram/OstrichGram. 2) Pumpstr - Web-based Nostr client for Bitcoin Cash. These represent community efforts to integrate BCH into decentralized social media infrastructure. Why this matters: Combines censorship-resistant messaging (Nostr) with censorship-resistant money (BCH). Both leverage that Nostr and BCH use same cryptographic curve, enabling payment addresses to derive directly from social identities. Competition between implementations drives innovation - different UX approaches (native app vs web), different feature priorities (privacy DMs vs public posting vs tipping). OstrichGram unique feature: Telegram bridge to allow cross-posting between platforms."
        },
        {
          "question": "What is StartOS and why are there barriers to BCH integration?",
          "answer": "StartOS (formerly Start9) is self-hosted server OS making it easy to run Bitcoin/Lightning nodes at home - plug-and-play sovereignty. Already supports BTC+Lightning, Fulcrum 2.0 now listed. Barrier to BCH (BCHN) integration: Primarily ideological, not technical. im_uname: 'historically the barrier is ideological, tho if they're somehow willing that would be fantastic.' StartOS team maintains specific perspective on Bitcoin maximalism. Technical packaging is straightforward - they provide hello-world-startos template and Matrix support channel for service packaging. Community efforts: Contact through Matrix (migrated from Telegram due to scammers), packaging BCHN+Fulcrum together, potentially including EC for CashFusion. Calin: 'Might be slight ideological reservation but that can be overcome I think.' Benefits if achieved: Home users could easily run full BCH infrastructure (BCHN node + Fulcrum + potentially EC) without Linux expertise, improving network decentralization and user privacy."
        },
        {
          "question": "What is the EC maintainer situation and why is it challenging?",
          "answer": "EC has limited maintainers despite being critical BCH infrastructure. Jonas: 'It's not like this project is packed by maintainers.' Challenges: 1) Adding new platform support (ARM64) requires ongoing maintenance - builds break, dependencies change, 2) Volunteer developers have limited time, 3) Complex build system requires deep knowledge (Docker, Python packaging, reproducibility), 4) Security implications mean careful review of all changes, 5) No full-time paid developers. Example: Chris Troutner built ARM64 AppImage but explicitly states 'I'm not planning to maintain this code base.' JF appreciates work done but recognizes burden. EchterAgo maintains build infrastructure, Jonas works on reproducibility fixes, JF and Calin on core features. Community can contribute: Report bugs on GitHub, test releases, donate to flipstarter campaigns for specific features. Specialized tasks need experts - not something anyone can pick up casually."
        },
        {
          "question": "What GitHub PRs were merged for EC in October 2025?",
          "answer": "Several PRs merged during active development period: 1) PR #3120 - Jonas' protobuf reproducibility fix (build paths deterministic), 2) PR #3126 - Small nuisance fix (details not specified in chat), 3) PR #3127 - Jonas whitelisted issues in audit tool: 'Looked thru the list of issues by the audit tool and whitelisted them all.' His summary: 'It makes a red thing turn green, and since I'm the only one on earth that looks at that thing it brings peace to my mind.' Also mentioned: GitHub issue #3121 related to some endorsement matter. JF merged PRs, noting active code review happening. Dustin has pending PRs that need conflict resolution (PR #3086). Community actively maintaining codebase despite limited maintainers. Important: These fixes primarily affect build infrastructure and developer experience, not end-user features. Shows healthy maintenance culture - even 'just makes green light' PRs valued for maintaining code quality standards."
        },
        {
          "question": "What is the GitHub workflow policy for EC maintainers with merge privileges?",
          "answer": "Flexible trust-based system. Jonas (newly granted merge privileges) asks: 'Are you OK with me just pushing changes to master if they don't touch the actual EC code? So changes like GitHub Actions, packaging and test cases going straight to master without any review?' JF approves: 'i think that should be fine. Calin usually makes it a point to look at all commits between releases, at least to describe what's in the release.. so the danger of something bad getting in should be minimal.' Calin's perspective: 'for bigger changes I tended to like the extra indirection where I can look at my changes 1 last time before merging... you are a very experienced software professional, Jonas, so I personally trust your judgement here.' Best practices: 1) Small infrastructure changes (CI, tests, packaging) can go directly to master, 2) PRs provide visibility even without formal review - Calin: 'i like the fact that it was a PR because I saw what is going on', 3) Core EC code changes need more scrutiny, 4) Tag maintainers in Telegram for urgent reviews. emergent_reasons: 'it's always safer to just go ahead and make a PR to look at yourself and give someone at least a small window to check it out.'"
        },
        {
          "question": "How do you set up GitHub-to-Telegram notifications for EC repository activity?",
          "answer": "Jonas created dedicated notification channel. Announcement: 'I have fixed the GitHub notifications. To not create noise in this channel I've created a new one where interested parties can see when Issues and PRs are opened and closed: https://t.me/electroncashnotifications' Background: JF noted: 'honestly i dont always check the notifications, but if you tag me here i'll def see it.' Problem: GitHub email notifications often ignored, Telegram more immediate. Implementation: Bot forwards GitHub webhook events to dedicated channel. Benefits: 1) Main EC channel stays focused on discussion, not automated noise, 2) Interested parties opt-in to notifications, 3) PRs get visibility faster, 4) Issue tracking more transparent. Jonas' first task after getting merge privileges: 'I have, as a first order of business, closed ~100 issues (all android) as duplicates' - shows active maintenance happening. This infrastructure improvement helps maintain open source project with distributed volunteer team across timezones."
        },
        {
          "question": "What is best practice for merging your own PRs as a maintainer?",
          "answer": "Balance between review and velocity. Calin advises Jonas: 'You can always PR, let it sit for a few minutes then merge or skip that altogether.' For infrastructure changes: Self-merge acceptable. JF: 'for bigger changes I tended to like the extra indirection where I can look at my changes 1 last time before merging to master - sort of see them up on screen in the browser as a diff.' Benefits of PR even for self-merge: 1) CI runs before hitting production (emergent_reasons: 'It should also give the CI an opportunity to hit any CI snags before hitting production'), 2) Provides audit trail, 3) Other maintainers see activity via notifications, 4) Forces self-review in different context. Jonas' approach: Created PR #3128, waited one day, merged himself. Calin: 'you could have even pushed directly for that too tbh.. it's tests so' but 'i like the fact that it was a PR because I saw what is going on.' Trust matters: Jonas given autonomy because experienced professional, but transparency valued even when formal review not required."
        },
        {
          "question": "What is fastlane and why did it raise concerns in EC repo?",
          "answer": "Fastlane is mobile app automation tool for app store submissions. emergent_reasons: 'fastlane seems to be an automation setup for mobile apps.' Used for: Automating screenshots, uploading to app stores, managing metadata. PR #3137 added fastlane configuration for F-Droid submission. Concerns: 1) Unknown developer submitted it without prior discussion, 2) Includes GitHub Action that runs on PR events, 3) Contains app screenshots in repo (Jonas: 'I'm not sold on having screenshots of the app within the git repo'), 4) Copied from Electrum but not customized explanation. Dustin: 'looks like someone trying to include EC on F-Droid based to that.' Jonas investigates: 'It seems like the fastlane metadata can be used when updating on Google Play Store also, which I guess is useful.' Tom: 'IIRC f-droid allows you to have a second repo with the fdroid specific stuff.' Jonas' preference: 'any Android specific metadata should be in the android/ subdirectory' not repo root. Decision: Wait for known maintainers to review before merging anything from unknown contributor."
        },
        {
          "question": "Is Electron Cash developed by a company with paid support staff?",
          "answer": "No, EC is volunteer-driven open source project. emergent_reasons clarifies when user asks for help: 'It's not a company - just volunteers who use and support Electron Cash. If you have a question, please post here.' Important implications: 1) No paid support staff, 2) No guaranteed response times, 3) Development depends on volunteer availability and interest, 4) Funding comes from flipstarter campaigns for specific features. Community structure: Core maintainers (Calin, JF, Jonas, EchterAgo) donate time, regular contributors (Dustin, emergent_reasons, Shadow) help with support and testing. Best practices for getting help: Post questions in public Telegram channel (not DM to avoid scams), provide technical details (version, OS, wallet type), check GitHub issues first, be patient. Contribution welcome: Anyone can submit PRs, report bugs, test releases, write documentation. JF notes: 'its an open source project. in theory anyone should be able to contribute.' Warning: emergent_reasons reminds: 'Please don't post payment links' - scam vectors exist, official channel is volunteer-run community, not commercial service."
        },
        {
          "question": "When is the next EC release planned and what's included?",
          "answer": "Planned for approximately 2 weeks (mid-November 2025). Calin announces: 'Yes very soon I just need to approve some PRs and also do some tweaks for @moleccc.. probably in 2 week or so maybe.' Key feature: CashTokens tab enabled by default (was disabled in 4.4.2). Mathieu G: 'I know the CashTokens tab is disabled by default in the last release but would be enabled by default in the upcoming release.' Calin confirms: 'I agree that should be done.' Already merged: 'I think the PR was already merged some time back, just never got in a release afaik.' Other PRs pending merge: #3144 (CashTokens payment requests), #3145 (export history P2SH addresses fix), various infrastructure improvements. Calin: 'It's easy like 1 line change. It's in main_window.py.' Release will include all merged improvements since 4.4.2 (reproducibility fixes, audit tool whitelisting, ARM64 documentation). Shows steady development pace despite volunteer-only maintenance."
        },
        {
          "question": "What PR updates are happening in EC codebase for November 2025?",
          "answer": "Multiple infrastructure improvements pending. Notable PRs: #3155 - Kallisti updates desktop explorer list: 'Opened a PR to update the EC desktop explorer list.' Maintenance task - keeping external service links current. Earlier merged: #3144 (CashTokens payment requests), #3145 (P2SH export addresses), various reproducibility fixes.  (BitCartCC) continues contributing, discovering gap limit issue next. Community activity: Doramas publishes CashFusion article at bitcoiniscash.org/bitcoin-cash-privacy/, expanding learning resources. Regular 'Fusion Friday' community events continuing (Fiendish posts weekly). GitHub notifications now forwarded to t.me/electroncashnotifications. JF notes SLIP-39 as potential contribution: 'low hanging fruit to do just do what electrum did' - showing path for community members to contribute. Healthy open source dynamics: External developers (BitCartCC), community members (Kallisti, Doramas), core maintainers all contributing. Shows project sustainability despite volunteer-only model."
        }
      ]
    },
    {
      "name": "Configuration & Settings",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Why does my Electron Cash show an incorrect BCH price (e.g., showing $13,000 instead of actual price)?",
          "answer": "This happens when the price API source (like CoinCap) has incorrect data. Electron Cash fetches live prices from external APIs, and if that API returns wrong data, your wallet will display incorrect fiat values. This can be costly if you're making trades based on the displayed price. Solution: Go to Tools > Preferences > Fiat and switch to a different price source. Always verify the displayed price against other sources before making important transactions."
        },
        {
          "question": "Why does 'No FX rate available' appear in Electron Cash?",
          "answer": "This occurs when the configured price API provider is down or blocked. Common causes: 1) The specific API provider is having issues (CoinCap has been unstable, BitcoinAverage is dead), 2) Your firewall is blocking connections, 3) VPN is blocked by the API provider. Solution: Go to Tools > Preferences > Fiat and switch providers. Working providers (as of Jan 2025): CoinGecko, Coinbase, Kraken, BitPay, Bitstamp, Yahoo Finance. CoinCap and BitcoinAverage should be avoided."
        },
        {
          "question": "Which fiat price providers work best in Electron Cash?",
          "answer": "Recommended working providers: CoinGecko (most commonly used), Coinbase, Kraken, BitPay, Bitstamp, Yahoo Finance. Avoid: CoinCap (unstable, sometimes shows wrong prices like $13k), BitcoinAverage (dead service, should be removed). Access via Tools > Preferences > Fiat. Note: VPNs may cause issues as many sites blanket-block known VPN providers."
        },
        {
          "question": "What does 'Spend only confirmed coins' option do in Electron Cash?",
          "answer": "When enabled (Tools > Preferences > Transactions), EC will only spend UTXOs that have at least one confirmation. This provides slight security benefit: prevents spending unconfirmed change from previous transactions that might not confirm. It's useful when: 1) Making multiple transactions in succession, 2) During network congestion, 3) For extra assurance coins are truly spendable. Downside: you can't immediately respend coins from unconfirmed transactions, which may slow down workflows. For most users, leaving it off is fine since BCH confirms quickly."
        },
        {
          "question": "What is happening with the CoinCap price API in Electron Cash?",
          "answer": "CoinCap deprecated their v2 API on March 31, 2025. The v3 API requires an API key and charges for requests. EC users should switch to alternative price providers: CoinGecko, Kraken, Coinbase, BitPay, or Bitstamp (Tools > Preferences > Fiat). CoinGecko is recommended as a free alternative. This is a reminder that free API services often get discontinued, so relying on multiple sources is wise. EC developers may need to remove CoinCap from options or implement the new paid API."
        },
        {
          "question": "How do I fix tiny fonts in EC AppImage on 4K monitors?",
          "answer": "Set the Qt scale factor environment variable: `env QT_SCALE_FACTOR=2 ./Electron-Cash-4.4.2-x86_64.AppImage`. Adjust the number (1.5, 2, 2.5) based on your monitor's DPI and preference. For Wayland issues combined with scaling: `env -u WAYLAND_DISPLAY QT_SCALE_FACTOR=2 ./Electron-Cash-4.4.2.AppImage`. This is a Qt5 limitation - it doesn't have native high-DPI support like newer Qt6. Consider creating a desktop shortcut with these environment variables for convenience."
        }
      ]
    },
    {
      "name": "Debugging & Troubleshooting",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "How do I get detailed error logs from Electron Cash?",
          "answer": "Run the Electron Cash AppImage from terminal with the -v (verbose) flag. This will show the full Python traceback including source code line numbers. The error dialog in the GUI often only shows the final error message without the stack trace. Example: ./ElectronCash.AppImage -v"
        },
        {
          "question": "What does 'RuntimeError: dictionary changed size during iteration' mean and can it corrupt my wallet?",
          "answer": "This Python error occurs when EC's internal data structures are modified during iteration (threading issue). Yes, this can potentially corrupt your coins list, requiring a wallet rebuild. If you see this error, run EC with the -v flag for more detailed information. Consider rebuilding your wallet (Wallet menu > Information > Rebuild) to ensure coin data integrity. This is a known threading bug that occasionally occurs."
        },
        {
          "question": "What common Python environment issues prevent EC from running from source?",
          "answer": "Common issues include: 1) libsecp256k1 version conflicts (BTC vs BCH Schnorr signatures), 2) protobuf version mismatches ('cannot import runtime_version'), 3) PyQt5 vs PyQt6 conflicts, 4) SSL certificate verification failures with self-signed certs (switch to Let's Encrypt), 5) Python version incompatibilities after system updates. Solutions: Use virtual environment (venv) with site-packages, try Anaconda for clean environment, or fall back to AppImage. Running from source on ARM additionally requires manually compiling secp256k1."
        },
        {
          "question": "What does 'could not find paymentrequest_pb2.py' error mean when running EC from source?",
          "answer": "This error occurs when the protobuf file hasn't been compiled. Run the command shown in the error message: `protoc --proto_path=electroncash/ --python_out=electroncash/ electroncash/paymentrequest.proto`. You need to install the protobuf compiler first (protoc). This is a recent requirement - the pb2.py file needs to be generated from the .proto definition. This started happening around late 2024/early 2025 and affects running from source. The AppImage doesn't have this issue since it includes pre-compiled files."
        },
        {
          "question": "Why do I get protobuf version mismatch errors when running EC from source?",
          "answer": "The protoc compiler version and Python protobuf library version must match. Common scenario: System protoc (e.g., 3.19) generates *_pb2.py files that are incompatible with your Python protobuf library version (e.g., 5.27). Solutions: 1) Update Python protobuf: `pip install -U protobuf`, 2) Regenerate the pb2 files: `protoc --proto_path=electroncash/ --python_out=electroncash/ electroncash/paymentrequest.proto`, 3) Recreate your venv. The generated files contain version info in their headers - check both match your installed Python library. AppImages avoid this by bundling matching versions."
        },
        {
          "question": "Why does CashFusion on Android reject my correct wallet password?",
          "answer": "This is a reported bug where CashFusion on Android EC sometimes rejects the valid wallet password with 'password is not valid' error, even though it's the same password that unlocks the wallet. It doesn't happen with all wallets, only some. Workaround: File a bug report on GitHub with device model, Android version, EC version, and if possible, steps to reproduce. Include whether the wallet was created on Android or imported. This helps developers isolate the issue."
        },
        {
          "question": "How do I fix EC AppImage menus not showing on Wayland?",
          "answer": "Run the AppImage with Wayland display disabled: `env -u WAYLAND_DISPLAY ./Electron-Cash-4.4.2-x86_64.AppImage`. This forces EC to use XWayland (X11 compatibility layer) instead of native Wayland. This fixes menu rendering issues on some Wayland compositors. The AppImage bundles Qt5 which has varying Wayland support. Not all users experience this issue - some run EC on Wayland without problems depending on compositor and configuration."
        },
        {
          "question": "Why does EC mobile show 'invalid address' when scanning BitPay QR codes?",
          "answer": "BitPay changed their QR codes from simple address+amount format to URL-based format: `bitcoincash:?r=https://bitpay.com/i/xxxx`. Desktop EC supports these payment protocol URLs (fetches actual address from the URL), but EC mobile may not have implemented this BIP70/BIP72-style payment request feature yet. The merchant name and amount appear because they're in metadata, but the actual sending fails. Workaround: Use desktop EC to pay BitPay invoices, or wait for mobile update. Report as bug on GitHub for tracking."
        },
        {
          "question": "Why does EC Android get stuck on 'generating your addresses' when offline?",
          "answer": "This issue can occur on older Android devices (Android 7 from 2018 reported). The address generation process itself doesn't require network connectivity - EC should generate initial 20 addresses and stop if it can't verify usage on blockchain. Possible causes: 1) Very slow processor on old device (though stuck for days is excessive), 2) Potential bug specific to older Android versions, 3) Device resource limitations. Testing confirms EC Android works offline in airplane mode on modern devices. If experiencing this: try latest EC version, test same device online first to isolate the issue, and report bug on GitHub with device model and Android version."
        },
        {
          "question": "Why did CashFusion break after updating EC from git master with protobuf error?",
          "answer": "Error 'ImportError: cannot import name runtime_version from google.protobuf' occurs when your installed protobuf version (e.g., 3.20.1) is incompatible with regenerated fusion_pb2.py files that require newer protobuf features. The master branch updated the protobuf .proto files and regenerated Python stubs. Fix: Reinstall dependencies to get the new required protobuf version. Check that protobuf version in requirements.txt matches what's installed in your virtual environment. The 'runtime_version' import was added in protobuf 5.x, so you need to upgrade from protobuf 3.x. This is why using a Python virtual environment is recommended - you can easily update dependencies without affecting system packages."
        },
        {
          "question": "How do I rescan transactions if my EC wallet is missing transaction history?",
          "answer": "EC provides two options: 1) 'Wallet -> Rebuild History...' - Deletes local history and re-downloads everything from Fulcrum servers. Use this if you see addresses in your Addresses tab but transactions are missing. 2) 'Wallet -> Scan more addresses...' - Extends the gap limit to search for addresses further down the derivation path. Use this if addresses aren't showing up at all. If 'Scan more addresses' times out, retry - it switches servers on timeout. Check Addresses tab first: if receiving address shows under 'Used' or change address under 'Empty', but transaction history is missing, use Rebuild History. If addresses themselves are missing, use Scan more addresses."
        },
        {
          "question": "Can I recover a password-protected Electron Cash wallet file if I forgot the password?",
          "answer": "Unfortunately, no easy solution exists. If you have encrypted wallet file but forgot password: 1) EC cannot help you bypass password - that would defeat security purpose, 2) Try common passwords you've used, write them down as you test, 3) Check if you wrote password down somewhere in 2018-2019, 4) The wallet file SHOULD have had a seed phrase backup at creation - search for 12/24 word phrase, 5) Seed phrase can restore wallet without password. The encrypted file contains private keys but they're AES-encrypted with your password. Password cracking is theoretically possible but extremely slow without specialized tools. Lesson: Always backup both seed phrase AND remember/secure your password."
        },
        {
          "question": "What are Electron Cash's scalability limits for wallets with many addresses or UTXOs?",
          "answer": "EC has practical limits: 1) After ~30,000 addresses, start a new wallet - performance degrades significantly, 2) Wallets with 60k+ UTXOs on single address cause freezing (can't access Coins tab, can't type amounts), 3) Long-running CashFusion (years of 24/7 operation) creates massive address/UTXO counts, consuming 5-8GB RAM. GUI issues are worse than backend - opening Addresses tab with huge address count crashes client. Workarounds: Use CLI instead of GUI for operations, avoid clicking Addresses/Coins tabs, migrate funds to new wallet periodically. Root cause: EC tries to load everything into GUI lists at once instead of lazy-loading only visible items. Fix would require significant GUI refactoring."
        },
        {
          "question": "How do I recover funds from a wallet EC can't handle due to too many UTXOs?",
          "answer": "Multiple approaches: 1) Use EC CLI instead of GUI - may avoid GUI rendering issues, 2) Export individual private keys (WIF) from seed, import each address as separate wallet, 3) Set address gap to 0 to prevent wallet from scanning many addresses, 4) Use libauth or other library to derive private keys from seed phrase programmatically, 5) Create transactions programmatically using extracted private keys. For single address with 60k+ UTXOs: Even Fulcrum server may timeout on listunspent query - that much data challenges entire infrastructure, not just EC. Last resort: If it's testnet BCH (tBCH), consider starting fresh wallet and mining to new address instead of transferring."
        },
        {
          "question": "What's the difference between GUI freezing and backend issues in EC?",
          "answer": "Important distinction for troubleshooting: GUI issues freeze interface but wallet data may still be accessible via CLI or programmatic access. Example: Wallet with 60k UTXOs - Coins tab freezes GUI, but CLI commands or direct wallet access might work. EC's GUI renders entire lists in Qt widgets, causing hangs when data is large. CLI bypasses GUI rendering entirely. Solution path: If GUI freezes, try EC CLI commands (payto, listunspent, etc.) or export private keys and use external tools. Backend issues (Fulcrum timeout, database corruption) affect all access methods. Diagnosis: If wallet loads but specific tabs freeze = GUI issue. If wallet won't sync or balance wrong = backend/network issue."
        },
        {
          "question": "Why does EC AppImage crash after running for extended periods on Linux?",
          "answer": "Some users report EC 4.4.2 AppImage crashing silently after hours of running (especially during screen lock). Debugging steps: 1) Run EC from terminal in verbose mode to capture logs when crash occurs, 2) Check system logs (journalctl) for segfaults or OOM killer, 3) Monitor memory usage - EC can grow to 5-8GB RAM with large wallets, 4) Ensure AppImage has execute permissions, 5) Try different compositors (X11 vs Wayland differences). Possible causes: Memory leak over time, Qt/GUI framework issue, CashFusion threading problems. Most users report stable operation for weeks - if yours crashes consistently, likely specific to your configuration. Report issue on GitHub with verbose logs, distro version, desktop environment. Workaround: Restart EC periodically as preventive maintenance."
        },
        {
          "question": "What is a potential workaround for wallets with too many UTXOs that EC can't handle?",
          "answer": "Tom's suggestion for extreme UTXO count (60k+): Import wallet from later block height to get partial view. This means: 1) When restoring from seed, specify recent block height instead of genesis, 2) Wallet only sees transactions/UTXOs from that height forward, 3) Avoids loading entire transaction history that causes GUI freeze. Limitations: Loses access to older UTXOs (need full import for those), primarily useful for chipnet/testnet scenarios where history is less critical. Other approaches: Extract individual private keys and import each address separately (spreads load), use CLI instead of GUI (bypasses rendering issues), or programmatically construct transactions using libauth. Note: 60k UTXOs also challenges Fulcrum server - 'listunspent' query may timeout regardless of EC client."
        },
        {
          "question": "What causes Electron Cash AppImage build failures and how are they investigated?",
          "answer": "AppImage builds can fail even when nothing appears to have changed, often due to Python dependency issues. Example: cryptography package (required for TLS/encryption) pulls setuptools-rust which requires semantic_version, causing build errors. Puzzling aspects: 1) Dependencies pinned to specific versions in Docker containers should be deterministic, 2) Same version worked for releases a year ago, 3) No code changes but builds suddenly fail. Investigation steps: 1) Check GitHub Actions logs for specific error messages, 2) Identify which package is failing (often deep in dependency tree), 3) Try building locally vs CI environment to isolate issue, 4) Consider updating to newer package versions (but requires security review), 5) Verify Docker container hasn't changed base image. Solution often involves balancing: updating to latest (more secure, less audited) vs keeping old versions (tested but may not build). Package manager complexity is a can of worms requiring careful review to prevent malicious code insertion."
        },
        {
          "question": "What caused EC AppImage build failures in September 2025 and how was it fixed?",
          "answer": "Root cause: python-qrcode package version 6.1 had '[console-scripts]' group in entry_points.txt with dash in name, which setuptools doesn't allow. This caused semantic_version package installation to fail during cryptography package build. Debugging process by EchterAgo: 1) Traced error to pkg_resources AttributeError in egg_info, 2) Found qrcode-6.1.dist-info/entry_points.txt contained problematic [console-scripts], 3) Discovered upstream fix in python-qrcode PR #229. Solution: Update qrcode to version 7.4.2 (not 8.2 because srcdist builder uses Python 3.8 from Ubuntu 20.04, and qrcode v8+ dropped Python 3.8 support). Additional considerations: Must include SHA256 hashes for new package version, may need to add pypng as dependency, and typing-extensions also needed update. This exemplifies why 'messing with python packages is a can of worms' - even pinned versions in Docker containers can break due to transitive dependency issues."
        },
        {
          "question": "Why does Electron Cash reject JPP (JSON Payment Protocol) invoices from Paytaca?",
          "answer": "EC's JPP support is hardcoded to only accept payment requests from bitpay.com domain. When scanning QR code with bitcoincash:?r= payment URL pointing to watchtower.cash (Paytaca's payment processor), EC returns error: 'payment URL not pointing to a bitcoincash payment request handling server'. Technical details: EC successfully fetches the JSON payment request (returns valid response with payment_id, outputs, amounts, addresses, expiry time), but domain whitelist check fails. Jonas confirms: 'Only for paymentrequests from bitpay.com'. Impact: Merchants using Paytaca's WooCommerce plugin can't accept payments from EC users. Workaround: Use Paytaca wallet instead, or merchant provides plain address QR code. Fix needed: Expand EC's JPP domain whitelist to include other payment processors, or remove domain restriction entirely (security trade-off). This exemplifies tension between security (restricting to known providers) and ecosystem openness (supporting all JPP servers)."
        },
        {
          "question": "Why is Python 3.8 usage in EC build system problematic?",
          "answer": "EC's source distribution (srcdist) builder uses Ubuntu 20.04 which includes Python 3.8, but Python 3.8 reached End of Life (EOL) in 2024. Problems: 1) Newer packages drop 3.8 support (qrcode v8+ requires Python 3.9+), 2) Security vulnerabilities in EOL Python won't be patched, 3) Limits which dependency versions can be used. Example: Wanted to use qrcode 8.2 but had to fall back to 7.4.2 to maintain 3.8 compatibility. EchterAgo: 'ideally we'd also update srcdist to use a newer python, 3.8 is EOL.' Solution path: Update srcdist Docker container to use Ubuntu 22.04 (Python 3.10) or 24.04 (Python 3.12), but this is breaking change requiring extensive testing. Package version selection becomes constrained by oldest supported Python version in build matrix. This is why maintaining build reproducibility across years is challenging - upstream ecosystem moves forward while pinned versions create growing technical debt."
        },
        {
          "question": "Why do JPP (JSON Payment Protocol) invoices from Paytaca fail in wallets?",
          "answer": "URL encoding issue: QR code contains URL-encoded characters (%3A instead of :) that some servers don't properly decode. Kallisti (Paytaca dev): 'The %3A instead of : is throwing it off. We need to properly decode URLs in that format. Bug is on our end.' Additionally, EC's JPP implementation only accepts payment requests from bitpay.com domain (hardcoded security check). Jonas points to paymentrequest.py line 95 - when JPP was implemented, only BitPay used it. Even valid JPP responses fail EC's domain whitelist. Flowee Pay uses BIP-70 binary protocol, not JSON, and also has issues. Solution requires: 1) Server properly handling URL encoding, 2) EC expanding domain whitelist or removing restriction. BIP-70 (protobuf binary) vs JPP (JSON) both serve same purpose but different formats - BitPay invented JPP but servers should support both for broad wallet compatibility."
        },
        {
          "question": "Why is Python dependency management difficult for EC and what helps?",
          "answer": "Python ecosystem challenges: 1) Frequent Python version deprecation (3.8 EOL, currently on 3.11), 2) Package backwards compatibility breaks (e.g., Keras API changes completely between versions), 3) System package manager (apt) conflicts with pip, 4) Transitive dependency version conflicts. Real examples from EC: qrcode v8+ dropped Python 3.8 support, protobuf 5.x broke reproducibility, cryptography package pulls setuptools-rust. Shadow: 'Python ecosystem seems like a complete mess to me.' Solutions: 1) Use conda/miniconda for isolated environments (JF and emergent_reasons both recommend), 2) Never mix system Python packages with pip packages, 3) Pin dependency versions in requirements.txt, 4) Use virtual environments religiously. Dustin: 'virtual environments can be a must on Linux due to OS dependencies.' Jonas notes EC maintains Python 3.11 in AppImage (EchterAgo does this maintenance work), avoiding EOL issues for users of official releases."
        },
        {
          "question": "Why does Electron Cash crash when my Linux computer is locked but works fine during active use?",
          "answer": "Likely Qt framework bug rather than memory issue. User reports: EC crashes after screen lock despite 32GB RAM, works fine for hours during active computer use (browsing, gaming). Calin's diagnosis: 'This leads me to think it's somehow related to bugs in qt hmm... Might not even be memory related might be some qt bugs in the EC version of qt.' Qt handles GUI rendering - when screen locks, compositor/display server behavior changes, potentially triggering Qt bugs. KDE Plasma updates may affect this. Additional factors: 1) EC does leak memory over time (confirmed by Calin), 2) Without swap, OOM killer may terminate EC abruptly, 3) Qt version bundled with EC AppImage may have incompatibilities. Troubleshooting: Enable swap (even 1GB), run from source with system Qt instead of AppImage, check dmesg/journalctl for OOM killer messages. Josh's specific case likely Qt-related since memory usage unchanged during issue."
        },
        {
          "question": "Does Electron Cash have memory leaks and how much RAM does it use?",
          "answer": "Yes, EC has known memory leaks. Calin confirms: 'Yeah swap won't really fix it - EC leaks memory sadly.' Memory usage varies by wallet size: Small wallets: ~500MB-1GB, Large wallets (years of CashFusion history): 5-8GB normal, up to 8GB during spikes. Shadow's experience: '5GB (usual) - 8GB (extreme spikes) of RAM at all times' with large wallet. Leak causes: Python object references not released, transaction history accumulation, CashFusion state management. Symptoms: Gradual memory growth over runtime, eventual crash or OOM kill. Mitigation: 1) Restart EC periodically (workaround, not fix), 2) Enable swap to delay kill and allow graceful degradation, 3) Monitor memory usage with htop, 4) Consider migrating to fresh wallet if using CashFusion for years. Note: Memory leak is in EC codebase, not Qt or Python runtime, requires code-level investigation to fix properly."
        },
        {
          "question": "Why should Linux users enable swap even with plenty of RAM?",
          "answer": "Swap provides benefits beyond preventing out-of-memory situations. Calin explains: 'Because you give the kernel the opportunity to evict pages from ram that are dead memory that haven't been accessed in days - in favor of disk buffers.' Benefits: 1) Kernel can swap out inactive pages (processes allocated but not using memory), 2) More disk cache available for I/O operations, 3) Better overall system responsiveness, 4) Programs expecting swap may behave unexpectedly without it. Shadow reports: 'I had problems with random processes getting killed when I ran swapless. I still had 20GB of free RAM.' Some programs assume swap exists and crash otherwise. Calin: 'swap is beneficial even in non memory starved scenarios.' Recommended: At minimum 1GB swap on NVMe/SSD. ZSWAP compresses RAM before swapping, effectively increasing available memory 20-30%. Modern swapless trend problematic - convenience (faster system) but causes edge-case failures."
        },
        {
          "question": "How does virtual vs reserved memory differ and why does it matter for EC?",
          "answer": "Critical distinction for monitoring memory usage: Virtual memory is address space mapped (can be huge - Shadow saw 500GB virtual for single process), reserved/resident memory is actual physical RAM consumed. Calin: 'Virtual is just the address space it's almost meaningless number.' When monitoring EC: Look at RSS (Resident Set Size) or RES in htop, ignore VIRT column. EC with large wallet uses 5-8GB RSS (actual RAM). Tools: htop shows both columns - focus on RES. Why this matters: Process may have 100GB virtual (pre-allocated address space for potential future use) but only 1GB resident (actually using physical RAM). OOM killer cares about resident memory, not virtual. When tracking EC memory leak: Monitor RES growing over time, that indicates leak. If only VIRT grows but RES stable, that's normal memory mapping behavior, not leak."
        },
        {
          "question": "What are common Linux desktop environment issues affecting EC?",
          "answer": "KDE Plasma (Qt-based like EC) interactions discussed: 1) Memory usage - KDE uses ~750MB-1GB baseline (Jonathan reports 750MB), more than XFCE (minimal DE), but acceptable with modern RAM. 2) Qt version conflicts - EC bundles its Qt version in AppImage, system Qt (from KDE) may differ causing bugs. 3) Screen lock events - Josh's EC crashes only after screen lock, possibly compositor/session management triggering Qt bugs. 4) GPU/compositor interactions - Wayland vs X11 can affect Qt applications differently. Shadow notes: 'KDE was a RAM-eating monster last time I used it' but Josh counters: 'KDE 6 has been rock solid since I've started using it 2 years ago.' Jonathan: 'KDE is great... If you're on a memory starved machine, say 2gb or less, you might want consider other options.' Solution: If EC crashes only with certain DE behaviors (lock, suspend), try running from source with system Qt instead of AppImage's bundled Qt."
        },
        {
          "question": "How was the protobuf reproducibility issue in EC AppImage builds fixed?",
          "answer": "Jonas created PR #3120 with clever workaround for protobuf 5.x build path embedding. Problem: Google's new UPD (Universal Proto Deserializer) backend compiles C library at build time, __FILE__ macro embeds absolute paths into .rodata section. These paths are randomized (/tmp/pip-install-xxx) causing different hashes on each build. Solution: Replace build path strings with deterministic strings of exact same length. Jonas: 'ended up bluntly changing the strings in the binary... My guess is that it's used for printing. But the .rodata is very sensitive since the machine code jumps around in it and offsets needs to be exact.' Why not proper fix: -fmacro-prefix-map flag (used for cryptography package) doesn't work because pip randomly generates build path and we can't control it. EchterAgo: 'the problem is you don't know the path beforehand so you can't pass it in CFLAGS.' Python's mkdtemp doesn't support deterministic seeding. Current fix works but fragile - if protobuf changes string format, would need updating."
        },
        {
          "question": "What is ZSWAP and how does it improve Linux memory management for EC?",
          "answer": "ZSWAP is kernel feature that compresses RAM pages before writing to swap. Works as compressed cache between RAM and disk swap. Benefits: 1) Effectively increases usable RAM 20-30%, 2) Reduces disk I/O (compressed pages stay in RAM longer), 3) Faster than disk swap due to compression/decompression being faster than disk read/write, 4) Extends SSD lifespan by reducing swap writes. Jonathan: 'I haven't used a swapfile/partition in almost a decade now... that was resolved with zswap for me. I still don't have an on-disk swap.' Shadow uses: 4GB swapfile + ZSWAP enabled, only 52MB actual swap used with 80% ZSWAP utilization. Setup: Enable CONFIG_ZSWAP in kernel, set swappiness (Shadow uses 40). Compression algorithms: lz4 (fast), lz4hc (higher compression), zstd. Note: ZSWAP is different from ZRAM - ZSWAP backs to disk swap if needed, ZRAM is pure RAM compression. Both help EC users running 24/7 CashFusion with growing memory usage."
        },
        {
          "question": "What is the difference between tmpfs and ramfs for Linux filesystem use?",
          "answer": "Critical difference for performance-sensitive applications: tmpfs can swap to disk, ramfs cannot. Shadow clarifies: 'Yes, you should not use tmpfs as ramdisks, it swaps to swap.' Usage: tmpfs is mounted to /tmp by default on many distros - files there may end up on disk swap under memory pressure. ramfs ('mount -t ramfs') stays strictly in RAM but has no size limit (can OOM). Josh uses tmpfs for Portage compilation: 'I use a tmpfs for my portage compilation to keep that in Ram. I think I'd need to convert it to A RAM disk to avoid it being swapped out.' For crypto operations where you want guaranteed RAM (like during signing), ramfs ensures data never touches disk. For general use where overflow is acceptable, tmpfs is safer (size-limited). Swap encryption helps either way - if swapfile on encrypted partition, swapped data remains encrypted. Best practice for EC: Run on system with adequate RAM, use ZSWAP to optimize, don't worry about filesystem type unless extreme security requirements."
        },
        {
          "question": "Why does modern software poorly utilize available hardware resources?",
          "answer": "Calin's observation: 'imagine having 8GB RAM or 32GB RAM and programmers still finding a way to utilize those resources extremely poorly. No matter how good hardware gets, (some) programmers will figure out ways to poorly utilize those resources.' Root causes: 1) Python/JavaScript interpreted languages with garbage collection create memory overhead, 2) Library abstractions hide inefficiencies (protobuf, Qt framework), 3) Development speed prioritized over optimization, 4) Hardware becoming cheap makes optimization less valued, 5) Memory leaks from reference cycles or event handlers not cleaned up. EC specific issues: Transaction history accumulates without pruning, CashFusion state management grows, Qt widget memory not released. Shadow reports EC using 5-8GB with large wallet. Compare to Flowee Pay (C++) which Tom wrote with explicit resource management. Solutions: Periodic wallet restart, migrate to fresh wallet, developers prioritizing memory profiling. Industry trend: 'Electron' (not EC) apps bundling entire Chrome browser for simple apps exemplifies wastefulness."
        },
        {
          "question": "What logging does systemd provide for application crashes?",
          "answer": "Tom: 'systemd will log all application crashes. It will indeed mention that it was due to the out of memory killer if applicable.' Where to check: journalctl for systemd logs, dmesg for kernel messages (OOM killer). OOM killer logs include which process was terminated and why. Important: OOM killer only logs when it actually kills process - if application crashes for other reasons (segfault, Qt bug), different log entry. Josh notes: 'I'm staunchly anti systemd haha. I use OpenRC with sysklogd' - alternative init systems have different logging. For debugging EC crashes: 1) Check journalctl/syslog for crash messages, 2) Look for OOM killer messages in dmesg, 3) Monitor memory usage over time with htop, 4) Run EC with verbose mode from terminal to capture Python tracebacks. If crash has no OOM indication, likely Qt framework bug (common with screen lock on KDE) or Python exception not caught. Shadow's tip: Even without OOM kill, having no swap can cause crashes due to failed memory allocations."
        },
        {
          "question": "Does adding swap space fix EC crashes during screen lock?",
          "answer": "No - Josh's experiment proves RAM/swap isn't the issue. After extensive community discussion about swap benefits, Josh added swap file: 'Fine! I make a dammed swap file on a no-COW btrfs subvolume.' Result: 'Just checked, EC still crashed.' Calin confirms diagnosis: 'i really think it has nothing to do with RAM and more to do with some Qt shenanigans.' Josh realizes: 'I did notice I started having issues after a qt update from a while ago.' Root cause: Qt framework bug, likely related to screen lock events on KDE Plasma. EC bundles its own Qt version in AppImage which may have incompatibilities with system compositor. Possible solutions: 1) Run EC from source using system Qt, 2) Report specific Qt version and KDE version to help diagnose, 3) Wait for EC release with updated Qt, 4) Use different desktop environment as test. Swap is still recommended for general system stability, just doesn't fix this specific Qt-related crash."
        },
        {
          "question": "What causes EC AppImage crashes when screen locks and monitor turns off?",
          "answer": "Josh identified exact trigger: 'When my monitor goes blank after locking the screen. The locking itself doesn't crash, it's when the monitor shuts off.' Error log shows Wayland-related issues (wl_ prefixes in stack trace). Key findings: 1) Not RAM/swap issue (32GB RAM, tested with swap), 2) Not memory leak (works fine during active use), 3) Specific to monitor power-off event, not screen lock itself, 4) Wayland compositor behavior when display turns off triggers crash. Shadow: 'I see wl_ in there. Sooo..... Wayland?' Andy counters: 'I run electron cash on Wayland and have had zero problems' (using AUR package, not AppImage). Possible causes: AppImage's bundled Qt version incompatible with specific Wayland compositor version, Clang/LLVM profile on Gentoo introduces incompatibility, monitor DPMS events not handled correctly by bundled Qt. Jonas suggests: 'could this possibly be an issue that could be chalked up on the fixed if we move to Qt6 list?'"
        },
        {
          "question": "Does AppImage bundle its own libc or use system libc?",
          "answer": "AppImages use SYSTEM libc, not bundled version. Jonas confirms after Shadow states: 'It is basically like a docker container. Contains all necessary libraries inside it, except some most basic ones like libc.' Reason: libc is fundamental system interface to Linux kernel - bundling would break binary compatibility. AppImage bundles: Qt, Python, application-specific libraries. AppImage uses: System libc (glibc), kernel interfaces. Josh's investigation: 'So after ldding a few executables, it looks like most things are loading libc.so.6.' His Gentoo system uses Clang profile with libc++ (LLVM's C++ stdlib) instead of GNU libstdc++, but still uses system glibc for C standard library. Tom's debugging tip: 'In the proc filesystem, the pid of EC you can double check which path to the Qt lib it actually uses. For instance /proc/100/maps' - shows all loaded libraries for running process. This helps verify AppImage isn't picking up system Qt by mistake."
        },
        {
          "question": "Does EC work better on Xorg or Wayland?",
          "answer": "Mixed results - some users report no issues on either, one specific case shows Wayland-related crash. Evidence: Josh's AppImage crashes when monitor blanks (Wayland stack trace in error). Andy: 'I run electron cash on Wayland and have had zero problems' (AUR package). Jonas: 'I'm using the AppImage on Wayland (or whatever is the default on Ubuntu 24.04) and haven't had this issue.' Shadow strongly prefers Xorg: 'Wayland is totally experimental and unstable, despite any claims otherwise.' Tom defends: 'one person hates wayland and is very quick to blame it.' Reality: Wayland isn't universally broken, but specific combinations (AppImage + Gentoo + Clang + KDE Plasma) may trigger issues. WT notes: 'Wayland supposedly is a guarded, walled environment for processes, so we also have to ask if Electron Cash is doing something uncanny.' Workaround if having issues: Use AUR package (Arch) which uses system Qt, or try running EC with --xorg flag if compositor supports, or use XWayland compatibility layer."
        },
        {
          "question": "How do I check which libraries a running EC process is using on Linux?",
          "answer": "Tom's debugging technique: 'you can open the text file /proc/PID/maps to get your full list of libraries for any running process.' Steps: 1) Find EC process ID: use 'ps aux | grep electron' or htop/top, 2) Read /proc/PID/maps: 'cat /proc/12345/maps' (replace 12345 with actual PID), 3) Look for library paths - shows Qt location, Python libraries, system vs bundled. For AppImage: Should show libraries from /tmp/appimage-extracted-xxx/ paths, not system paths. If you see /usr/lib/qt5 instead, AppImage is incorrectly using system Qt. Josh's investigation: 'I can't ldd the AppImage though since it's, well, an AppImage' - but /proc/PID/maps works on running process. Additional tool: ldd shows library dependencies at load time, but /proc/PID/maps shows what's actually loaded at runtime (can differ). Look for: libQt5*.so paths (should be AppImage directory), libc.so.6 (should be system), libpython*.so."
        },
        {
          "question": "Could using Clang/LLVM instead of GCC cause EC compatibility issues?",
          "answer": "Possibly, though unlikely root cause. Josh uses Gentoo with Clang profile: 'I use a Gentoo system with the Clang profile... uses the libcxx library rather than the GNU libc.' Shadow theorizes: 'Because perhaps CLANG/LLVM is not as well battle-tested as GCC, which is the mainstream compiler used absolutely everywhere.' Investigation results: Josh's system uses standard glibc for C library, libc++ only for C++ standard library. Both coexist on his system. Most applications including Steam work fine. Problem is more likely: 1) AppImage's bundled Qt (compiled with GCC) interacting oddly with system compiled with Clang, 2) Wayland compositor behavior (not compiler), 3) Specific KDE Plasma version + Qt5 version combination. Tom notes: Valve (Steam) uses Arch Linux (GCC-based) as foundation for SteamOS. EC AppImage built on Ubuntu 20.04 with GCC - should be compatible with any glibc-based system regardless of host compiler."
        },
        {
          "question": "What is the verbose flag for debugging EC AppImage crashes?",
          "answer": "Run AppImage with -v flag to capture detailed output. Josh: 'I feel dumb. Why didn't I think of this sooner? I'm running the AppImage with the -v (verbose) flag.' How to use: './Electron-Cash-4.4.2-x86_64.AppImage -v 2>&1 | tee ec_debug.log' captures all output. The verbose flag causes EC to print: 1) Library loading information, 2) Qt/GUI initialization details, 3) Network connection attempts, 4) Wallet loading progress, 5) Error messages with stack traces. When Josh ran with -v, crash output showed Wayland-specific function calls (wl_ prefixes), directly identifying display compositor as crash location. Alternative debugging: 1) Run EC from terminal (not desktop launcher) to see stdout/stderr, 2) Check ~/.local/share/Electron Cash/... for EC's own logs, 3) journalctl for systemd logs (if using systemd), 4) dmesg for kernel-level issues (OOM, segfaults). Always capture verbose output when reporting bugs to GitHub - essential for developers to diagnose issues."
        },
        {
          "question": "How do you limit EC to single CPU core on Linux for performance testing?",
          "answer": "Use taskset command to set CPU affinity. ErdoganTalk asks: 'is it possible to limit ElectronCash to 1 processor/thread only?' Jonny's solution: 'You can spawn the program via the taskset command that limits the process to the cpu/thread you want.' Two approaches: 1) Launch with restriction: 'taskset -c 0 electron-cash' binds to CPU 0, 2) Modify running process: 'taskset -p -c 2 PID' where PID is python3.11 process. ErdoganTalk's experience: 'I had to start ElectronCash, then change processor affinity to 2 (or any number 0-7) on the process number for python3.11.' Use cases: 1) Testing single-threaded performance, 2) Preventing EC from monopolizing resources, 3) Debugging concurrency issues, 4) Energy efficiency on laptops. Note: EC is Python application, already limited by GIL (Global Interpreter Lock), but still uses multiple threads for I/O operations. Setting affinity primarily useful for controlling resource usage rather than improving performance."
        },
        {
          "question": "Does Python's GIL prevent EC from using multiple CPU cores effectively?",
          "answer": "Yes, Python's Global Interpreter Lock limits concurrency. Calin explains: 'it only uses 1 thread anyway because python' and 'Python is single-core always.. it doesn't really parallelize.' When user asks about limiting EC to single CPU core, Calin notes: 'you don't even need to do this.' Technical details: GIL ensures only one Python thread executes bytecode at a time, even on multi-core systems. This prevents true parallelism for CPU-bound tasks. However, EC uses multiple threads for I/O operations (network requests to Fulcrum servers, GUI rendering via Qt), which can release GIL during blocking operations. Why matters: Memory usage is better metric than CPU core usage for EC. Memory leaks affect performance more than core availability. Workarounds exist: multiprocessing module (not used in EC), native extensions can release GIL (libsecp256k1 does this). For CashFusion, bottleneck is network I/O and cryptographic operations (mostly in C extensions), not Python bytecode execution. GIL mostly impacts batch operations like scanning entire blockchain."
        },
        {
          "question": "Why does EC fail to export P2SH input addresses in transaction data?",
          "answer": "Parsing limitation: EC's scriptSig parser doesn't handle general P2SH contracts. emergent_reasons discovers: 'if I add some debug to the export code, it sees this for p2sh inputs... address: None.' Investigation reveals: 'It even looks like the scriptsig parser just doesn't even try to parse p2sh20 or p2sh32... cannot find address in input script.' Root cause: EC's parse_scriptSig() designed for specific input types (P2PKH, multisig P2SH) but not arbitrary P2SH contracts. Bitcoin/BCH inputs contain scriptSig (unlocking script) that doesn't explicitly include address - address must be derived from script hash. For multisig: EC recognizes pattern and computes P2SH address. For general P2SH: Parser gives up, returns type='unknown', address=None. Impact: Transaction export (JSON format) missing input addresses for smart contracts like CashScript covenant transactions. Dustin: 'I noticed that a long time ago, but it isn't an issue for my use case' (uses multisig P2SH which works). emergent_reasons offers bounty for fix: 'willing to pay for a local fix.' This is technical debt from EC's P2PKH-centric design."
        },
        {
          "question": "Why does EC's scriptSig parser fail for non-multisig P2SH inputs?",
          "answer": "Uses heuristic pattern matching that doesn't cover general P2SH. Calin explains: 'it's a heuristic matcher.. and there is no general solution.' The algorithm: 1) Do I see 1 push?  p2pk, 2) Do I see 2 pushes?  p2pkh, 3) Do I see OP_0 then more pushes?  p2sh multisig, 4) Otherwise  unknown. Problem: Non-multisig P2SH contracts (like CashScript covenants) often have different push patterns. Calin: 'As an increasing number of p2sh are NON multisig... the heuristic scanner is now being exposed for the fraud that it is!' Why unsolvable locally: 'there is no way to improve it... because the problem is unsolvable with scriptSig alone as the only thing one has to examine.' Bitcoin transactions only include unlocking script (scriptSig), not locking script (previous output). Without knowing original locking script, can't definitively determine input type. Tom reinforces: 'The issue is that if you're looking at one transaction, you have the redeem. But you would need to fetch the old transactions to get the rest of the script.' Solution: Fetch previous transaction outputs from network."
        },
        {
          "question": "How did Calin's PR #3145 fix the P2SH export address issue?",
          "answer": "By fetching previous transaction outputs instead of relying on heuristics. Calin explains: 'yes it fixes the problem by getting the actual spent coins because there is no way to solve this problem from the scriptSig alone.. you ultimately need the previous output (spent coin) for the txn.' Implementation: 'this PR just does that -- leverages the fetch inputs subsystem from transaction.py to go out to the network and determine spent coins for a txn.' PR link: github.com/Electron-Cash/Electron-Cash/pull/3145. Testing: emergent_reasons confirms: 'Tried it and it worked!' Benefit: Export history now includes correct input_addresses for all transaction types, not just P2PKH and multisig. Trade-off: Requires network access during export (fetches previous txs), may be slower for large histories, adds external dependency. Context: This fixes export functionality specifically, not the general-purpose transaction parser. Calin: 'there is no solution, sadly, if the only information one has to fix it is the scriptSig.. you need to go back to the previous output scriptPubKey to know for sure.' Export can use network since it's not a real-time operation."
        },
        {
          "question": "Why do some P2SH inputs get incorrectly identified as P2PKH?",
          "answer": "Heuristic parser looks for 2 pushes pattern. Calin details: 'the heuristic scanner will falsely think p2pkh if it sees 2 pushes and the first push is not 0. A legit p2sh (non-multisig) can match that pattern then the heuristic scanner just thinks p2pkh (wrongly).' P2PKH pattern: <signature> <pubkey> - exactly 2 pushes. P2SH with 2 pushes: <data> <redeemScript> - also 2 pushes! If P2SH contract's redeem script only needs one piece of data, scriptSig has 2 pushes total and gets misidentified. Conversely, correct P2SH detection: 'if it sees OP_0 as the first push, it thinks p2sh and then correctly matches.' OP_0 is required for standard multisig (BIP 11) due to OP_CHECKMULTISIG bug. emergent_reasons explains: 'The decoder is using a heuristic to identify each input as a p2pk, p2pkh, multisig-p2sh, or give up. The heuristic for p2pkh can catch p2sh in at least one specific case (2 pushes).' Dustin confirms: 'looking at the JSON where the addresses show up, it indicates the type is p2pkh (it's not, it's P2SH)' - false positive working by accident."
        },
        {
          "question": "Why can't EC CLI deserialize require network access to fix P2SH parsing?",
          "answer": "Offline operation is core design requirement. Dustin: 'we don't want cli deserialize to require network, but might be able to add an option to use/require network when we know it's P2SH and want to try to fetch.' Use cases for offline deserialize: Air-gapped transaction building, offline signing workflows, security-sensitive environments, debugging without connectivity. Dustin's workflow: 'literally going into EC GUI, hitting send, pasting a P2PKH address, hitting max, hitting preview, hitting copy, going to CLI and running electron-cash deserialize' - for automated transaction processing. CLI output format: 'return self._EnsureDictNamedTuplesAreJSONSafe(tx.deserialize().copy())' - returns transaction dictionary. Trade-off: Offline operation means limited information. emergent_reasons: 'I need the export to just work' - his use case (tax reporting) can tolerate network access. Dustin suggests: 'might be able to add an option' - optional network flag would preserve backwards compatibility. Current state: Export (GUI feature) can use network (Calin's PR #3145), CLI deserialize stays offline. Different tools for different trust models."
        },
        {
          "question": "How did Electrum handle the scriptSig parsing problem?",
          "answer": "Electrum gave up and removed heuristic parser entirely. Calin notes: 'Interestingly, Electrum gave up, removed the heuristic parse_scriptSig function.. and just shows you some garbage there for inputs.' Their alternative: 'and i think they have some mechanism for remembering and/or retrieving previous outputs somehow to fully resolve txns but i forget how they did it i remember thinking it was not as nice UI-wise as what we do.' EC's approach: Kept heuristic matching despite limitations, added fetch_inputs capability for when accuracy matters. Trade-off: EC shows 'best guess' addresses (sometimes wrong), Electrum shows raw data (always honest but unhelpful). Calin acknowledges EC's parser inadequacy: 'so we are left with parse_scriptSig() which works 95% of the time and fails spectacularly when it doesn't.' Important context: As P2S activates in May 2026 and more custom contracts emerge, heuristic accuracy will decline further. Eventually EC may need to follow Electrum's approach or implement mandatory input fetching."
        },
        {
          "question": "Should CLI deserialize command fetch network data to resolve addresses?",
          "answer": "Philosophical debate on function purity vs utility. Dustin proposes: 'Still wonder why it couldn't be modified to retrieve whenever it fails if network is available, maybe even without an option.' Calin supports but clarifies: 'i am in favor of retrieving... it may slow down the RPC call a bit in some cases but I think is worth it.' However, questions scope: 'that seems like a low-level facility just to actually DESERIALIZE a transaction.' Pure deserialize: Transform bytes to data structure. Extended deserialize: Transform bytes + resolve all external references. Calin's naming concern: 'what you are alluding to is some higher level thing like DeserializePlusResolveAllExternalInfoForTxnPlsINeedKThxBye.' Potential solutions: Add optional flag (fullyResolveEverything=True), create separate command, silently fetch when network available. Dustin's use case: 'I do [use offline deserialize], that's why I assumed it's what emergent was doing.' Calin: 'do people use it in offline mode as a quick way to get fun stuff out of EC like free txn deserilization?' Question remains open for community input on best approach."
        },
        {
          "question": "What is the philosophy of good heuristic matching in parsers?",
          "answer": "Minimize false positives while maximizing coverage. Calin explains: 'the idea is to pick a set of heuristics that end up being lies like as infrequently as possible.' Current EC heuristics: Work ~95% of time (P2PKH dominant, multisig P2SH common). As usage patterns change (more CashScript contracts, more complex P2SH), accuracy decreases. Dustin's proposed change evaluation: 'i think your changes increase the lie percentage, rather than reduce it.' Why worse: Hashing arbitrary push as P2SH20 would misidentify P2PKH (signature becomes 'address'), P2SH32 (wrong hash), any non-P2SH. Calin's principle: 'probably deserialize may need to be fixed tho to not at least lie to you about p2sh... like right now deserialize may lie to you... may match p2sh when it's really not.' Honesty options: Return 'unknown' (honest uncertainty), fetch previous output (accurate), or heuristic guess (risk). Current EC approach: Guess but acknowledge in code comments it's fragile. Future direction: May need to follow Electrum and abandon heuristics entirely."
        }
      ]
    },
    {
      "name": "Development & Architecture",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Why is Electron Cash still using Qt5 instead of Qt6?",
          "answer": "Migrating to Qt6 requires switching from PyQt to PySide2, which is not a huge code change but requires extensive testing of every GUI component. Python's dynamic typing means there's no compile-time safety check, so all UI elements need manual testing. Ubuntu is planning to eventually stop packaging Qt5, so this migration is on the roadmap but not yet prioritized due to the testing overhead."
        },
        {
          "question": "Is Electron Cash a fork of another wallet?",
          "answer": "Yes, Electron Cash is a fork of Electrum (the Bitcoin wallet). It was created for Bitcoin Cash. EC is one of many Electrum forks - others exist for Litecoin, Dogecoin, Dash, Zcash, BSV, eCash, Ergon, and more. Because EC inherits Electrum's codebase, it uses the same general architecture including PyQt for the GUI and the client-server model with dedicated indexers. The first EC release occurred just one day before the BCH fork in August 2017."
        },
        {
          "question": "Where can I find documentation about SPV protocol for Bitcoin Cash?",
          "answer": "Key resources: 1) Original Bitcoin whitepaper section on SPV, 2) https://documentation.cash/protocol/spv.html - BCH-specific SPV documentation, 3) BIP-37 specification for bloom filter SPV. The documentation.cash site covers the merkle proof verification concept and its implementation in BCH. Remember that 'SPV' as defined in the whitepaper is the verification concept, while BIP-37 was the first network-level implementation using bloom filters."
        },
        {
          "question": "How do I build an Electron Cash AppImage from source?",
          "answer": "Run the build script: `contrib/build-linux/appimage/build.sh 4.4.2` (replace version number as needed). This creates an AppImage with all bundled dependencies. AppImages are useful when running from source has environment issues (libsecp256k1 conflicts, Qt/PyQt version mismatches, protobuf conflicts). The AppImage bundles its own Python environment, Qt libraries, and cryptographic libraries to avoid host system conflicts."
        },
        {
          "question": "How can I help maintain Electron Cash packages for Linux distributions like Fedora?",
          "answer": "You can become a co-maintainer for official Fedora packages. Responsibilities include: 1) Following Fedora package guidelines, 2) Bumping version numbers when maintainer is away, 3) Reviewing new BCH-related packages before submission, 4) Creating RPMs for dependencies like libsecp256k1-bitcoin-cash. Contact existing package maintainers (like Jonny in the EC Telegram) to start. Benefits: faster introduction of BCH-specific packages, easier installation via `dnf install electron-cash`, and community ownership of packaging. Fedora maintainer policy documentation: https://docs.fedoraproject.org/en-US/fesco/Packager_sponsor_policy/"
        },
        {
          "question": "How does BCH's libsecp256k1 differ from Bitcoin's version?",
          "answer": "BCH uses a different Schnorr signature implementation than BTC's libsecp256k1. The BCH version (from BCHN) is effectively frozen and incompatible with newer BTC versions. This causes conflicts on distros like Fedora that package BTC's version. Solutions: 1) Package libsecp256k1-bitcoin-cash separately (like GNU Guix does), 2) Use static linking to bundle BCH version within the app, 3) Use AppImage which includes compatible libraries. The naming convention '-bitcoin-cash' is recommended to avoid conflicts while allowing both to be installed."
        },
        {
          "question": "Where can I find Electron Cash's Fedora RPM packaging specification?",
          "answer": "The Fedora RPM spec file is at: https://src.fedoraproject.org/rpms/electron-cash/blob/rawhide/f/electron-cash.spec. This defines how EC is packaged for Fedora Linux, including dependencies, build steps, and protobuf file compilation. The spec downloads .proto files separately since they're not in the sdist tarball. Useful for understanding how official Linux packages handle EC dependencies like libsecp256k1, protobuf, and PyQt."
        },
        {
          "question": "What's the best practice for contributing icons or UI changes to Electron Cash?",
          "answer": "Always consult maintainers BEFORE investing significant time. Key points: 1) EC maintainers (especially Calin) prefer detailed, non-flat icon styles over modern minimalist designs, 2) EC intentionally maintains a 'retro' aesthetic, 3) Bug fixes and consistency improvements are welcome, 4) Reductionist/flat modern icons are likely to be rejected. When submitting PRs: include screenshots, expect feedback, and be prepared to modify or revert specific changes. The maintainers appreciate contributions but have strong aesthetic preferences that differ from modern design trends."
        },
        {
          "question": "What is Qt and why does it matter for Electron Cash?",
          "answer": "Qt is the GUI framework EC uses (via PyQt5). Qt determines: how windows render, menu appearance, font scaling, and platform compatibility. EC uses Qt5 (not Qt6 yet) which affects: 1) High-DPI support (needs manual QT_SCALE_FACTOR), 2) Wayland compatibility (varying success), 3) Native appearance on different OSes, 4) Available build options. Migration to Qt6 would require switching to PySide2 and extensive testing. The AppImage bundles specific Qt version, while running from source uses system Qt. Qt version mismatches cause many UI-related issues."
        },
        {
          "question": "What advantages would moving to Qt6 bring for Electron Cash?",
          "answer": "Key advantages: 1) Qt6 has prebuilt ARM wheels (Qt5 doesn't) making ARM AppImages feasible, 2) Better native high-DPI support without QT_SCALE_FACTOR hacks, 3) Improved Wayland compatibility, 4) Modern features and better performance, 5) Ubuntu planning to stop packaging Qt5 eventually. Challenges: Requires switching from PyQt5 to PySide2, extensive testing of all GUI components due to Python's dynamic typing, and maintainer time. GitHub issue #3053 tracks this migration discussion."
        },
        {
          "question": "Does Qt5 support high DPI screens?",
          "answer": "Yes, Qt5 has decent HDPI support, but it requires explicit enabling in code. It's not automatic like Qt6. For EC users: set QT_SCALE_FACTOR environment variable manually. The issue is that Qt5 doesn't automatically detect and adjust for high-DPI screens, especially when combined with Wayland. Only in the last couple of years have frameworks started automatically handling this through cooperation with the graphics stack. EC's Qt5 dependency is one reason why high-DPI support requires manual configuration."
        },
        {
          "question": "How divergent are Electron Cash and Electrum codebases now?",
          "answer": "Very divergent - they split about 7 years ago (circa 2017-2018 when BCH forked from BTC). Electrum underwent massive refactoring since then, making it nearly impossible to port features or fixes between them. A developer attempted to port a performance fix and found the code so different they couldn't even determine if the fix was applicable. This means: 1) EC can't easily adopt Electrum's newer features, 2) Each codebase has evolved with different priorities (EC added CashTokens, CashFusion; Electrum added Lightning), 3) Security patches must be evaluated independently, 4) Android versions have different feature sets despite similar origins. Seven years is 'an eternity in software land'."
        },
        {
          "question": "How would a change to BCH block time target affect Electron Cash?",
          "answer": "EC would need code modifications to SPV proof checking, but it wouldn't be a huge project. Key impacts: 1) Header verification timing assumptions would need updating, 2) Difficulty adjustment algorithm references need modification, 3) With faster blocks, can still prune headers - store only 1k recent headers plus verified merkle root. Good news: EC already uses header merkle roots/proofs, so even with 1-minute blocks (vs current 10-minute), storage remains minimal. The full node software changes are more involved than wallet changes. EC has proven adaptable - it survived the BCH fork from BTC and subsequent consensus changes."
        },
        {
          "question": "Why is there a python-dateutil version requirement (<2.9) in EC and how does it cause packaging issues?",
          "answer": "EC's requirements.txt specifies python-dateutil less than 2.9, causing conflicts with newer Linux distributions (like Fedora rawhide shipping 2.9.0). The library is only used in electroncash/paymentrequest.py for date parsing. History: A higher version likely broke something in the past, prompting the version cap. Issue: Distribution packagers can't include EC when system dateutil exceeds 2.9. Solutions being explored: 1) Test with newer dateutil to see if original issue is resolved, 2) Remove dateutil dependency entirely (Electrum BTC doesn't use it), 3) Update code to work with newer versions. This exemplifies challenges of maintaining cross-distribution compatibility with pinned dependencies."
        }
      ]
    },
    {
      "name": "Hardware Wallets",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Why do I get 'IndexError: list index out of range' when signing transactions with Satochip hardware wallet?",
          "answer": "This is a known bug in the Satochip plugin's CashToken handling code. The tx.token_datas() method returns output token data, but the code incorrectly uses it to check inputs. When there are more inputs than outputs, it causes an IndexError. Workaround: Send coins one at a time (single input per transaction) instead of combining multiple coins. This bug affects old Satochip wallets created before CashTokens."
        },
        {
          "question": "Why does Electron Cash not detect my KeepKey hardware wallet on Windows 11?",
          "answer": "This is a known issue: KeepKey works with Electrum (BTC) and the official KeepKey app on Windows 11, but EC reports 'no device detected'. It works fine on Linux with the same hardware. Troubleshooting: 1) Update firmware, 2) Verify USB drivers are installed, 3) Try different USB ports, 4) Run EC as administrator. The issue appears to be Windows-specific driver/permission handling in EC. Workaround: Use EC on Linux (even via Live USB) or report the issue on GitHub with Windows version and EC version details."
        },
        {
          "question": "My KeepKey hardware wallet is not detected by Electron Cash - is there a fix?",
          "answer": "Yes, KeepKey detection has been fixed in EC's git master branch (as of April 2025) but isn't yet in an official release. Workarounds: 1) Use a pre-release build from https://ec.loping.net/ signed by ichundes (EC developer), 2) Wait for EC 4.4.3 or later official release, 3) Run EC from source using master branch. The issue affected Windows 11 particularly. Check GitHub issue #2995 for details. Always verify GPG signatures of any pre-release builds before using."
        },
        {
          "question": "Does Electron Cash mobile support hardware wallet connections?",
          "answer": "Currently, no. Hardware wallet support exists only in EC desktop (KeepKey, Trezor, Ledger, Satochip). Mobile hardware wallet integration faces challenges: 1) iOS restricts USB connections and would require air-gap or Bluetooth, 2) Android could potentially use USB OTG but implementation is complex, 3) Development resources are limited, 4) Each hardware wallet has different connection protocols. Users requesting this feature should: submit feature request on GitHub, understand it's a significant development effort, and for now use EC desktop for hardware wallet management. Some users manage hardware wallets on desktop and use mobile only for spending from hot wallets."
        },
        {
          "question": "Does Ledger work with Electron Cash after firmware updates?",
          "answer": "Frequently breaks. Ledger updates firmware regularly and often breaks compatibility with third-party wallet software like EC. Recent reports: Latest Ledger Nano X firmware incompatible with EC. Root cause: Ledger changes APIs/protocols without coordinating with external wallet developers. Community response: Stop using Ledger. EC developers don't own Ledgers and don't test compatibility - they support what's reported working. Alternatives: Trezor (more open source), OneKey, or abandon hardware wallets entirely for GrapheneOS phone or offline laptop. Ledger's closed-source firmware and frequent breaking changes make it unreliable for non-Ledger-Live software."
        },
        {
          "question": "Why doesn't CashFusion work with hardware wallets?",
          "answer": "Hardware wallets can't participate in CashFusion rounds. Technical reason: CashFusion requires signing many inputs/outputs rapidly during round coordination. Hardware wallets: 1) Require manual confirmation for each signature, 2) Have timeouts that would expire during fusion process, 3) Can't handle the complex multi-party signing protocol. Solution: Import seed phrase from hardware wallet into EC software wallet for fusion. However, this defeats hardware wallet security model (keys leave secure element). Workaround: After fusing with seed phrase in EC, move fused coins back to hardware wallet addresses. Not ideal but only current option. Better approach: Keep funds in software wallet (de-googled phone, offline laptop) and skip hardware wallet complexity entirely."
        },
        {
          "question": "Can I see my hardware wallet seed phrase after initial setup?",
          "answer": "Typically no - seed phrases are displayed only during initial device setup. Security model: Hardware wallets are designed so private keys never leave the device. If you could extract seed phrase anytime, defeats security purpose. Backup verification: Some devices (Ledger) have 'Check Recovery Phrase' feature through Ledger Live that verifies your backup matches what's on device without exposing it. Important: Ledger's controversial 'Recover' firmware update showed they technically CAN extract seeds, which undermined trust. Best practice: Write down seed phrase carefully during setup, store securely. If you forgot to backup or lost backup, move funds to new wallet with fresh backup rather than trying to extract seed."
        },
        {
          "question": "Why can't I view my hardware wallet seed phrase in Electron Cash?",
          "answer": "EC doesn't show seed phrases for hardware wallet-connected wallets because the seed never leaves the hardware device. Key security principle: Hardware wallets are designed so private keys (including seed) stay in secure element chip forever. EC only knows your xpub (public key) for watching addresses. To verify your backup: Use manufacturer's software (Ledger Live, Trezor Suite) with 'Check Recovery Phrase' feature - you enter your backup phrase and it confirms if correct without displaying the actual seed. This verification is different from viewing - device checks hash internally. If you need to see seed phrase, you should have written it down during initial device setup - that's the only time it's displayed."
        },
        {
          "question": "Should Ledger work with EC on macOS and what causes detection failures?",
          "answer": "Should work but has known issues. User T reports: 'my ledger is never detected while ledger live works well... I tried with nano s and nano x.' Common causes: 1) Ledger Live app holding exclusive device access - close it completely before using EC, 2) macOS USB permissions - EC may not have device access, 3) Browser extension conflicts, 4) Outdated EC version incompatible with newer Ledger firmware. Troubleshooting steps: Close Ledger Live completely (check Activity Monitor), try different USB port, ensure EC has USB access in macOS System Preferences, update EC to latest version. Note: Ledger Live uses WebUSB which can conflict with EC's direct USB library (hidapi). On macOS specifically, USB device access permissions more restrictive than Linux. If still failing: Check EC verbose output for USB enumeration errors, try running EC from terminal to see connection attempts. Hardware wallet support is plugin-based in EC, ensure plugin is enabled in Tools > Plugins menu."
        },
        {
          "question": "What is SeedCash and how does it support BCH hardware wallet functionality?",
          "answer": "BCH-focused hardware wallet with SLIP-39 support. Mart introduces: 'Its architecture is used for HW control but in terms of the application, it is practically all new.' Fork of SeedSigner project, customized for BCH. Features: BIP-39 seeds (12-24 words), SLIP-39 shares (20 or 33 words), xpub/xpriv export, BCH address generation (CashAddr and Legacy formats), transaction signing (in development). Integration with EC: Generate SLIP-39 seed on device, export xpub via QR code, create watch-only wallet in EC. Private keys never leave device. Air-gapped: No network connectivity, communication via QR codes only. Use case: Cold storage with social recovery. Split seed into shares, distribute to trusted parties, any M-of-N can recover. Website: seedcash.cash with educational resources. Open source (based on SeedSigner). Fills gap that EC lacks native SLIP-39 support - external device handles seed management while EC provides wallet interface."
        }
      ]
    },
    {
      "name": "Installation & Setup",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Why does Electron Cash show 'no module found pathvalidate' error after updating on Arch Linux?",
          "answer": "This happens after a Python version update (e.g., to Python 3.13). The python-pathvalidate package from AUR needs to be reinstalled to compile against the new Python version. Run your AUR helper to rebuild all Python packages that depend on the updated Python version. This is a common issue with Python version bumps on Arch-based systems."
        },
        {
          "question": "How do I install Electron Cash on Ubuntu?",
          "answer": "You can: 1) Download the AppImage from electroncash.org and run it directly, 2) Run from source by cloning the GitHub repository, or 3) Use a PPA if available. Most developers run it from source for testing. PPAs provide OS-integrated package management but require someone to maintain the packaging."
        },
        {
          "question": "Can I run Electron Cash on Raspberry Pi or other ARM-based systems?",
          "answer": "There is no ARM AppImage for Electron Cash. You must run it from source, ideally in a Python virtual environment (VENV). Building an AppImage for ARM is impractical because many binary dependencies required for the build are not available for ARM architecture. Each unsuccessful build attempt takes about 3 hours. The setup process depends on your specific OS version and pip/apt installations. This approach has worked on various versions of EC on Ubuntu and Pi OS on Pi4 and Pi5."
        },
        {
          "question": "Why doesn't Electron Cash work on Fedora when running from source?",
          "answer": "Fedora switched to BTC's libsecp256k1 which has incompatible Schnorr signatures (BCH uses different Schnorr). This causes conflicts when running EC from source. Solution options: 1) Use the AppImage which bundles compatible libraries, 2) Build BCH's libsecp256k1 from BCHN source and copy the .so file, 3) Wait for someone to package libsecp256k1-bch separately for Fedora repos. CashFusion specifically requires working secp256k1, so fallback to Python code isn't sufficient."
        },
        {
          "question": "What are the advantages of running Electron Cash from source vs AppImage?",
          "answer": "Running from source offers: 1) Easy testing of master branch or feature branches via git pull, 2) Ability to tweak config files directly, 3) Native Qt appearance (AppImage can look slightly different), 4) Package manager integration (dnf/apt updates). Disadvantages: Environment conflicts (libsecp256k1, protobuf versions, PyQt compatibility), SSL certificate issues with self-signed certs. AppImage benefits: Isolated environment, no dependency conflicts, works out of box. Trade-off based on your use case."
        },
        {
          "question": "What is the current status of protobuf in EC's requirements.txt?",
          "answer": "Protobuf is listed in requirements.txt (recently moved from requirements-hw.txt). To install properly: `pip install -U -r contrib/requirements/requirements.txt`. The bundled AppImage uses protobuf==5.27.3 with matching *_pb2.py files. If running from source with older Python protobuf library, you'll get import errors. Either upgrade protobuf or regenerate the pb2 files with your local protoc version. Version mismatch is the #1 cause of 'could not find paymentrequest_pb2.py' errors."
        },
        {
          "question": "Why is there no ARM AppImage for Electron Cash?",
          "answer": "Several technical challenges: 1) No prebuilt PyQt5 wheel for ARM (Qt6 has one, but EC requires Qt5), 2) Build process is extremely slow on ARM devices (~3+ hours per attempt on Pi4), 3) Many binary dependencies lack ARM versions, 4) Complex deterministic build requirements for security verification, 5) Technical debt from early Electrum development. Cross-compiling from x86 Docker container is theoretically possible but not implemented. Current solution: Run from source in Python virtual environment on ARM devices, accepting the setup complexity."
        },
        {
          "question": "How do I install Electron Cash on Fedora Linux?",
          "answer": "Simple one-line install: `sudo dnf install electron-cash`. Fedora maintains an official EC package in their repositories. This is the easiest installation method on Fedora, handling all dependencies automatically including libsecp256k1, protobuf compilation, and PyQt5. Updates come through regular Fedora updates. Alternative: Use the AppImage for any Linux distro, or run from source in a Python virtual environment for development/testing."
        },
        {
          "question": "Should I use Python virtual environments for running Electron Cash from source?",
          "answer": "Yes, using venv is strongly recommended, especially on rolling-release distributions like Arch Linux. Benefits: 1) Isolates EC dependencies from system Python packages, 2) Survives system upgrades that would break dependencies, 3) Easier to match specific library versions EC needs (protobuf, PyQt5, etc.), 4) Simple to recreate if broken. Setup: `python -m venv --system-site-packages ec_venv && source ec_venv/bin/activate && pip install -r requirements.txt`. Only minor hassle: may need to recreate venv on major Python version upgrades."
        },
        {
          "question": "How do I install Electron Cash on Whonix?",
          "answer": "Download and run the AppImage directly. Get it from https://electroncash.org/downloads/4.4.2/win-linux/Electron-Cash-4.4.2-x86_64.AppImage. Make it executable (chmod +x) and run. Since Whonix routes all traffic through Tor, EC will automatically use Tor for network connections. Whonix is Debian-based, so the Linux AppImage works perfectly. The AppImage bundles all dependencies, avoiding package compatibility issues."
        },
        {
          "question": "What causes 'No module named pysatochip' error when installing EC from AUR?",
          "answer": "The AUR package might not have pysatochip as a dependency if you're trying to use a Satochip hardware wallet. Solutions: 1) Install pysatochip separately: `pip install pysatochip` or from AUR if available, 2) Use the AppImage which bundles all dependencies, 3) If not using Satochip hardware wallet, this shouldn't prevent EC from running - check if the error is fatal or just a warning. The AppImage avoids these dependency issues by including everything internally."
        },
        {
          "question": "Why is the Electron Cash iOS app experiencing bugs on newer iPhones?",
          "answer": "The iOS app hasn't been updated in approximately 3 years. Issues reported: FaceID setting doesn't persist (resets on app restart) on iPhone 15 Pro with iOS 17.7.2. Root causes: 1) iOS API changes over three years not reflected in app, 2) Apple's walled garden makes updates difficult (requires Mac hardware, paid developer account), 3) Limited iOS development resources in EC community. Workarounds: try PIN-only authentication, update to latest iOS version (may fix compatibility), or use alternative wallets. One developer attempted to build from Hackintosh VM but Apple's server detected non-authentic hardware. The iOS ecosystem's closed nature is a significant barrier to open source wallet development."
        },
        {
          "question": "Why is Electron Cash having libsecp256k1 issues on Fedora?",
          "answer": "Fedora changed their libsecp256k1 package upstream to Bitcoin Core version and created separate libsecp256k1-abc for Bitcoin ABC version. Problem: Both packages use the same shared library name (.so file), making them mutually exclusive - can't install both simultaneously. EC requires the ABC version (with Schnorr signatures), but if you have Electrum (BTC) installed, it needs Core version, causing conflicts. Solutions: 1) Use EC AppImage (bundles its own libsecp256k1), 2) Set up LD_LIBRARY_PATH for private lib, 3) Contribute fix as PR if you have Linux dev skills. The AppImage bypasses system package conflicts entirely."
        },
        {
          "question": "Why is CashFusion icon missing when I build Electron Cash from source?",
          "answer": "If you built EC from source but CashFusion icon doesn't appear in the bottom status bar, you likely didn't install the plugin correctly or missed dependencies. The CashFusion plugin needs specific setup when running from source: 1) Ensure all dependencies in requirements.txt are installed (especially protobuf), 2) CashFusion is a plugin that must be enabled, 3) Check Tools > Plugins to see if it's available. The AppImage version includes everything pre-configured with proper plugin setup. If building from source, follow the complete build instructions including plugin dependencies. Quick workaround: Use official AppImage which bundles fusion plugin correctly."
        },
        {
          "question": "Is Electron Cash Android available on Google Play Store?",
          "answer": "Yes, EC Android is still available on Google Play Store at: play.google.com/store/apps/details?id=org.electroncash.wallet. In August 2025, Google announced licensing requirements for crypto wallet apps that initially seemed to threaten all wallets, but they backtracked and clarified that non-custodial wallets (like EC) are exempt - only custodial services need special licensing. Community concern: Google controls major app distribution channel and has financial incentive (Google Pay) to restrict crypto wallets. Lesson: Don't rely solely on centralized app stores. EC is also available via: F-Droid (open source app store), direct APK download from electroncash.org, GitHub releases. Learn to sideload APKs - it's only a few clicks on Android."
        },
        {
          "question": "Why doesn't Electron Cash provide ARM64/aarch64 AppImage builds?",
          "answer": "Several challenges prevent official ARM64 AppImage: 1) EC uses older Python version requiring dependencies without prebuilt ARM64 binaries, 2) Reproducible build process is complex ('arcane' in maintainer's words), 3) Cross-compilation from x86-64 to aarch64 requires additional Docker setup, 4) Limited developer time for maintenance, 5) Testing infrastructure needed. Workarounds: Run from source using Python virtual environment (miniconda/conda recommended). Performance notes: Without compiling libsecp256k1, cryptographic operations are slow. With compiled libsecp256k1, casual use fine but CashFusion may still be slow on Raspberry Pi 4. Chris Troutner successfully built EC on Raspberry Pi (arm64), creating step-by-step README. Jonas: 'It should be possible to add some packages to the AppImage Dockerfile and cross compile it to aarch64 from an x86-64 host. But who has the time to do it and then maintain it.'"
        },
        {
          "question": "How do you run Electron Cash from source instead of AppImage?",
          "answer": "Running from source offers latest features and avoids binary trust issues. Steps: 1) Clone EC repository from GitHub, 2) Use virtual environment (conda/miniconda recommended by devs - JF: 'it does a wonderful job of managing python envs'), 3) Install Python dependencies from requirements.txt, 4) Optionally compile libsecp256k1 for performance (instructions in repo). Common issues: System packages (apt) conflicting with pip packages. Jonas: 'A problem is when system wide packages interfere with user local packages.' Solution: Use isolated virtual environment. For ARM64: More complex due to missing prebuilt wheels - may need to compile dependencies. emergent_reasons: 'except for libsec, not necessary to build to run from source. You can just literally run from source.' EC currently uses Python 3.11 in official builds (maintained by EchterAgo), but source can run on newer versions. Arch Linux users report success with latest Python versions via AUR package."
        },
        {
          "question": "Does AppImage use more RAM than running from source?",
          "answer": "Yes, AppImage has overhead compared to running from source. Shadow explains: 'AppImage eats lots of ram, more than running from source, because it creates and mounts a container.' AppImage bundles entire application with dependencies in single file, then mounts as FUSE filesystem at runtime. Overhead includes: 1) Filesystem mounting layer, 2) Duplicate libraries (system has them, AppImage has own copies), 3) Potential memory mapping inefficiencies. Running from source uses system Python and libraries directly - more memory efficient but harder to set up. Trade-off: AppImage provides easy installation and version isolation, source provides better performance and transparency. For users with tight memory constraints or wanting to minimize overhead: Use Python venv with system packages. Jonas reports successfully running EC from source on Raspberry Pi (ARM64) with this approach."
        },
        {
          "question": "What Python virtual environment approach is best for running EC from source?",
          "answer": "Multiple options with different trade-offs: 1) Python's built-in venv module: 2qx recommends 'The builtin venv module (-m venv) seems to give the least amount of headache over the long term, IMHO.' Lightweight, no external dependencies, straightforward. 2) Conda/Miniconda: JF and emergent_reasons prefer this - 'does a wonderful job of managing python envs.' More features, handles non-Python dependencies, but additional software to install. 3) System Python without venv: Can work (Tom uses on Arch via AUR) but risks system package conflicts. Common pitfall: Chris Troutner notes 'AI pointed out that the virtual environment was the source of some of the issue' - sometimes venvs add complexity. For EC specifically: Clone repo, create venv (python -m venv ec-env), activate it, pip install -r requirements.txt. EC GitHub README has instructions. Optionally compile libsecp256k1 for performance. Dustin: 'Once you have a venv, the EC readme on github gives you simple instructions.'"
        },
        {
          "question": "Is there an ARM64 AppImage for Raspberry Pi available?",
          "answer": "Yes! Chris Troutner built ARM64 AppImage in October 2025. Announcement: 'It took me about a week of vibe coding and a lot of trial and error, but I finally managed to build an AppImage for arm64 support. I've tested this on Raspberry Pi 4 and 5 B.' Available at github.com/christroutner/Electron-Cash (v4.2.3). Key features: 1) CashFusion works (tested by Chris), 2) Step-by-step build instructions in README, 3) Can build on Pi 5 (Pi 4 slower, may crash during build). Important caveats: Build is NOT reproducible (Ubuntu packages not version-pinned), Chris not planning to maintain it long-term, same protobuf issues as x86_64. Community response enthusiastic - Shadow: 'people can now easily run CashFusion 24/7 on their Raspberry Pis without having their main PC run 24/7.' However, Jonas notes: 'The big problem... of adding an arm64 build on every release is: Who will maintain it? Builds break, someone needs to fix it.'"
        },
        {
          "question": "Can EC be cross-compiled from x86_64 to ARM64?",
          "answer": "Theoretically yes, practically challenging. Shadow: 'you can cross compile to Pi, zero problem... A ready VM (or a docker container) can be easily crafted, built specifically with all the tools to cross-compile it.' However, Chris Troutner built on native ARM64 machine because: 1) PyQt5 binaries not available via pip for arm64 - had to copy from Ubuntu packages, 2) Many assumptions in build scripts about native architecture, 3) Unknown if all dependencies cross-compile correctly. Jonas notes Chris' solution: 'Download the ubuntu packages and copy them' (github link to _build_arm64.sh). Cross-compilation challenges: Different library ABIs, native build tools expect host architecture, Python wheels may not have arm64 versions. JF: 'normally we build windows releases on linux, but no idea about arm64.' Current path: Build on native arm64 (Pi 5 recommended), use Chris's modified build scripts, accept non-reproducible builds. Cross-compilation would require significant build system modifications."
        },
        {
          "question": "Is StartOS suitable for running Electron Cash and BCH infrastructure?",
          "answer": "Good for dedicated BCH infrastructure, not as daily driver replacement. StartOS (formerly Start9) testing underway for BCH. Adaptive Blocksize Limit: 'We are currently testing start9 actually it's very smooth to run but bchn still has some issues... I think the experience of using BCH apps on start9 is better than normal Linux.' emergent_reasons clarifies use case: 'I don't think anybody who uses linux as their daily driver is going to switch to start9 just for bch stuff. But for people who use it for mining or whatever, that seems like a good addition to the package.' Target audience: 1) BCH miners wanting easy infrastructure, 2) Newcomers needing plug-and-play setup, 3) Users wanting dedicated backend services machine. Not for: Daily driver Linux users, developers needing flexibility. Current status: BCHN being packaged (Jordan fixing issues), Fulcrum 2.0 available. Potential future: EC packaging for 24/7 CashFusion. StartOS provides UX simplification but trades off customization typical Linux users expect."
        }
      ]
    },
    {
      "name": "Legal & Licensing",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Are there legal risks for Electron Cash developers regarding bugs like incorrect price display?",
          "answer": "Under the MIT license, the software comes with no warranty. However, legal risks depend on jurisdiction and political visibility. While the MIT license provides disclaimer protection, it's not absolute. Users have responsibility (caveat emptor/vendor) to verify critical information. Developers should focus on moral/personal responsibility to provide quality software. The fact that EC is FOSS (Free and Open Source Software) and WYSIWYG (What You See Is What You Get) provides some protection, but edge cases with determined litigants could be complex."
        }
      ]
    },
    {
      "name": "Network & Architecture",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "How does Electron Cash connect to the Bitcoin Cash network?",
          "answer": "Electron Cash is not 'pure SPV'. It uses Fulcrum as middleware - EC talks to Fulcrum servers, which in turn talk to full nodes. Pure SPV would mean querying any full node directly using bloom filters, but EC uses dedicated indexers (Fulcrum) that maintain address and transaction indexes for fast queries. This architecture provides better performance than pure SPV while maintaining lightweight client benefits. Users can run their own Fulcrum server for maximum privacy and control."
        },
        {
          "question": "Where can I get help with running a Fulcrum server?",
          "answer": "There's a dedicated Telegram group for Fulcrum server support: @electroncashserver. This is the appropriate place for questions about Fulcrum setup, configuration, maintenance, and troubleshooting. The main Electron Cash group focuses on wallet usage, while the server group handles infrastructure topics."
        },
        {
          "question": "How can I learn about SPV and thin client technology in Bitcoin Cash?",
          "answer": "Good resources include: 1) The original Bitcoin whitepaper section on SPV, 2) https://flowee.org/news/2023-08-thin-clients/ which explains thin client concepts for BCH, 3) Understanding that EC uses indexed servers (Fulcrum) rather than pure bloom filter SPV. Key concept: EC queries Fulcrum which maintains address/transaction indexes, rather than querying full nodes directly with bloom filters like original SPV design."
        },
        {
          "question": "What is the technical definition of SPV and how does Electron Cash implement it?",
          "answer": "SPV (Simplified Payment Verification) is defined as a wallet that validates transactions by: 1) Checking merkle proofs to verify transaction inclusion in a block, 2) Confirming the block is in the chain with most Proof-of-Work. EC does perform these SPV checks. However, EC is more accurately described as an 'RPC/SPV' wallet - it uses SPV to verify proofs but relies on Fulcrum servers (RPC) for blockchain queries. This differs from BIP-37 'pure' SPV which uses bloom filters to query any full node directly. The distinction is primarily about networking architecture and has privacy implications."
        },
        {
          "question": "What is BCH's rolling checkpoint and how does it work?",
          "answer": "BCH's rolling checkpoint prevents deep reorganizations. The rule: 10 confirmations OR 2 hours, whichever is LONGER. This means: 1) If blocks are mined quickly (high hashrate), must still wait 2 hours for finality, 2) If blocks are slow, need minimum 10 confirmations. This prevents scenarios where hashrate spikes cause rapid block production followed by reorgs. You could theoretically reorg 100 blocks if they were all mined in under 120 minutes (unlikely but mathematically possible). The 2-hour minimum provides temporal security independent of confirmation count."
        },
        {
          "question": "How does HD wallet address generation work with the gap limit?",
          "answer": "HD (Hierarchical Deterministic) wallets generate addresses sequentially from a master seed using BIP32 derivation. The 'gap limit' (default 20 in EC) determines when to stop generating new addresses: the wallet generates addresses until it finds 20 consecutive UNUSED addresses, then stops. Online: wallet queries blockchain to check which addresses have transaction history. Offline: without blockchain access, wallet cannot determine usage, so it just generates the initial 20 addresses and stops there. This is why offline wallets work fine - they don't need to search for used addresses, they just generate the base set. The gap limit prevents infinite address generation while ensuring you don't miss funds sent to addresses further down the derivation path."
        },
        {
          "question": "Is the BCH dust limit always 546 satoshis for every output?",
          "answer": "No! The commonly cited 546 sat limit is specifically for P2PKH outputs with 1000 sat/kb minimum relay fee. The actual dust limit varies based on: 1) Output script type - P2SH outputs have different sizes, 2) Token data - CashToken outputs include additional data making them larger, 3) Minimum relay fee rate. Dust limit is calculated as 3x the cost to spend the output (based on input size). For P2SH with tokens, the limit can be significantly higher than 546. EC had the 546 value hardcoded, but a PR was created to calculate actual dust limits dynamically. Reference: libauth.org/functions/getDustThreshold.html documents the calculation method clearly."
        },
        {
          "question": "Is Electron Cash technically an SPV wallet?",
          "answer": "EC is described as 'RPC/SPV' wallet. It uses SPV (Simple Payment Verification) in that it performs merkle proof verification of transactions without downloading the full blockchain. However, purists note it doesn't connect directly to Bitcoin Cash nodes - instead it connects to Fulcrum servers which then connect to nodes. This two-step separation: 1) Improves scaling and performance (Fulcrum optimized for address queries), 2) Can enhance privacy (your IP separated from nodes), 3) Enables features like address indexing that nodes don't provide natively. You can run your own Fulcrum server connected to your own node for maximum trustlessness. The architecture is inherited from Electrum (BTC) and wasn't changed when EC forked."
        },
        {
          "question": "Why don't Bitcoin Cash nodes serve SPV proofs directly?",
          "answer": "Current BCH node p2p protocol limitations: 1) No direct txid->SPV proof query - you can't ask 'give me merkle proof for txid X', 2) 'getdata' only returns mempool/unspent transactions, not arbitrary historical ones (unless txindex enabled), 3) merkleblock (BIP-37) returns filtered transactions+proofs but requires bloom filter setup first. This is why SPV wallets must use intermediary services: either Electrum protocol (via Fulcrum servers) which provides convenient merkle proof API, or implement full BIP-37 bloom filter workflow. Alternative: BIP-157 (neutrino/compact block filters) but not implemented in BCHN. Result: EC's Fulcrum dependency isn't a design choice but a practical necessity given current node capabilities."
        },
        {
          "question": "What advantages does Electrum protocol provide over direct node connections?",
          "answer": "Electrum protocol (what Fulcrum implements) offers features nodes don't: 1) Merkle roots/proofs over headers - clients can store just root + minimal tip instead of entire header chain, 2) Address-based transaction queries - nodes can't query 'all transactions for address X', 3) Convenient SPV proof API - single call to get merkle proof for txid, 4) Header chain pruning support - verify once, store root, discard headers. For light clients wanting minimal trust: download header chain, verify it, compute trusted root, then discard headers. Future ideas: add header root/proof messages to node p2p protocol, service discovery so nodes can advertise if they run Fulcrum alongside. Currently, any SPV verification requires Electrum protocol."
        },
        {
          "question": "How much storage does downloading all blockchain headers require for SPV wallets?",
          "answer": "Approximately 4MB per year of blockchain history. For context: BCH has been running since 2009, so total header storage is ~64MB (16 years x 4MB). This is trivial on modern devices - most smartphone cameras take single photos larger than 4MB. Even downloading, parsing, and storing all headers from genesis to tip is orders of magnitude cheaper than watching one minute of YouTube. Mobile phones with 64GB+ storage don't notice this. SPV clients can also prune older headers once verified, keeping only recent 1000 headers plus a verified merkle root. This makes light wallet operation extremely efficient compared to full node requirements."
        },
        {
          "question": "Why does Electron Cash sync so much faster than other BCH wallets?",
          "answer": "EC's architecture uses Fulcrum servers (Electrum protocol servers) that maintain pre-indexed databases of all BCH transactions. When wallet comes online: 1) Downloads new block headers (small, fast), 2) Queries server with address list, 3) Server uses its index to return only relevant transactions for that wallet. Other wallets (Stack, Cake) may use different sync methods requiring more blockchain scanning. Key optimization: BCH ecosystem (EC, Fulcrum, BCHN) has been continuously developed for fast, efficient, scalable performance. Fulcrum's address-based indexing is the main speed advantage - you only download data relevant to your specific wallet."
        },
        {
          "question": "How does coinbase maturity affect spending newly mined coins?",
          "answer": "Coinbase outputs (block rewards including both subsidy and transaction fees) have a mandatory maturity period before they can be spent. This was coded by Satoshi: blockchain enforces 100 confirmations minimum, while original client required 120 confirmations for extra safety margin. Transaction shows 'mined in block X' but remains unspendable until maturity reached (~100-120 blocks = 16-20 hours on BCH). This prevents issues if the block gets orphaned in a reorg - premature spending of coins that might disappear causes bigger problems. Applies to entire coinbase output, not just subsidy. Mining pools wait for this reason before paying out."
        },
        {
          "question": "What are the trade-offs of reducing BCH block time from 10 minutes to 1 minute?",
          "answer": "Benefits: Faster first confirmation (~1 min vs 10 min), better UX for transactions ineligible for DSP (DeFi contracts, anyone-can-spend scripts), more responsive network. Costs: 1) 10x more block headers to validate and store (more overhead for SPV clients), 2) Higher orphan rates due to propagation delays, 3) Significant retooling required across ecosystem (wallets, nodes, services), 4) More frequent difficulty adjustments needed, 5) Coinbase maturity period (100 blocks) becomes 100 minutes vs 1000 minutes. Key debate: DSPs + first-seen rule already secure most 0-conf transactions, so faster blocks mainly help edge cases. KISS principle: Some argue improving DSP coverage is simpler than changing fundamental block timing."
        },
        {
          "question": "What is Fulcrum and why is it important for BCH ecosystem?",
          "answer": "Fulcrum is high-performance Electrum protocol server developed by Calin Culianu. Role: Maintains indexed database of all BCH transactions, provides fast address-based queries to SPV clients. Why important: 1) Powers Electron Cash's fast sync and balance queries, 2) Enables SPV proof verification, 3) Provides DSProof data to wallets, 4) Serves as infrastructure for many BCH services beyond EC, 5) Optimized for scalability (handles large blocks efficiently). You can run your own Fulcrum connected to your node for maximum trustlessness. Public Fulcrum servers handle most user connections. It's the 'engine behind the scenes' that makes light wallet experience smooth compared to direct node connections."
        },
        {
          "question": "What happens if BCH implements 1-minute blocks and exchanges respond?",
          "answer": "Exchanges will likely increase confirmation requirements by 10x to maintain same security level (same cumulative proof-of-work). Current 6-conf requirement becomes 60-conf requirement. Result: No actual speed improvement for exchange deposits. Potential problems: 1) Some exchanges may forget to update settings (temporary faster deposits until they notice), 2) Block reward comparisons to BTC become confusing (0.1x per block), 3) Marketing becomes harder ('our blocks are faster but also worth less'). The 'benefit' relies on businesses not understanding the change or legacy systems with hardcoded confirmation counts. Ironic outcome: Main practical benefit is psychological (seeing confirmations tick faster) not actual faster finality for services requiring confirmations."
        },
        {
          "question": "How do 1-minute blocks affect SPV wallets like Electron Cash?",
          "answer": "SPV clients download block headers to verify proof-of-work chain. With 1-minute blocks: Headers grow 10x faster - instead of ~4MB/year, now ~40MB/year. Impact: 1) Initial sync takes longer (download all historical headers), 2) Storage requirements increase for light wallets, 3) More bandwidth used for ongoing sync. For full nodes: Minimal impact since transaction data dominates storage. Headers are small (80 bytes each), but 10x more adds up over years. EC already handles header pruning (store only recent 1000 + verified merkle root), but this becomes more important with faster blocks. Trade-off is real but not catastrophic - modern phones handle it fine."
        },
        {
          "question": "What are the arguments against changing BCH block time to 1 minute?",
          "answer": "Multiple downsides identified by community: 1) SPV clients need 10x more header storage, 2) Higher orphan rates from network propagation delays, 3) Exchanges just increase confirmation requirements (no real speed gain), 4) Erodes Bitcoin heritage - block rewards no longer comparable to BTC, 5) Makes BCH harder to explain/market, 6) Massive ecosystem retooling required, 7) Doesn't actually solve DeFi MEV problems (bots adapt to faster blocks), 8) Psychological comfort only - first confirmation feels faster but same PoW security. Counter-argument: DeFi benefits from lower variance and faster state updates. Community consensus: Need extensive benchmarking (orphan rates with 32MB blocks at 1-min intervals) before any decision. KISS principle applies - don't change fundamentals without clear overwhelming benefit."
        },
        {
          "question": "Why do smart contracts need block confirmations when payments work with zero-conf?",
          "answer": "Smart contracts can have competing unconfirmed transaction chains in the mempool. Example: AMM DeFi where multiple users interact with same contract UTXO simultaneously. Problem: Until next block, it's uncertain which transaction chain becomes valid. If user builds transaction on 'wrong' unconfirmed chain, their transaction gets cancelled when block confirms different chain. This requires waiting for state reconciliation - average 10 minutes with current block time, outlier cases up to 1.5 hours. Regular payments don't have this issue because they spend from user's own UTXOs with no competition. This is key argument for faster blocks (1-minute) - reduces wait time for DeFi state updates."
        },
        {
          "question": "Why would 1-minute blocks help with large block scalability?",
          "answer": "Counter-intuitive benefit: Smaller, more frequent blocks are easier to process than infrequent large blocks. With current 10-minute target, scaling to 1GB blocks means processing 1GB every 10 minutes in one burst. With 1-minute blocks, same throughput splits into 100MB blocks every minute - steadier processing load, better for network propagation, smoother resource utilization. Mining nodes handle continuous smaller workloads better than periodic massive ones. This spreads CPU/bandwidth usage more evenly. However, trade-off: 10x more block headers to validate/store, more frequent difficulty adjustments needed, coinbase maturity becomes 100 minutes instead of ~1000 minutes for same block count."
        },
        {
          "question": "Does Electron Cash support Neutrino/BIP-157 compact block filters?",
          "answer": "No, EC doesn't implement Neutrino (BIP-157 compact block filters) and there are no current plans to add it. Background: Neutrino is alternative to bloom filters for SPV privacy - client downloads block filter commitments, matches locally, requests only relevant blocks. Benefits: Better privacy than bloom filters, don't reveal addresses to servers. EC's situation: Uses Electrum protocol (Fulcrum servers) instead of direct node connections, which provides similar benefits differently. BCHD node software supports Neutrino, but EC can't connect to it directly. Future possibility: Could be implemented as option alongside current Fulcrum connection, but requires significant development effort. Current priority is improving existing features (RPA integration, CashTokens support) over protocol changes."
        },
        {
          "question": "Is BIP-157/158 (Neutrino/compact block filters) the same as Bloom filters?",
          "answer": "No, they're different privacy techniques: 1) Bloom filters (BIP-37): Send probabilistic filter to server/node, they return matching transactions. Privacy: false positives hide exact addresses, but still reveals info to server. 2) BIP-157/158 (Compact Block Filters): Client downloads block filter commitment, matches locally, requests only relevant blocks. Privacy: Server sees which blocks you request, not which addresses. BIP-157/158 is p2p protocol extension - requires node support (BCHD implemented it, BCHN hasn't). EC uses neither directly - it uses Electrum protocol (Fulcrum servers) which provides different privacy model. JF notes: 'completely different than how EC works - almost apples and oranges'."
        },
        {
          "question": "How does moderation work in Nostr-Telegram bridges, and why is centralization unavoidable?",
          "answer": "Bridges between decentralized (Nostr) and centralized (Telegram) platforms face inherent moderation challenges. Current approaches: 1) Blacklist - Client operator maintains JSON file of banned pubkeys, frontend filters out their posts (doesn't involve relay), 2) Whitelist/NFT gating - Users purchase $1 NFT to gain posting rights, creating economic barrier to spam, 3) Channel owner bans - Nostr group owner can ban users, bridge respects this. Why centralization is unavoidable: Bridge must aggregate messages from one platform to another, so someone controls that aggregation. Unlike pure Nostr where users can ignore relays, Telegram users can't individually mute bridged messages (normal users can't mute others in group chat). Best solution: Whitelist approach (NFT = whitelist) rather than reactive blacklist, since spam takes time to notice and ban. Trade-off: Loses some of Nostr's censorship-resistance properties when bridging to centralized platforms."
        },
        {
          "question": "What is Anubis and how does proof-of-work prevent bot abuse?",
          "answer": "Anubis (github.com/TecharoHQ/anubis) is a proof-of-work challenge system for web applications. How it works: Before processing request, server requires client to solve SHA256 hash puzzle (find nonce that produces hash with certain number of leading zeros). Impact: 1) Bots running millions of instances must spend 1000x compute resources per request, 2) Normal users barely notice (browser does computation in background), 3) Makes mass-scraping/spam economically unfeasible. Use case discussed: Block explorer getting hammered by botnet with random user agents - rate limiting affects legitimate users, but PoW targets automated abuse specifically. Shadow's insight: 'Bots are usually cheap to run, are run in millions, billions instances. If they have to spend 1000x the resources on a request, they would maybe decrease the share of resources used to scan your website.' Alternative to CAPTCHAs that doesn't require third-party services and respects user privacy."
        },
        {
          "question": "What is BIP-21 vs JPP in payment requests?",
          "answer": "BIP-21 is URI scheme specification: 'bitcoincash:address?amount=X&label=Y' - simple standardized way to encode payment info in QR codes. JPP (JSON Payment Protocol) is full payment protocol: Interactive exchange between wallet and merchant server returning JSON with payment details, multiple outputs, expiry time, memo, etc. Relationship: BIP-21 URI can include 'r=' parameter pointing to JPP server URL (bitcoincash:?r=https://server/invoice/123). When EC scans such QR: 1) Parses BIP-21 URI, 2) Sees 'r=' parameter, 3) Fetches JSON from that URL using Accept: application/payment-request header, 4) Parses response for outputs array. JPP advantages: Multiple outputs in single payment, merchant can set exact fee rate, expiry times, invoice memos. JPP vs BIP-70: JPP uses JSON instead of protobuf, simpler implementation. Currently EC only accepts JPP from BitPay domain, limiting broader ecosystem adoption of this payment standard."
        },
        {
          "question": "What is the difference between BIP-70 and JSON Payment Protocol (JPP)?",
          "answer": "Both are payment request protocols but use different serialization: BIP-70 uses binary protobuf format, JPP uses JSON. BitPay invented JPP as alternative to BIP-70. Key insight from Tom: 'The wallet decides if they fetch from the server the binary or the json. The server has to do both' (if they want broad compatibility). Same URL can serve different formats based on Accept header in HTTP request. EC sends 'Accept: application/payment-request' to fetch JSON. Advantages of JPP: Easier to debug (human-readable), simpler implementation (no protobuf dependency), modern web-friendly. Advantages of BIP-70: More established, smaller payload size, certificate validation. In practice: BitPay supports both, Paytaca supports JPP only, Flowee Pay supports BIP-70 only. For maximum compatibility, servers should implement both protocols."
        },
        {
          "question": "What is Fulcrum 2.0 and why is it significant for Electron Cash?",
          "answer": "Fulcrum is the Electrum Protocol server (written by Calin Culianu) that EC connects to for blockchain data. Version 2.0 released September 2025 is major milestone. Fulcrum serves as bridge between full nodes (BCHN) and lightweight wallets (EC). Why significant: 1) EC depends on Fulcrum servers for address history, balance queries, transaction broadcasting, 2) Performance improvements benefit all EC users, 3) New features may enable EC functionality, 4) Critical infrastructure for BCH ecosystem. Fulcrum 2.0 adds support for newer protocols, better performance, bug fixes. Community celebrated release - shows active development of BCH infrastructure. Running your own Fulcrum server increases privacy (don't query third-party servers) and network resilience. StartOS integration discussions underway to make running BCHN+Fulcrum easier for home users."
        },
        {
          "question": "What components in Electron Cash use protobuf and why is it dependency?",
          "answer": "Protobuf (Google's Protocol Buffers) used in multiple EC components: 1) CashFusion - for communication protocol between fusion participants, 2) BIP-70 payment requests - legacy payment protocol uses protobuf for message serialization, 3) CashShuffle - privacy mixing protocol communication, 4) KeepKey hardware wallet plugin - device communication. Jonas: 'Yes, BIP-70 and the KeepKey plugin... CashShuffle also uses protobuf.' Why protobuf: Efficient binary serialization, language-neutral, schema validation, backward compatible. Problem: Google's protobuf library has been 'disaster for a decade' (Tom's words) with frequent breaking changes. Alternative: Tom wrote custom protobuf implementation for Flowee - 'Their protocol is stable, it's the software that's been a disaster.' EC approach: 'we try to build as much from source as possible in appimage' (EchterAgo) for security/reproducibility, but this causes build challenges. Could fetch prebuilt binaries instead (already done for PyQt) but loses source-verification benefit."
        },
        {
          "question": "How does EC's Docker-based build process work?",
          "answer": "EC builds happen inside Docker containers for reproducibility and isolation. Jonas explains: 'The Dockerfiles used for doing the builds is included in the EC source repo. In fact, the build scripts start off by actually building a docker image, launch a container and do the build inside that container.' Process: 1) contrib/build-linux/appimage/ contains Dockerfiles and build scripts, 2) Script builds Docker image with specific base (Ubuntu version, Python version), 3) Container launched with controlled environment, 4) Dependencies installed from pinned requirements.txt inside container, 5) EC compiled with known toolchain, 6) AppImage assembled with all dependencies bundled. Benefits: Same container on any machine produces identical output, isolates from host system variations, version-controlled entire build environment. Challenge: Maintaining Dockerfiles as upstream changes (Python EOL, package updates). EchterAgo maintains these build infrastructure components."
        },
        {
          "question": "Would upgrading EC from Qt5 to Qt6 fix Wayland-related issues?",
          "answer": "Possibly yes - Qt6 has better Wayland support. Jonas suggests: 'could this possibly be an issue that could be chalked up on the fixed if we move to Qt6 list?' Background: Qt5 was designed primarily for X11 with Wayland support added later. Qt6 designed with Wayland as first-class citizen. Specific benefits: 1) Better DPMS (monitor power management) handling, 2) Improved compositor integration, 3) Modern Wayland protocol support, 4) Bug fixes accumulated over years. Challenge: Qt5 to Qt6 migration is significant effort - API changes, deprecated features, PyQt5 to PyQt6 migration. Current EC uses PyQt5 extensively. Multiple users run EC on Wayland without issues (Jonas on Ubuntu 24.04, Andy on Arch), so Qt6 may not be strictly necessary. More immediate fix: Update Qt5 version in AppImage, or use system Qt (AUR package approach). Qt6 migration is on roadmap but not imminent due to complexity and limited maintainer resources."
        },
        {
          "question": "What DDoS protection works for BCH block explorers?",
          "answer": "Anubis proof-of-work challenge effective and easy to deploy. ichundes reports: 'i had to put ddos protection in front of my explorer because some botnet was hitting it to the point of memory exhaustion.' Solution: 'it was quite easy to set up the protection using anubis.techaro.lol.' How it works: First-time visitors solve brief proof-of-work challenge (like mini-mining), bots struggle with computational cost while humans barely notice. Attack context: 'this is likely part of some botnet c&c, but why scrape the explorer instead of just directly querying fulcrum?' ichundes theorizes: 'traffic on port 443 looks more normal and is allowed by more firewalls.' Tom notes broader pattern: 'I've noticed a lot of scraping of stupid content... I think this is all just AI training data that is being resold.' Traditional IP blocking ineffective: 'I started with an IP blockage solution, but after blocking thousands (and some subnets) they just kept coming from new ones.' Proof-of-work protection superior: Shifts cost to attacker proportionally to their scale, legitimate users unaffected. Infrastructure operators should implement before attacks, not after."
        },
        {
          "question": "Why can't Fulcrum servers easily run on port 443 alongside web servers?",
          "answer": "Protocol mismatch: Fulcrum uses raw TCP, not HTTP. tula s asks: 'why are all the EC servers on 50002? wouldnt it make sense to put a few on 443?' Problem: Running behind corporate firewalls requires port 443 (HTTPS), but Fulcrum uses JSON-RPC over TCP without HTTP headers. Andy explains: 'Fulcrum needs TCP reverse proxying and the website needs HTTP... There's no headers in fulcrum requests to filter on.' Nginx reverse proxy challenge: HTTP servers identified by Host header, but raw TCP connections have no such identification. Calin confirms: 'fulcrum doesn't use http (unless you are using the websockets interface...)' and 'raw bare TCP sockets which have no headers and no way to filter.' Workaround: pat shares solution: 'I combine the self-signed 50002 classic port exposed from docker with a 443 aided by nginx + ssl configured for my domain name over a reverse proxy.' Requires different subdomain/IP for Fulcrum on 443. Fulcrum does have WebSocket endpoint (HTTP-based) which could work, but EC clients expect traditional TCP connection. Corporate firewall workaround remains challenge."
        },
        {
          "question": "How do you configure Fulcrum on both standard and firewall-friendly ports simultaneously?",
          "answer": "Use nginx reverse proxy with different subdomains. pat demonstrates: 'I combine the self-signed 50002 classic port exposed from docker with a 443 aided by nginx + ssl configured for my domain name over a reverse proxy. so fulcrum.pat.mn:443 and fulcrum.pat.mn:50002 are available at the same time.' Setup: 1) Fulcrum binds to internal port (e.g., 50002), 2) Nginx terminates TLS on port 443 using domain certificate, 3) Nginx proxies to Fulcrum's internal port. Important: This works because Fulcrum gets its own subdomain - nginx can route based on Server Name Indication (SNI) in TLS handshake. Andy's concern: 'If you ran it on 443 you wouldn't be able to run a web server on the same IP' - true for same domain, but different subdomains work. Calin acknowledges: 'i can configure my server to offer an alternate 443 port for ssl' but federation/peering logic needs consideration. Benefit: Corporate networks that only allow 443 can now connect. WSS (WebSocket Secure) is alternative but requires client support."
        },
        {
          "question": "What tools help simplify nginx reverse proxy configuration?",
          "answer": "https-portal Docker container recommended. Damascene suggests: 'Use https-portal it made my life easier.' WT complains: 'I always crash and burn when I try to configure nginx.' https-portal provides: Automatic Let's Encrypt certificate renewal, simple configuration syntax, Docker integration, reverse proxy setup without deep nginx knowledge. Alternative approaches: Direct nginx configuration (complex but flexible), Caddy (simpler config than nginx), Traefik (container-native). For Fulcrum specifically: Tom shares example: 'I recently used the idea of wrapping a http-only in nginx to make it use the https part of the bigger website. It's awesome.' Points to Flowee wallet-backup-server readme for configuration example. Key insight: Infrastructure complexity shouldn't prevent running BCH services. Tools like https-portal lower barrier to entry. Important: Still need to understand what you're proxying - nginx is just traffic routing, doesn't modify Fulcrum's protocol requirements."
        },
        {
          "question": "What is the technical reason there's 'no such thing as a from address' in Bitcoin?",
          "answer": "Inputs reference UTXOs, not addresses - address derivation requires assumptions. Tom warns: 'just want to jump in and remind people that there is no such thing as a from address. It just happens to work in a lot of cases, but if you build software to depend on it, you will feel pain at some point.' Technical reality: Transaction inputs contain: prevout_hash (previous tx ID), prevout_n (output index), scriptSig (unlocking data). No explicit address field. To get 'from address': Must examine previous transaction's output script, parse that script to determine type (P2PKH, P2SH, etc.), hash appropriately to create address. This fails for: Complex contracts with multiple spending paths, P2S scripts (coming next year), coinbase transactions, non-standard scripts. Tom's advice: 'Adding a refund address should be part of a good payment protocol.' For accounting/UX: Address derivation is convenience feature, not protocol requirement. emergent_reasons confirms: 'I think tom is talking about refund addresses, but that's not what I need anyway' - his use case is transaction export for accounting, where addresses are needed for reporting despite protocol limitations."
        },
        {
          "question": "What is P2S and why will it change transaction parsing next year?",
          "answer": "P2S (Pay-to-Script, native script addresses) is upcoming BCH upgrade. Tom: 'Anything that isn't p2pkh or p2sh. Now, granted, today that means those transactions are not standard. But next year you'll see a lot of p2s ones.' emergent_reasons: 'ah. yeah p2s soon. fun times :D' P2S characteristics: Native script outputs (not wrapped in hash), introspection capabilities, VM limits improvements. How it differs: Current P2SH: Output contains hash of script, script revealed at spending time. P2S: Output contains actual script directly. Parsing impact: Even more complex input patterns, different scriptSig structures, new address types. Current heuristics: Won't work at all for P2S inputs. Tom earlier: 'just want to jump in and remind people that there is no such thing as a from address' - becomes more relevant as script diversity increases. Implication: EC's transaction parsing needs modernization. Current approach (heuristic matching) increasingly inadequate. emergent_reasons' export issue is preview of challenges ahead. Solution space: Full input fetching (like PR #3145), better type detection, support for explicit type hints in transaction metadata."
        },
        {
          "question": "Why can't you distinguish P2SH20 from P2SH32 addresses without previous output?",
          "answer": "Same redeem script creates different addresses based on hash algorithm chosen. Calin explains: 'there is no way to differentiate p2sh20 from p2sh32 if the only thing you are allowed to examine about the chain is the scriptSig of the input and nothing else.' Technical details: P2SH20 uses HASH160(redeemScript)  20 bytes, P2SH32 uses SHA256(redeemScript)  32 bytes. Same redeem script, different output types. Dustin confirms: 'I wrote a script to generate both from the same redeem script.' scriptSig contains: Unlocking data plus redeem script (for P2SH). No indication of which hash algorithm was used for the original lock. Calin's colorful explanation: 'so even IF you perfectly solved the problem of heuristic matching for p2sh due to your being a supernatural being and bending the fabric of reality... you would still be faced with the impossible problem of deciding if this thing is p2sh32 vs p2sh20.' Dustin realizes: 'My redeem script that works will always be returned as P2SH20 even if I iterate a new one with the intention of using P2SH32.' This is fundamental Bitcoin design, not EC bug."
        },
        {
          "question": "What makes a P2SH address and how does it map to on-chain data?",
          "answer": "Calin teaches via Socratic method: 'what does this address instruct software to do when composing a txn paying out to that address? what happens on the lower level like on the txn output level?' Answer: P2SH address = hash of redeem script, encoded with specific prefix. Dustin correctly states: 'A P2SH or P2SH32 address is the hash of the redeem script.' Creating payment: Address decoded  hash extracted  locking script constructed (OP_HASH160 <hash> OP_EQUAL). Spending that payment: Must provide: data satisfying redeem script + redeem script itself. Verification: Node hashes provided redeem script, compares to stored hash, then executes script. Calin: 'how does an address map to... the locking script in an output (scriptPubKey as the Satoshi-derived nodes call it).' Key insight: Address is just encoding of output type + hash. When examining input (spending), you see unlocking data, not locking type. This architectural decision (minimal transaction size) means parsers can't definitively identify input types without external data."
        },
        {
          "question": "Why do Bitcoin transactions contain minimal information by design?",
          "answer": "Space efficiency and trust model. Calin explains architectural decision: 'the reason it's this way -- it's just because txns contain minimal information and require external information to be fully evaluated (such as coins being spent).. so it is what it is.' Alternative considered: 'an alternative design that wasted space would have been to include all the extraneous information in the txn itself but that would be a waste of space since the node needs to have original forms of that information ANYWAY that it trusts.' Trust model: Node must verify against its own chain state, can't trust transaction's self-reported metadata. Example: Transaction says 'I'm spending UTXO X', node must look up UTXO X to verify: Does it exist? What's its locking script? What's its value? Including that info in transaction is redundant - node validates against source-of-truth anyway. Implication for wallets: 'so we are stuck in a reality where all we see is scriptSig and we have to guess what the hell it was originally as an output that is being spent.' This is fundamental blockchain design trade-off: Compact transactions vs self-contained transactions."
        }
      ]
    },
    {
      "name": "Plugins & Extensions",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "What is Electron Cash Wallet Connect?",
          "answer": "Electron Cash Wallet Connect is a plugin that allows Electron Cash to connect to decentralized applications (dApps) on Bitcoin Cash. Version 0.02-alpha added support for complex contracts requiring user's public key and signature. It enables signing transactions and messages from web-based dApps directly in your Electron Cash wallet. Future versions will support multi-connection (connecting to multiple dApps simultaneously). The plugin is being actively developed with plans for eventual integration into mainline EC."
        },
        {
          "question": "Where is the Cosigner Pool plugin in Electron Cash?",
          "answer": "The Cosigner Pool is a built-in optional feature, not an external plugin. Find it under Tools > Preferences > Optional Features, not under Plugins. It allows multisig wallet participants to share partially signed transactions through a server. The server is still running (as of Feb 2025) and works for software wallets, but NOT for hardware wallets. Alternative methods for sharing PSBTs: QR codes (Tools > Show QR), raw hex (Ctrl-T to load), or through secure messaging apps."
        },
        {
          "question": "Where can I find the Double Spend Proof (DSP) plugin for Electron Cash?",
          "answer": "The DSP plugin is available as a GitHub pull request (PR #2331: https://github.com/Electron-Cash/Electron-Cash/pull/2331). It's not yet merged into the main release. To use it, you need to either: 1) Run from the specific PR branch, or 2) Wait for it to be merged and released officially. The plugin enables double-spend proof detection in EC. Status as of Feb 2025: waiting for code review from maintainers. Report any issues in the PR comments or the EC Telegram group."
        },
        {
          "question": "What is the WalletConnect (WC) plugin for Electron Cash?",
          "answer": "The WalletConnect plugin (developed by OPReturn, funded via Flipstarter) allows EC desktop to connect with web3 BCH dApps like Cauldron DEX. It's currently in alpha stage. Features: scan QR code to connect EC to websites, approve transactions from dApps directly in EC, interact with CashTokens and DeFi protocols. Known issues: some users report crashes when approving transactions (likely threading-related bugs), repeated password prompts before crash. The plugin is actively developed with new versions coming. To use: enable in Tools > Plugins, scan WalletConnect QR from dApp website. This brings MetaMask-like functionality to BCH ecosystem."
        },
        {
          "question": "How do I install plugins in Electron Cash if they fail to load?",
          "answer": "Common WalletConnect plugin installation issue: Error occurs when zip file is corrupted or wrong version. Troubleshooting: 1) Re-download plugin zip from official source (ensure latest version), 2) Verify file integrity (checksums if available), 3) Ensure zip isn't damaged during download, 4) Same version number doesn't mean identical files (updates within version possible), 5) Check GitHub releases for plugin changelog. Installation: Tools > Plugins > Install plugin from zip. If errors persist: check EC console for specific error messages, report to plugin developer with error details. Important: Only install plugins from trusted sources (official flipstarter campaigns, known developers). Plugins have full access to your wallet."
        }
      ]
    },
    {
      "name": "Privacy & Address Management",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Why is RPA wallet change address handling a privacy concern?",
          "answer": "RPA wallets lack separate change derivation, causing linkability issues. Jonas warns: 'Be careful when spending from the RPA wallet. Best thing to do is to send each and every UTXO separately to a normal wallet and fuse from there.' Dustin explains problem: 'IIUC, all change consistently goes to the same address, tying each transaction from the wallet together.' JF details implementation: 'If you're asking about sending from an RPA wallet, there's no change address, so whether you're doing a normal send or another RPA send, the change goes back to the originating UTXO.' Privacy impact: Andy: 'If you use multiple UTXOs in one transaction they're linked and chain analysis can determine who you are if you mix with exchange funds.' Recommended workflow: 1) Receive to RPA wallet (protects sender's privacy), 2) Transfer each UTXO individually to normal wallet, 3) Use CashFusion from normal wallet to break linkability. Inter-Wallet Transfer plugin automates this: github.com/KarolTrzeszczkowski/Inter-Wallet-Transfer-EC-plugin. Current RPA is privacy tool for receiving, not comprehensive privacy solution for spending."
        },
        {
          "question": "Is RPA (Reusable Payment Address) feature production-ready in EC?",
          "answer": "Yes, stable and live for over a year. Glaxweb asks: 'any update with the reusable public key project?' Shadow confirms: 'Yes, it is LIVE in latest Electron Cash, has been for a year+. You need to create a new wallet and choose RPA as the wallet type.' Stability status: 'Indeed, it is a stable feature. I don't remember any serious bugs reported [lately].' Setup: File > New Wallet > RPA Wallet type. Use case: Share one address publicly, each sender's payment goes to unique derived address - protects sender privacy and prevents address reuse. Limitations to understand: 1) Change goes back to same address when spending (breaks privacy), 2) CashFusion not available in RPA wallets directly, 3) Best practice is sweep UTXOs individually to normal wallet before spending. Future: Work ongoing to integrate RPA into normal wallets with CashFusion support. Current RPA is specialized tool for receiving payments with enhanced sender privacy, not replacement for regular HD wallets."
        },
        {
          "question": "What is the Inter-Wallet Transfer plugin and why is it useful for RPA?",
          "answer": "Plugin automates moving UTXOs between wallets individually for privacy. Andy mentions: 'There's an inter-wallet transfer plugin that can automate it.' 2qx provides link: github.com/KarolTrzeszczkowski/Inter-Wallet-Transfer-EC-plugin. Created by Karol Trzeszczkowski. Use case: RPA wallet receives multiple payments, each to unique derived address. To maintain privacy when spending: Transfer each UTXO separately to CashFusion-enabled wallet. Manual process is tedious with many UTXOs. Plugin automates: 1) Select source wallet (RPA), 2) Select destination wallet (normal with CashFusion), 3) Configure to transfer one UTXO per transaction, 4) Plugin executes transfers automatically. Adaptive Blocksize Limit: 'This would be very helpful for me until RPA make it to normal wallets where we can use cashfusion.' Important: Without this automation, users might combine multiple RPA UTXOs in single transaction, destroying privacy benefit. Plugin is third-party, verify code before trusting with funds. Maintainer is known EC plugin developer, same person who created scheduled payments plugin."
        }
      ]
    },
    {
      "name": "Privacy & CashFusion",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Where can I view CashFusion statistics and usage data?",
          "answer": "CashFusion statistics are available at https://fusionstats.redteam.cash/. This site shows fusion activity, participation rates, and other metrics about CashFusion usage on the network. It's maintained by Rucknium (aka RedTeam), a privacy researcher in the BCH ecosystem."
        },
        {
          "question": "Why doesn't Electron Cash have a map feature to show wallet users?",
          "answer": "Privacy is the main reason. Users don't usually want to inform the network of their location. Additionally, there's a lack of good open and free map solutions. Most BCH vendor maps are closed/proprietary (like bitcoin.com map) which could block access, and many have outdated entries. OpenStreetMap has been suggested but adoption has been slow. EC prioritizes user privacy over network visibility features."
        },
        {
          "question": "What are the privacy implications of Electron Cash's architecture compared to BIP-37 SPV?",
          "answer": "EC/Electrum-style architecture has a significant privacy downside: the wallet directly tells the server all addresses of interest, allowing the server to build a complete profile of your wallet. BIP-37 SPV uses probabilistic bloom filters instead, which provides some plausible deniability (though not perfect). However, BIP-37 has its own issues. The trade-off is that EC's approach is more efficient and reliable. For maximum privacy in EC, run your own Fulcrum server or use Tor/VPN connections to public servers."
        },
        {
          "question": "Does changing CashFusion mode reset the fusion round counter?",
          "answer": "No, the fusion round counter is preserved when you switch modes (Normal, Consolidate, Fan-out). If your coins have been fused 2 times out of a target of 3 rounds, switching modes keeps that count at 2/3. The round tracking is per-coin, not per-mode. This allows you to change strategies mid-fusion without losing progress. The fusion plugin tracks each coin's history regardless of which mode was used for each fusion."
        },
        {
          "question": "Can I set up Electron Cash to auto-start and fuse without entering a password?",
          "answer": "Yes, but ONLY with an unencrypted wallet. The password is used to decrypt the wallet file itself, so there's no way to auto-start an encrypted wallet. For automatic fusion: 1) Create an unencrypted wallet (leave password blank during setup), 2) Configure your OS to launch EC at boot with that wallet, 3) Enable auto-fusion in CashFusion settings. WARNING: Unencrypted wallets can be stolen by anyone with device access - it's equivalent to hanging the key next to a locked door. Use this only on dedicated, secured machines."
        },
        {
          "question": "Why doesn't CashFusion appear in my Electron Cash installation on Raspberry Pi?",
          "answer": "CashFusion requires working libsecp256k1 for cryptographic operations. When running from source on ARM, libsecp256k1 may not be properly compiled/linked. Check Tools > Plugins > CashFusion to see if it's enabled. If missing: 1) Ensure libsecp256k1 is compiled for ARM (run `contrib/make_secp`), 2) Install in a proper virtual environment with all dependencies, 3) Verify Python can import the crypto library without falling back to pure Python. The pure Python fallback is too slow for fusion operations."
        },
        {
          "question": "If I can browse with Tor Browser, why doesn't Electron Cash connect through Tor?",
          "answer": "Tor Browser and EC use Tor differently. EC needs to connect to Fulcrum servers via SOCKS5 proxy. Configuration: 1) Tools > Network > Proxy tab > Select SOCKS5, 2) Set Host: 127.0.0.1, Port: 9050 (or 9150 if using Tor Browser's proxy), 3) Enable 'Use Tor proxy for all connections'. Also consider using .onion server addresses for Fulcrum. EC won't automatically use your system's Tor setup - it needs explicit proxy configuration. For CashFusion over Tor, ensure the fusion server is also reachable over Tor."
        },
        {
          "question": "Is CashFusion still operational in 2025?",
          "answer": "Yes, CashFusion is fully operational and actively used. The fusion servers are running and participants are fusing daily. Statistics available at https://fusionstats.redteam.cash/. CashFusion requires: 1) EC desktop (not available on mobile yet), 2) Plugin enabled in Tools > Plugins, 3) Minimum balance to participate in fusion rounds, 4) Patience as rounds fill up with participants. The protocol provides trustless mixing for improved privacy without custody risk."
        },
        {
          "question": "Why do I get timeout errors when using CashFusion over Tor?",
          "answer": "Tor connection timeouts are completely normal and expected behavior. Tor routes traffic through multiple relays which introduces latency and connection failures. These errors don't indicate a problem with CashFusion itself. Solution: Just ignore the timeout errors and wait for successful fusions. EC will automatically retry connections. The timeouts are common whether using Tor for web browsing or other purposes. Your coins remain safe - failed fusion attempts don't affect your funds. Eventually fusions will succeed when connections stabilize."
        },
        {
          "question": "How long does it take to fuse large amounts like 100-800 BCH?",
          "answer": "Fusing large amounts can take considerable time depending on: 1) Current number of active fusion participants (low activity = slower), 2) How your funds are structured (one big UTXO vs many smaller ones), 3) Fusion mode selected. Real-world example: ~20 BCH fused per day with moderate activity, so 100 BCH could take 5+ days, 800 BCH potentially weeks. Speed improves over time as coins get split into fusion-friendly sizes. Key insight: Use 'Fan-out' mode for large consolidated UTXOs to split them up first, which dramatically speeds subsequent fusions. Fusion speed depends on matching with other participants in similar value tiers."
        },
        {
          "question": "When should I use CashFusion's 'Fan-out' mode vs 'Consolidate' mode?",
          "answer": "Choose based on your current UTXO structure: 1) Fan-out (Spread out): Use when you have large consolidated piles (e.g., one 700 BCH UTXO). This splits big UTXOs into many smaller ones, making them match more fusion tiers and dramatically speeding up the process. 2) Consolidate: Use when you have many tiny UTXOs that need combining. 3) Normal: Balanced approach for typical usage. All modes are equally safe security-wise - they just optimize for different UTXO structures. The fusion round counter is preserved when switching modes, so you won't lose progress. Tip: Switch modes if fusions are too slow - your coin structure probably needs adjustment."
        },
        {
          "question": "What is Fusion Fridays and when are fusion participants most active?",
          "answer": "Fusion Fridays is a community initiative where BCH users focus on running CashFusion on Fridays to increase participant count and improve fusion speed. Higher participation means: more fusion rounds complete faster, better anonymity sets, shorter wait times. Activity varies with events (e.g., during conferences like BCH events in Slovenia, fewer people may be fusing). There's no guaranteed 'best time' but Fridays historically have higher activity. The community encourages running fusion clients 24/7 (similar to BitTorrent seeding) to provide consistent liquidity for everyone. Check fusionstats.redteam.cash for current activity levels."
        },
        {
          "question": "Can I speed up CashFusion by acting as multiple participants?",
          "answer": "Yes! EC has an option to 'fuse as 2 players' which contributes multiple sets of inputs/outputs to fusion rounds. Benefits: helps rounds fill up faster, increases your chance of participating in rounds, contributes to overall fusion liquidity. This is especially useful when participant count is low. The option is in CashFusion settings. Note: you need sufficient wallet balance to act as multiple players since each 'player' contributes different coin tiers. This feature is similar to contributing extra seeders in BitTorrent - helps everyone while also helping yourself get faster fusions."
        },
        {
          "question": "Why do some CashFusion transactions not get labeled in my history?",
          "answer": "This is a known long-standing bug that hasn't been thoroughly investigated yet. About 90% of fusions are labeled correctly, but occasionally some aren't. Possible causes: 1) App crash during fusion (labels added locally on restart don't reflect fusion metadata), 2) Timing issue in label assignment. The fusion info IS in the transaction data - theoretically could be regenerated on wallet load by analyzing tx structure (multiple inputs/outputs matching fusion pattern). Feature request: auto-mark fusion transactions with CF icon based on transaction analysis rather than relying on stored labels. For now, you can manually identify fusion txs by their characteristic structure (many inputs and outputs of similar values)."
        },
        {
          "question": "What is RPA (Reusable Payment Address) and how does it work in Electron Cash?",
          "answer": "RPA enables receiving payments privately without revealing a static address or requiring sender interaction. How it works: 1) Recipient provides RPA (derived from wallet's public key), 2) Sender uses RPA to derive unique payment destination that only recipient can find, 3) Recipient scans blockchain for transactions to their RPA-derived addresses. Current EC implementation: Requires separate wallet type (not integrated into standard HD wallets yet), doesn't use change addresses (sends change back to same address like Cashonize), derives only a few keys from the seed. Limitations: Can't be used with hardware wallets (yet), not compatible with CashFusion (no change addresses). Future: Calin plans to integrate RPA as a feature of standard wallets rather than separate wallet type."
        },
        {
          "question": "What is the bandwidth cost of using RPA (Reusable Payment Addresses)?",
          "answer": "RPA requires constantly scanning every new block for potential payments. However, BCH's RPA implementation is optimized: instead of downloading full blocks (like BTC's stealth addresses), it only downloads transactions matching your prefix. With EC's prefix size, this is less than 1% of all transactions. Trade-off: As blockchain usage grows, download requirements grow proportionally (1% of 1GB blocks is still 10MB). Compare to traditional SPV with merkle proofs: download size stays constant regardless of block size. The scanning is a small price to pay for privacy in exchange scenarios, but it's why RPA wallets need to be running more frequently than standard wallets."
        },
        {
          "question": "What's the difference between Bloom filters and RPA for privacy?",
          "answer": "They serve different purposes: 1) Bloom filters: Privacy technique for querying blockchain without revealing exact addresses. You share hash patterns (with false positives for privacy) to nodes, which return matching transactions. Connect to thousands of nodes for privacy. 2) RPA (Stealth Addresses): Enables receiving payments without revealing a static address publicly. Sender derives unique destination that only you can find. These aren't directly comparable - bloom filters improve query privacy for standard HD wallets, while RPA provides completely different functionality (non-interactive private receiving). You don't need RPA for privacy if you use HD wallets with unique addresses per payment. RPA shines specifically when you can't interact with the sender to provide fresh addresses."
        },
        {
          "question": "What are the best use cases for RPA/stealth addresses?",
          "answer": "RPA excels in non-interactive payment scenarios: 1) Donations: Public QR code where anyone can send privately, 2) Subscription services: Customer saves one address, tops up anytime without requesting new addresses, 3) Software sales: Single paycode for all buyers - they paste txid to verify payment, 4) Recurring payments: No 'this address expires in 2 hours' warnings, 5) Account top-ups: Services assign one RPA per customer. NOT ideal for: Regular business transactions where buyer/seller interact (just use unique invoice addresses), exchanges (need to track deposits precisely), any scenario requiring sender identification. RPA simplifies backend (no address generation system needed) but adds blockchain scanning overhead."
        },
        {
          "question": "Does CashFusion work with wallets that contain CashTokens?",
          "answer": "Yes, but tokens are automatically excluded from fusion. How it works: 1) CashFusion scans wallet for eligible UTXOs, 2) Any UTXO containing tokens (fungible or NFT) is automatically skipped, 3) Only BCH-only UTXOs participate in fusion rounds, 4) Token UTXOs stay frozen during fusion process, 5) The satoshis locked with tokens also don't get fused. This is by design - tokens require special transaction handling and can't be mixed in standard fusion protocols. If you need to fuse BCH locked with tokens, first move tokens to a separate output, then the freed BCH becomes fusable. Your tokens remain safe on their original addresses."
        },
        {
          "question": "What corporate or business use cases benefit from stealth/RPA addresses?",
          "answer": "Primary corporate benefit: Financial privacy from competitors and public. Use cases: 1) Paying invoices privately - competitors can't see resource allocation, 2) Receiving payments without exposing revenue in real-time, 3) Quarterly reporting vs forced transparency - choose when to disclose financials, 4) Payroll privacy - employees' salaries not publicly visible, 5) Subscription billing - one stealth address per customer prevents cross-customer data leakage. Non-public companies especially benefit - they don't want general public or competitors analyzing their blockchain activity. Stealth addresses enable corporate BCH adoption while maintaining traditional financial privacy expectations businesses are accustomed to."
        },
        {
          "question": "Does CashFusion work on iOS Electron Cash?",
          "answer": "No, iOS EC does not implement CashFusion and there are no current plans to add it. Primary reason: iOS doesn't support apps running continuously in the background, which CashFusion requires. The UX would be poor since you'd need to keep the app open constantly for fusion rounds. Alternative: Stack Wallet on iOS supports CashFusion but also requires keeping the app open. For best fusion experience, use desktop EC running 24/7 on a computer while using mobile wallet for spending. You can run the same seed on both - desktop handles fusions while mobile handles transactions."
        },
        {
          "question": "Can I run CashFusion on desktop while using the same wallet on mobile?",
          "answer": "Yes, this works well. Setup: 1) Use same seed phrase on both desktop EC and mobile EC, 2) Enable CashFusion on desktop with Tor running, 3) Keep desktop running 24/7 (many users run BCH nodes on same machine anyway), 4) Use mobile for everyday transactions. The desktop will continuously fuse coins in background while mobile wallet reflects the fused balance. Both instances sync with same Fulcrum servers so balance stays consistent. This is a popular setup for iOS users since iOS EC lacks native fusion support."
        },
        {
          "question": "Why does my balance show incorrectly in some wallets after using CashFusion?",
          "answer": "This is typically a gap limit issue. CashFusion creates many outputs across different derivation paths. When you import the same seed into other wallets (Paytaca, Stack, etc.), they may have smaller gap limits (default 20) and stop scanning before finding all your fused UTXOs. EC handles this well because: 1) It tracks addresses used during fusion, 2) Has better gap limit management, 3) Was designed with fusion in mind. Selene wallet (no fusion support) also shows correct balance because it may scan more addresses. Fix: In other wallets, increase gap limit or use 'scan more addresses' feature. Sending all UTXOs back to yourself consolidates them into addresses the wallet expects to find."
        },
        {
          "question": "What is the privacy trade-off between fixed donation addresses vs RPA?",
          "answer": "Fixed address donations: Anyone can see total donations received, timing, amounts, and potentially donor identities (unless they used CashFusion). Your donation history becomes public. RPA donations: Each payment goes to unique derived address only you can find - public sees random-looking addresses, can't connect donations to you or track totals. Only you know donor amounts. Major limitation: Only EC desktop currently supports sending TO RPA addresses. Donors need compatible wallet. For maximum reach: Use fixed address (simple, all wallets support). For privacy: Use RPA (limited support, more complex). Middle ground: Fixed address + ask donors to use CashFusion first."
        },
        {
          "question": "Why does Android EC require a separate Tor app for CashFusion?",
          "answer": "Android EC doesn't bundle Tor internally like desktop version. Technical reasons: 1) Android app sandboxing makes embedding Tor complex, 2) Code size and maintenance overhead, 3) Different platform constraints. Setup: Install Orbot (official Tor app for Android) separately, configure EC to use it as proxy. The fusion protocol itself works fine on Android once Tor connection is established through external app. Alternative for iOS: iOS EC has no fusion at all (not just Tor issue) due to background process restrictions. For best fusion experience: Use desktop EC which bundles Tor seamlessly and runs 24/7 easily."
        },
        {
          "question": "How do I know when my coins have been fused in CashFusion?",
          "answer": "Check your transaction history - fusion transactions appear with CF label/icon. The Coins tab shows which UTXOs came directly from fusion transactions. EC provides 'only spend fused coins' option in settings to prevent accidentally spending unfused coins. On desktop, right-click the CF icon to open progress dialog showing current fusion status. Each completed fusion is a separate transaction visible in history. Important: Multiple fusion rounds increase privacy - first fusion breaks direct link, subsequent rounds add more anonymity layers. The number of fusion rounds can be configured in CF settings. More rounds = better privacy but more fees consumed."
        },
        {
          "question": "Which coins does CashFusion automatically exclude from fusing?",
          "answer": "CF excludes several UTXO types: 1) Coins on addresses with more than 3 UTXOs (anti-spam measure, though debated), 2) UTXOs containing CashTokens (tokens require special handling), 3) Coins on manually frozen addresses/UTXOs (except CF's temporary freezes during rounds), 4) Very small UTXOs below minimum fusion threshold. To exclude specific coins: use Freeze feature on addresses or individual UTXOs. To include excluded coins: unfreeze them or adjust settings. Note: You can't fuse single-input coins effectively - fusion requires multiple inputs from your wallet to obscure which outputs belong to which inputs. Single input = outputs can still be correlated."
        },
        {
          "question": "Why doesn't Tor Browser work for CashFusion on Android?",
          "answer": "Tor Browser on Android only routes browser traffic through Tor network - it doesn't provide system-wide proxy that other apps can use. CashFusion needs Tor SOCKS proxy accessible to EC app, not just browser routing. Correct setup: Install Orbot (official Tor app for Android) which runs as VPN/proxy service that any app can connect through. Some users report Orbot issues while Tor Browser app works, but technically for CashFusion you need the proxy functionality. EC Android specifically looks for SOCKS proxy on localhost port 9050 (Orbot default). Without proper Tor instance running, CF icon won't enable and fusion won't start."
        },
        {
          "question": "Does CashFusion actually work on Android EC?",
          "answer": "Yes, but requires correct setup: 1) Install Orbot (NOT just Tor Browser), 2) Start Orbot and wait for connection (look for onion icon in status bar), 3) Open EC with Tor active - CF icon should enable, 4) Press play button to start fusion, 5) Keep phone awake with EC open - mobile OS may kill background processes. Success indicators: Fusion transactions appear in history, balance changes as coins get fused. Common problems: Wrong Tor app (browser vs proxy), phone sleeping/killing app, insufficient balance for fusion rounds, changing settings incorrectly. Many users confirm it works - if issues persist, try desktop EC where it's more reliable and can run 24/7 easily."
        },
        {
          "question": "What is Calin's roadmap for RPA in Electron Cash?",
          "answer": "Current RPA implementation is proof-of-concept as separate wallet type with limitations (no change addresses, no fusion support, limited key derivation). Planned improvement: Make RPA a feature of standard HD wallets rather than separate wallet type. Benefits: 1) One wallet file handles both regular and RPA payments, 2) Change addresses work normally, 3) CashFusion compatible, 4) No need to run separate wallet instances, 5) Better UX for receiving private payments. Timeline: Calin wants to work on this but needs development time. JF offered to help implement if given architectural guidance. Goal is seamless integration where users can optionally use RPA features within their normal HD wallet workflow."
        },
        {
          "question": "Why doesn't EC automatically select the smallest viable UTXO for transactions?",
          "answer": "EC's coin selection algorithm considers privacy, not just minimizing UTXO usage. Problem with 'smallest viable': If EC always picks smallest UTXO that covers payment + fees, blockchain analysis can easily identify which output is change (the smaller one). Example: Pay 0.03 BCH using 0.08 BCH UTXO - obviously 0.05 BCH output is change. Better approach: Select UTXO where payment and change are similar sizes (closer to 2x payment amount), making it harder to distinguish outputs. Trade-off: Uses more of your 'good' (fused) UTXOs faster, requiring more frequent fusion. If you prefer conserving specific UTXOs, use manual coin selection (right-click in Coins tab). BIP69 output sorting also helps obscure payment vs change."
        },
        {
          "question": "What is BIP69 and how does it improve transaction privacy?",
          "answer": "BIP69 is deterministic transaction output ordering standard. How it works: Orders outputs lexicographically (by script/amount) rather than by meaning (payment first, change second). Privacy benefit: Just looking at transaction, you can't tell which output is payment vs change based on position alone. Example: Without BIP69, first output might always be payment. With BIP69, outputs sorted algorithmically - position means nothing. Limitation: If payment is 0.01 BCH and change is 99.99 BCH, size difference still reveals which is which. Best privacy: Combine BIP69 with coin selection that makes payment and change similar sizes. EC uses BIP69 by default. Note: Even with these measures, sophisticated chain analysis can still make educated guesses based on spending patterns."
        },
        {
          "question": "Why should I migrate to a new wallet after running CashFusion for extended periods?",
          "answer": "Several reasons: 1) Performance - EC becomes sluggish with thousands of addresses/transactions, 2) RAM usage grows unbounded (5-8GB for years of fusion), 3) GUI crashes on Addresses tab, 4) Security - using same seed for years means one compromise reveals all history (like encryption key rotation), 5) Transaction history becomes unwieldy. Migration process: Create new wallet with fresh seed, use CashFusion to gradually move funds from old wallet to new (breaks linkage better than single transfer). Challenge: Must backup new seed phrase securely. Recommendation: Migrate every 1-2 years or after ~30k addresses. Don't wait until wallet becomes unusable - migrate proactively."
        },
        {
          "question": "What is RPA's actual privacy benefit versus CashFusion?",
          "answer": "RPA and CashFusion solve different privacy problems and are complementary, not alternatives. RPA's specific benefit: Allows posting public receiving address without third parties monitoring your balance. Dustin's clarification: 'RPA allows you to post a receiving address in public without third parties being able to see what is sent to you, that's it, nothing more. It doesn't magically prevent any other knowledge leakage.' On-chain reality: RPA outputs look identical to any other P2PKH transaction - completely indistinguishable. Tom's elevator pitch: 'Instead of giving a new address to each sender, you give a code that allows the sender to generate a personal address to send to.' Limitations: Sender always knows where they sent, receiver always knows their addresses, can't combine RPA outputs without revealing they belong to same person (need CashFusion for that). Andy: 'You can't combine outputs from two RPA transactions before CF.' Use together: RPA for private receiving addresses, CashFusion for breaking on-chain linkage."
        },
        {
          "question": "Would an 'Electron Cash Private Edition' with enforced privacy settings be feasible?",
          "answer": "Proposal: EC variant with hardcoded privacy settings - Tor default, CashFusion for all sends, RPA for all receives. Intent: Compete with Monero by preventing users from accidentally compromising privacy. Technical challenges: 1) RPA and CashFusion don't currently work together in EC (implementation limitation, not protocol limitation), 2) Restricting to RPA-only addresses severely limits usability (can't pay merchants without RPA support), 3) RPA outputs are normal P2PKH - no special on-chain privacy beyond address reuse prevention. Jonas: 'Work to be done in EC regarding RPA, more basic than this Private Edition, and I don't think anyone is doing that work.' JF: EC roadmap includes RPA as feature of standard wallets rather than separate wallet type - this foundational work must happen first. Community debate: Some argue RPA provides Monero-level privacy, but fundamentally different - RPA just generates fresh address client-side instead of server-side, doesn't hide amounts or provide ring signatures."
        },
        {
          "question": "How are RPA addresses distinguishable from regular BCH addresses?",
          "answer": "Two levels of distinction: 1) Address format (off-chain): RPA uses 'paycode:...' prefix, regular BCH uses 'bitcoincash:...' - completely different encoding. This allows wallets to recognize when user wants RPA functionality. 2) On-chain transactions: Completely indistinguishable. Adaptive Blocksize Limit: 'RPA are indistinguishable from any normal bitcoin cash address on chain.' Jonas confirms: 'Outsiders can't see if a transaction output is to a RPA or not.' This is key privacy feature - third parties monitoring blockchain can't identify RPA payments. The paycode format contains public key material that sender uses with ECDH to derive unique one-time address. Receiver scans all transactions using their private key to detect payments. Result: Standard P2PKH output on chain, but receiver didn't have to communicate fresh address each time. Enormous anonymity set because looks identical to all other BCH transactions."
        },
        {
          "question": "Does CashFusion require HD (hierarchical deterministic) wallet structure?",
          "answer": "No, CashFusion doesn't rely on HD wallets as part of its design. JF clarifies: 'every wallet nowadays typically uses HD, but fusion doesn't rely on HD as part of its design, it would work in theory even with a wallet that uses a bunch of unrelated addresses.' HD wallets conveniently generate new addresses from single seed, which CashFusion uses for sending outputs to fresh addresses. But fundamentally, CashFusion just needs: 1) UTXOs to mix (inputs), 2) Addresses to receive mixed outputs, 3) These addresses can be from any source - imported, HD-derived, or arbitrary. This means CashFusion could theoretically work with imported address wallets, multi-sig arrangements, or any wallet structure. In practice, EC uses HD for convenience and CashFusion outputs go to next HD-derived change address, but protocol itself is address-source agnostic."
        }
      ]
    },
    {
      "name": "Security & Best Practices",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "How do I create a secure paper wallet with Electron Cash?",
          "answer": "EC can export individual private keys and QR codes from addresses (right-click address > Get private key). For maximum security: 1) Remove hard drive from laptop, 2) Boot from Linux LiveUSB (use UNetbootin to create it), 3) Download paper wallet generator from trusted source, 4) Generate and print wallet while offline, 5) Turn off computer - all traces vanish since nothing writes to disk. If you must use your normal system, disconnect internet before generating, then completely wipe ALL browser data (cache, history, local storage) afterward. Never generate wallets on smartphones. For the easiest approach, use EC directly: create new wallet from LiveUSB, print seed phrase and receive address QR code, test with small amount before committing larger funds."
        },
        {
          "question": "How do I create a bootable Linux USB for secure wallet generation?",
          "answer": "Use UNetbootin (https://unetbootin.github.io/), a legendary open-source tool that creates bootable USB drives automatically. It can download Linux ISOs for you or use ones you've downloaded. Best practice: download ISO directly from the official Linux distribution website (e.g., Ubuntu, Linux Mint) rather than third-party sources. Once created, you can boot from this USB to generate paper wallets in a secure, isolated environment where nothing is written to your hard drive."
        },
        {
          "question": "What seed phrase lengths are supported in Electron Cash?",
          "answer": "EC supports BIP39 seed phrases of 12, 15, 18, or 24 words on desktop. Mobile version only supports 12 words currently. BIP39 doesn't define anything longer than 24 words, and longer would be pointless since 24 words already provide 256 bits of entropy (more than sufficient security). You can also add an optional passphrase to any BIP39 seed, though this is not recommended because there's no checksum - if you mistype it or forget it, recovery becomes extremely difficult."
        },
        {
          "question": "What are the security risks with offline wallet generation that most people don't consider?",
          "answer": "Beyond hard drive isolation, consider: 1) BIOS/firmware malware can persist even without hard drive and steal keystrokes, 2) LiveCD images can auto-connect to unsecured WiFi, 3) Malicious USB sticks may contain firmware exploits that survive reformatting (processor managing NAND chip can be hacked), 4) Hardware keyloggers on keyboard ports. These are called 'Evil Maid Attacks'. Best practice: dedicate a machine to permanent offline duty, only use new USB sticks from trusted sources, and ideally disable/remove WiFi hardware physically."
        },
        {
          "question": "How do I verify my Electron Cash download is authentic?",
          "answer": "Always verify downloads using GPG signatures or at minimum, checksums. Download GPG public keys for developers (jonald2 and Calin) from https://github.com/Electron-Cash/keys-n-hashes/tree/master/pubkeys. Import these keys into your GPG keychain, then verify the signature file against your download. This confirms the binary wasn't tampered with. Even if downloading from electroncash.org directly, verification is recommended security practice."
        },
        {
          "question": "Why are self-signed SSL certificates risky for public Fulcrum servers?",
          "answer": "Self-signed certs enable Man-in-the-Middle (MITM) attacks on public WiFi or unsecured networks. Users cannot easily verify if a certificate is legitimate (just a long number), making forgery trivial. While self-signed certs can be secure if you pin the specific certificate, typical users don't verify this. Web browsers treat them as untrusted for this reason. For public Fulcrum servers, use Let's Encrypt or other CA-signed certificates. Self-signed is only appropriate for private servers where you control both ends and can verify the certificate fingerprint."
        },
        {
          "question": "How do I tell if my wallet file is encrypted?",
          "answer": "Open the wallet file in a text editor. If it shows as one very long single line (like an address), the file is encrypted with your wallet password. Unencrypted wallet files show structured JSON data with readable keys like 'addresses', 'labels', 'transactions'. Note: Encrypted wallet files can be very large and may crash regular text editors - use an editor like Notepad++ that handles large files well. You can decrypt the file by loading it in EC and removing the password temporarily to inspect the contents."
        },
        {
          "question": "What are the security implications of running an unencrypted wallet for continuous fusion?",
          "answer": "Anyone with physical or remote access to your device can copy the wallet file and drain your funds. The security trade-off is identical to 'saving the password' - you're effectively storing the decryption key alongside the encrypted content. Mitigations: 1) Use a dedicated device (like Raspberry Pi) only for fusion, 2) Ensure strong OS-level security (disk encryption, limited user access), 3) Keep only modest amounts in the fusion wallet, 4) Place device in physically secure location. Running 24/7 is optimal for CashFusion liquidity, similar to BitTorrent seeding."
        },
        {
          "question": "Does Electron Cash support BIP38 encrypted paper wallets?",
          "answer": "Yes, EC supports BIP38 encrypted private keys. To sweep: 1) Go to Wallet > Private keys > Sweep, 2) Enter the BIP38 encrypted private key (starts with '6P'), 3) EC will prompt for the password to decrypt it. BIP38 adds a password layer to private keys for secure paper wallet storage. If you created a BIP38 paper wallet, you'll need both the encrypted private key and the password you set during creation. Desktop EC fully supports this feature."
        },
        {
          "question": "What is the difference between BIP38 and CashStamps for paper wallets?",
          "answer": "BIP38 encrypts the private key (WIF) with a password - you need both the encrypted key and password to sweep. EC supports BIP38 sweep (it prompts for password). CashStamps uses a simpler approach: it just presents the plain WIF for sweeping without encryption. This 'dumb' approach was deliberately chosen to make it easier for wallets to support. Few wallets besides EC support BIP38 encrypted keys. Both methods work for paper wallets, but BIP38 provides an extra security layer if the paper is physically compromised."
        },
        {
          "question": "How long is a Double Spend Proof (DSP) relevant for detecting fraud?",
          "answer": "A DSP is only relevant in the first 3-5 seconds after a transaction is broadcast. After that time window, the transaction has propagated across the network and miners have it in their mempools, making double-spend attempts extremely difficult. This is why BCH's 0-conf is considered safe for retail point-of-sale transactions. EC's DSP plugin (PR #2331) monitors for these proofs in real-time, but for historical transaction views, DSP information isn't particularly meaningful since the attack window has long passed."
        },
        {
          "question": "Should I use Windows for storing cryptocurrency?",
          "answer": "Security experts in the BCH community strongly recommend against using Windows for significant crypto holdings. Windows has more attack surface, telemetry, update issues, and security vulnerabilities. Linux provides better security through: open source verification, minimal bloat, better update model, stronger permission system. If you must use Windows: keep minimal funds in hot wallet, use hardware wallet, keep system fully updated, use dedicated machine. Consider Linux via dual-boot or Live USB for crypto operations. As community member says: 'don't expect your money to stay safe on Windows for long'."
        },
        {
          "question": "Does Electron Cash desktop already support offline transaction signing like Electrum?",
          "answer": "Yes, EC desktop fully supports offline transaction signing identical to Electrum. The workflow: 1) Create watch-only wallet on online computer using xpub, 2) Build unsigned transaction, 3) Save transaction (QR code or file), 4) Transfer to offline computer with full wallet (contains private keys), 5) Sign transaction offline, 6) Transfer signed transaction back to online computer, 7) Broadcast. You can manually select specific inputs by right-clicking coins in the Coins tab. This feature has existed in EC desktop 'forever'. The main gap is Android EC cannot save unsigned transactions to files (though it can sign transactions received as QR codes or raw text)."
        },
        {
          "question": "How do I back up an RPA wallet in Electron Cash?",
          "answer": "RPA wallets use seed words and are backed up the same way as standard HD wallets. Despite EC's RPA wallet having some limitations (no change addresses, limited key derivation), it still uses a BIP39-style seed phrase for recovery. When creating an RPA wallet, you'll receive 12/24 word seed phrase - write it down securely. Important: Using the same seed for both a hardware wallet and RPA wallet creates privacy linkage between them (same pubkey exposed). Ideally RPA should use a separate derivation path to avoid this correlation, which may be addressed in future EC versions. For now, use dedicated seed for RPA wallet if privacy is critical."
        },
        {
          "question": "Why does my antivirus block Electron Cash as malware?",
          "answer": "This is a common false positive with crypto wallet software. Antivirus programs (Avast, Norton, etc.) flag legitimate crypto apps because: 1) Stealth mining trojans use similar open source code, 2) Wallet-stealing malware triggers pattern matches, 3) Crypto operations look suspicious to heuristic scanners. EC is safe if downloaded from official source (electroncash.org). Verification steps: 1) Download ONLY from electroncash.org, 2) Verify GPG signatures or SHA256 checksums against published values, 3) Add exception in antivirus for the program, 4) Consider using Linux to avoid such issues entirely. Never download EC from random links in DMs or unofficial sources."
        },
        {
          "question": "What are Double Spend Proofs (DSP) and how does EC use them?",
          "answer": "DSProofs are cryptographic evidence that someone attempted to double-spend a transaction. How they work: When conflicting transactions (spending same UTXO) appear on network, nodes can construct proof using signatures from both. Fulcrum queries nodes for DSPs and provides them to wallets on request. EC can display DSP alerts for incoming transactions. Current status: Implementation exists but adoption is limited - most merchants don't see fraud because it's rare with first-seen rule. Practical value: Improves 0-conf reliability by detecting attacks in near real-time. Services like SideShift use DSPs. Not perfect security (probabilistic system), but adds valuable safety layer for unconfirmed transactions."
        },
        {
          "question": "Why might hardware wallets be riskier than software wallets?",
          "answer": "Supply chain attack risks: 1) Wallets intercepted and modified during shipping, 2) Retail distribution tampering (resealed devices with compromised firmware), 3) Trust in manufacturer's security practices, 4) Physical device can be counterfeited. Real cases: $6.9M stolen from pre-compromised hardware wallets sold on TikTok - seeds were known to attackers before buyers received devices. Additional concerns: Proprietary closed-source firmware in many devices, limited ability to verify hardware hasn't been modified. Alternative: Software wallets on airgapped devices you control (old laptop running Linux offline), or EC's offline signing workflow with your own hardware. Key principle: You're trusting multiple parties in hardware wallet supply chain vs. verifiable open-source software."
        },
        {
          "question": "How does zero-conf security work with first-seen rule?",
          "answer": "First-seen rule: Full nodes accept first valid transaction spending a UTXO and reject subsequent attempts. Network propagation ensures most nodes have same 'first' transaction. Why it's secure: 1) Miners generally follow first-seen (they receive transactions from honest nodes), 2) DSProofs alert recipients if double-spend attempted, 3) Merchants running nodes can verify their transaction propagated widely. Important insight: Security improves with adoption - more merchants running nodes means more enforcement of first-seen rule. Volunteers and merchants have strong incentive to maintain rule. Not perfect (probabilistic system), but practical security is high for typical retail transactions. Critical: Works only for standard transactions - anyone-can-spend scripts or complex DeFi operations may not be eligible."
        },
        {
          "question": "What's the difference between dumb NFC cards and smart cards for crypto storage?",
          "answer": "Two very different security models: 1) Dumb NFC cards: Just hold data (your seed phrase). No code, can't sign transactions, simply store information. The wallet software reads the seed phrase to derive keys. 2) Smart cards (Tangem, etc.): Have embedded firmware that signs transactions. Keys never leave the card - you tap the card to authorize each transaction. Important distinction: Dumb cards require wallet software to handle signing (keys in memory briefly), while smart cards do signing on-device but require trusting embedded firmware. Neither eliminates need for trusted software somewhere - it just moves the trust boundary. Some prefer dumb cards because less attack surface (no executable code on card)."
        },
        {
          "question": "Why do some experts recommend de-googled phones over hardware wallets?",
          "answer": "Several advantages: 1) Full control - you install the OS (LineageOS, GrapheneOS), apps are open source and auditable, 2) No supply chain risk - you buy generic phone from anywhere, 3) Familiar platform - standard Android apps work including EC, 4) Lower cost than dedicated hardware wallets, 5) Can run in airplane mode as airgapped device. Downsides: Larger attack surface than purpose-built device, requires technical knowledge to set up properly. Key insight: Hardware wallets have hidden complexities (firmware updates, driver requirements, manufacturer trust), while phones are well-understood attack surfaces. Best practice: Old de-googled phone running only EC, permanently offline for cold storage."
        },
        {
          "question": "Why are hardware wallet firmware updates a security concern?",
          "answer": "Several issues: 1) Continuous updates required - defeats purpose of 'cold' storage (must go online to update), 2) Each update is potential attack vector - one malicious update could steal funds, 3) Closed-source firmware common - you can't verify what code is running, 4) Driver updates also needed - more moving parts with trust requirements. Community perspective: 'If I have to continuously update firmware, it's not really cold storage anymore.' Alternative approach: Software wallet on device you control, with verifiable open-source code. Paper or steel backups are truly cold (no code to update). BTC-only firmware helps but still requires updates. Complex multi-coin firmware is highest risk due to large attack surface."
        },
        {
          "question": "Why is open source vs closed source more important than hardware vs software for security?",
          "answer": "Expert perspective from long-time engineers: Open source allows verification - you can read code, audit for backdoors, understand exactly what happens. Closed source requires trust in unknown parties. Hardware wallet problem: Even if open source, hardware is hard to verify (is this the actual firmware? was it modified in shipping?). Software on general-purpose hardware: Easier to verify - you can hash binaries, compile from source, audit changes. Trezor issues: Not hardware itself, but software complexity from supporting many altcoins. Large codebase = more bugs, harder to audit, more attack surface. Recommendation: Simple open-source software (EC) on hardware you control (de-googled phone, airgapped laptop) often provides better security model than complex proprietary hardware wallet."
        },
        {
          "question": "What specific incident caused people to lose trust in Ledger hardware wallets?",
          "answer": "Ledger released firmware update that added 'Recover' feature - ability to backup private keys to cloud. This fundamentally violated core hardware wallet promise: 'keys never leave device.' Community outrage: 1) Feature contradicts entire security model users bought into, 2) If firmware CAN export keys, malicious update could steal them, 3) Closed-source firmware means users can't verify code, 4) Trust in 'cold storage' destroyed when device can go online. Lesson: Hardware wallet security depends on trusting company not to break promises via firmware updates. This is why many BCH developers now recommend: open-source software wallets on offline devices you control (GrapheneOS phone, de-googled Android, airgapped laptop)."
        },
        {
          "question": "What are the human factors in choosing between hardware wallets and offline computers?",
          "answer": "Security isn't purely technical - operational security matters: 1) Hardware wallets: Simpler UX but trusting manufacturer, supply chain, and firmware updates. Risk: Company betrayal, supply chain tampering, update vulnerabilities. 2) Offline computers: More control but requires technical knowledge to set up properly (OS installation, security hardening, air-gap discipline). Risk: User error breaking security. Key insight: No perfect solution exists. Hardware wallets have corporate trust issues; offline computers have human error issues. Best choice depends on your technical ability and threat model. Both can lose funds - hardware through company malfeasance, offline through user mistakes. Complexity itself is security enemy regardless of approach."
        },
        {
          "question": "Why is Windows particularly dangerous for cryptocurrency wallets?",
          "answer": "Multiple serious concerns: 1) Windows 11 Recall feature takes periodic screenshots of everything on screen - could capture seed phrases when wallet displays them, 2) Even if disabled, feature can be re-enabled via updates without user consent, 3) Telemetry sends data to Microsoft servers, 4) Closed-source OS means you can't verify what's running, 5) Historically most-targeted OS for malware. EC has no special protection against screenshot capture. Alternative: Use Linux (open source, verifiable) or at minimum macOS. For crypto security: Keep bulk of funds on dedicated device (old phone, offline laptop) not your daily Windows machine. Community consensus: 'Don't use Windows' is foundational crypto security advice."
        },
        {
          "question": "How should I structure cold storage vs hot wallet for everyday use?",
          "answer": "Recommended setup: 1) Hot wallet on phone: Small amount for daily spending (week/month worth), 2) Cold storage: Bulk of funds on separate device kept physically safe at home. Important: 'Physically safe' doesn't require complex airgapped setup. Simple approach: Old phone or laptop kept at home (sock drawer, under bed) - key is it doesn't leave house where it could be stolen. Don't overthink security - avoid Windows, use strong password, keep seed phrase backed up separately. Splitting funds this way limits loss if phone is stolen or compromised. Cold device can be online occasionally for syncing - true airgap is unnecessary complexity for most users."
        },
        {
          "question": "Why would you want to rotate wallet seeds periodically?",
          "answer": "Security principle borrowed from encryption key rotation: Using same secret for years means one compromise reveals entire history. If seed is ever exposed (even years later), attacker sees all past transactions. Recommendation: Every year or two, create new wallet with fresh seed, migrate funds. Benefits: 1) Limits damage from future seed exposure, 2) Fresh derivation paths, 3) Clears accumulated transaction history (performance), 4) Can abandon old addresses. Migration challenge: Moving all funds in single transaction creates obvious on-chain link. Better: Use CashFusion to gradually move funds from old wallet to new, breaking linkage. This is why sub-wallet features being discussed - merge old seed into new wallet for fusion migration."
        },
        {
          "question": "Why do some community members prefer seed phrase backups over hardware wallets?",
          "answer": "Plausible deniability argument: Hardware wallets are physical objects that reveal you own cryptocurrency. If police/authorities/thieves find your Ledger/Trezor, they know you have crypto - even if they can't access it, they can seize it or use '$5 wrench attack' (physical coercion). Alternative: Seed phrase carved/written in hidden location (under floorboard, in wall, encrypted on USB). Benefits: 1) Nobody knows you own crypto unless they find the hidden backup, 2) Recovery requires only Linux LiveCD + EC, 3) No firmware updates to trust, 4) No supply chain attack risk. Encoding options: Convert 12 words to hex/binary before writing, encrypt with additional password. Trade-off: Requires more technical knowledge and secure storage location."
        },
        {
          "question": "What are secure ways to backup seed phrases without hardware wallets?",
          "answer": "Multiple approaches discussed by community: 1) Titanium/steel plate engraved with words (fire/water resistant), cement in wall, 2) KeePass encrypted database with strong password, distribute file copies to multiple locations (USB drives, trusted cloud storage in password-protected zip), 3) Paper/DVD with words encrypted using additional passphrase, 4) Convert words to binary/hex/decimal before physical storage for extra obfuscation, 5) Multiple geographic locations for redundancy (if house burns, have backup elsewhere). Key insight: Threat model matters - protect against fire/flood (multiple copies), theft (encryption/hiding), government seizure (plausible deniability). No single solution fits all - evaluate your specific risks."
        },
        {
          "question": "Can open source hardware wallet chips still have backdoors?",
          "answer": "Yes, significant concern even with 'open source' hardware: 1) You can't manufacture chips yourself - must buy from supplier, 2) Even if design is open source, how do you verify YOUR specific chip follows that design?, 3) Government can order manufacturer to add backdoors under NDA (you'll never know), 4) Secure element chips with tamper-resistance are black boxes by design. JF's insight: 'if you're relying on hardware, for all intents and purposes you are trusting the device.' Mitigation: Use generic hardware (old phone, laptop) running verified open source software - easier to audit software than hardware. Trust moves from chip manufacturer to software developers whose code you can inspect."
        },
        {
          "question": "How do I verify I downloaded legitimate Electron Cash and not malware?",
          "answer": "Critical security step: 1) Download ONLY from electroncash.org, 2) Verify GPG signatures or SHA256 checksums against published values on website, 3) Don't trust unofficial sources, app stores, or DMs sharing download links. Red flags that indicate malware: suspicious binary strings in GUI, app requesting unusual permissions, unexpected network connections, different file hash than official. Real example from chat: User showed EC with suspicious binary appearing in interface - community immediately identified as malware, advised to delete immediately and redownload from official source. Never type seed phrase into compromised software - malware steals seeds instantly. When in doubt, verify signatures or ask in official channels before using."
        },
        {
          "question": "Why is code complexity the enemy of security in cryptocurrency wallets?",
          "answer": "Expert insight from community: Every line of code is potential attack surface. Problems compound with: 1) GitHub repositories grow massive - who reviews all code plus dependencies?, 2) Compilers and build tools themselves could be compromised (compilation trust chain), 3) Multi-coin support in hardware wallets exploded firmware complexity, 4) More features = more bugs, harder audits, larger attack surface. Recommendation: Prefer simpler wallets focused on fewer chains (BCH-only firmware on Trezor safer than multi-coin). EC benefits from being specialized for BCH rather than supporting every cryptocurrency. Complexity enables monetization (supporting shitcoins makes money) but undermines security. Simple tools with focused functionality are easier to verify and trust."
        },
        {
          "question": "What permissions does EC request on macOS and are they suspicious?",
          "answer": "EC may request several permissions: 1) Screen Recording/Accessibility - for scanning QR codes on desktop screen, 2) Camera access - for scanning QR codes via webcam, 3) Audio (sometimes bundled with camera) - likely inherited from Qt framework's multimedia module. These are legitimate features, not malware indicators. However, be cautious: If EC shows strange binary strings in GUI, unusual behavior, or requests unexpected permissions, it may indicate compromised binary. Safety steps: 1) Download only from electroncash.org, 2) Verify GPG signatures, 3) Grant minimum permissions needed, 4) Deny permissions you don't need (can always grant later), 5) If suspicious, delete and redownload verified version. macOS Gatekeeper warnings are normal for non-App Store apps."
        },
        {
          "question": "Is Electron Cash affected by npm supply chain attacks or infected JavaScript dependencies?",
          "answer": "No, EC is completely unaffected by npm/JavaScript vulnerabilities because it's written in Python, not JavaScript. Recent attacks targeting crypto wallets through infected npm packages (which replace deposit addresses with attacker addresses) only affect web apps and JavaScript-based wallets. EC's security measures: 1) External Python packages are audited daily via automated GitHub Actions, 2) During builds, developers check GPG signatures of dependencies, 3) No JS code means no npm dependency chain. Jonas: 'No js code in EC. External packages used are audited daily.' Additionally, Python ecosystem typically has fewer external dependencies than JavaScript projects, reducing supply chain attack surface. This is one advantage of EC using native Python over Electron/JavaScript frameworks (despite the confusing name, Electron Cash is not built with Electron.js)."
        },
        {
          "question": "Why is the number of dependencies more important than programming language for wallet security?",
          "answer": "Programming language alone doesn't determine security - the cumulative number of external dependencies is more indicative of supply chain risk. Example: Flowee Pay uses Java (Android integration), JavaScript (UI), and C++ (core logic) - multiple languages but controlled dependencies. Contrast with typical JavaScript apps that pull hundreds of npm packages. Python (EC's language) has same 'fetch dependencies before build' model as JavaScript, but Python projects typically have substantially fewer dependencies. More dependencies = more attack surface, more code to audit, more potential for malicious insertions. EC benefits from: focused functionality (BCH-only), mature Python ecosystem with better package vetting, and manual signature verification during builds. The recent npm supply chain attack affected wallets not because of JavaScript per se, but because those wallets pulled in compromised packages deep in their dependency tree."
        },
        {
          "question": "How do GitHub phishing attacks target cryptocurrency developers?",
          "answer": "Sophisticated phishing campaign observed in September 2025: Emails appear to come from legitimate github.com mail servers (pass SPF/DKIM) but contain links to phishing domains. Attack vector: Attacker creates GitHub issue mentioning @username, GitHub sends notification email, link in email points to malicious site. Targets: Specifically cryptocurrency developers who maintain wallet/blockchain repositories. Protection: 1) U2F/FIDO2 security keys - won't authenticate to wrong domain, 2) Password manager autofill - only fills credentials for correct domain, 3) Never click links in emails - navigate directly to github.com, 4) Check domain carefully before entering credentials. GitHub removes malicious repos quickly but notification emails persist. EchterAgo: 'good reason to have a U2F key registered and only use your password managers autofill, both will prevent phishing domains.' This is targeted attack on crypto ecosystem's most valuable assets - developer credentials."
        },
        {
          "question": "What is SLIP-39 and why would it be useful in Electron Cash?",
          "answer": "SLIP-39 is Shamir's Secret Sharing for seed phrase backup - splits seed into multiple shares where only threshold number required for recovery. JF suggested as potential future EC feature. Benefits: 1) Distribute backup across locations (give shares to trusted family members), 2) Losing one share doesn't compromise funds (unlike single seed phrase), 3) No single point of failure, 4) Can require N-of-M for recovery (e.g., 3-of-5 shares needed). Example: Create 5 shares, give to 5 family members, need any 3 to recover. If one is lost/compromised, still secure. Current EC uses standard BIP-39 mnemonic (12/24 words) - single point of failure. SLIP-39 would provide more robust backup scheme. Already supported in Trezor hardware wallets. Implementation challenge: Additional complexity in wallet setup/recovery flow, compatibility with existing backup methods."
        },
        {
          "question": "Why are EC AppImage builds not reproducible and what causes this?",
          "answer": "Reproducible builds mean building same source code produces bit-for-bit identical binary, allowing verification. Current issue: protobuf package breaks reproducibility. When protobuf was bumped from 3.x to 5.x, new UPD (Universal Proto Deserializer) backend compiles at build time, embedding build paths into .so files. Different build directories = different hashes. Jonas: 'The package that causes a diff... *drumroll*... protobuf! When bumping from 3.x to 5.x there is a new backend (UPD) that is compiled at build time. It seems like some build paths ends up in the compiled .so file.' Concerning because: Users can't independently verify released binaries match source code - must trust developers. Solutions: Pin protobuf to older version (loses features), fix build paths in protobuf compilation, or accept non-reproducibility (undesirable). Tom notes: 'The main way to avoid issues with it is to stop using their generated code and their library... Their protocol is stable, it's the software that's been a disaster for a decade.'"
        },
        {
          "question": "How do you keep swap encrypted on Linux for security?",
          "answer": "Simple approach: Put swapfile on encrypted partition. Shadow: 'If you put your (not very used) swapfile on an encrypted partition, it becomes encrypted.' If using full disk encryption (FDE) with LUKS, all partitions including where swapfile resides are encrypted. Benefits: 1) Sensitive data paged to swap remains encrypted at rest, 2) No separate encryption key management, 3) Cold boot attacks less effective. Josh notes: 'better imo since I have fde and would like to keep swap encrypted as well.' Alternative: Dedicated encrypted swap partition, but more setup complexity. Shadow's setup: 'everything encrypted, RAM encrypted, Kernel structure randomized, no problems reported. Uptime in months.' For crypto wallet users: Critical because seed phrases or private keys in memory could theoretically be swapped to disk. With encrypted swap, even if attacker accesses disk, can't read swap contents. Combined with ZSWAP: Data compressed in RAM first, only overflow goes to encrypted disk swap - maximum security with performance."
        },
        {
          "question": "Why are reproducible builds important and what makes EC's builds reproducible?",
          "answer": "Reproducible builds allow anyone to verify that distributed binary matches source code - minimizes trust in maintainers. JF: 'i really appreciate this aspect of our build process and minimizing the trust placed on the maintainers.' How EC achieves this: 1) Exact dependency versions pinned in contrib/deterministic-build/requirements.txt, 2) Build happens in Docker container with controlled environment, 3) Build paths normalized to deterministic strings, 4) All source code auditable. Recent challenge: protobuf 5.x embeds random build paths requiring special handling. Jonas' fix (PR #3120) replaces randomized paths with deterministic strings. Process: Multiple developers build same release, compare SHA256 hashes - if identical, proves no tampering. Chris Troutner's ARM64 build NOT reproducible: Ubuntu packages not version-pinned, would produce different hashes. This is why official releases require maintainer commitment to reproducibility standards."
        },
        {
          "question": "Is there a CVE affecting EC's protobuf version and does it matter?",
          "answer": "Yes, CVE exists but likely not applicable. Jonas identifies: 'There is a CVE for the version of protobuf that we are using: github.com/advisories/GHSA-8qvm-5x2c-j2w7. But it shouldn't be applicable since we are supposedly using the compiled upd backend.' Context: Protobuf 5.x has vulnerability but EC compiles with UPD (Universal Proto Deserializer) backend that mitigates the issue. Additional security: 1) EC packages are audited daily via automated GitHub Actions, 2) Developers verify GPG signatures during builds, 3) Protobuf only used for specific features (CashFusion, BIP-70, CashShuffle), 4) Not exposed to arbitrary external input in most cases. Best practice: Keep EC updated to latest version which includes security patches. Don't use ancient EC versions. If concerned, run from source where you can review all dependencies. CVE is tracked but assessed as low risk due to compilation method. Security-conscious users should verify with official EC channels for current assessment."
        },
        {
          "question": "What are the security concerns with unknown developers submitting EC to F-Droid?",
          "answer": "Major supply chain risk. Unknown developer submitted fastlane PR (#3137) and F-Droid build without prior engagement with EC team. Calin: 'So weird.. out of nowhere some dude using Arabic script for a name does some stuff.' Mathieu G warns: 'i think there's a pretty large chance the person will try to scam people and steal their funds if they are not known.' Concerns: 1) Developer could modify source before F-Droid build, 2) GitHub Actions vulnerabilities could enable unauthorized publishing, 3) F-Droid builds aren't reproducible so can't verify binary matches source, 4) Unknown developer controls namespace. emergent_reasons strongly advises: 'If something gets posted with electron cash name by someone other than electron team, it must be called out loudly and everywhere as a likely scam.' JF acknowledges: 'its kind of weird that out of the blue someone no one knows just decided to make a build for f-droid.' Even well-intentioned contributors need vetting when handling wallet software accessing user funds."
        },
        {
          "question": "How does F-Droid building/signing differ from Google Play Store?",
          "answer": "Both platforms re-sign apps, but with different trust models. Tom explains: 'fdroid just uses the plain repo's and builds it 100% on their own system and signs it... Notice that Play Store releases are signed by Google, NOT Jonald. He signs just to allow uploading to Google's servers, they re-sign it to publish.' Key differences: Play Store: Developer signs to upload, Google re-signs for distribution. F-Droid: Builds directly from source on their servers, signs with F-Droid key. Jonas notes: 'The Play Store releases are at least signed by Jonald, but here it seems like it's built by a f-droid backend.' Tom's recommendation: 'it would be smart to use a different ID for both, so they can be installed at the same time as distinctly different apps' - prevents compatibility errors from different signatures. Security implication: Neither platform provides reproducible builds by default, both require trusting the distribution platform. F-Droid advantage is build from source (auditable), disadvantage is no developer signature verification."
        },
        {
          "question": "What GitHub Actions security risks should open source projects watch for?",
          "answer": "PRs adding GitHub Actions can introduce supply chain vulnerabilities.  warns: 'there are some github actions vulnerabilities where they get ability to publish if you don't restrict access to publishing scope only to some workflows.' Specific concerns with suspicious PR: Added new workflow files, uses external actions from unknown sources, could potentially gain write access to repo. Jonas explains: 'If you open a pull request it is executed on the source repo' - PR code runs with elevated privileges. Best practices: 1) Be vigilant on GHA especially 'pull_request_target' trigger (has write access), 2) Review all workflow additions carefully, 3) Restrict publishing scope to specific workflows, 4) Don't blindly trust 'copied from Electrum' claims. Calin's response: 'Idk I feel like closing this esp since it has unneeded GitHub actions.' Jonas: 'I don't see the issue with this GHA' but acknowledges: 'it's good to vigilante on GHA.' Even legitimate automation tools (fastlane) need scrutiny when added by unknown contributors."
        },
        {
          "question": "How does F-Droid's trust model actually work for app distribution?",
          "answer": "F-Droid only trusts git repositories, not individual submitters. Tom clarifies widespread misconception: 'the f-droid project specifically does not trust any person, it only trusts a git url. It never gets the data from a person, it gets the data from one or more git repositories you publish.' Key implications: 1) Unknown person submitting PR is irrelevant - F-Droid builds from EC's official GitHub, 2) All metadata (screenshots, descriptions) must live in EC's repo under their control, 3) EC maintainers approve all changes through normal merge requests. Tom: 'the ONLY thing you need to check is if the fdroid stuff links to the trusted git repos... No trust is needed because fdroid is designed to only pull from your git repos.' Damascene confirms: 'The person who submit has no power over it. F-droid will verify and handle it so it auto build from your git.' This design provides transparency - code is auditable, build process is known. Remaining trust required: F-Droid's build infrastructure itself, hence importance of reproducible Android builds to verify their output matches source."
        },
        {
          "question": "Why did Google Play Store change to AAB uploads and how does it affect trust?",
          "answer": "Google now re-signs all apps, reducing developer control. Tom explains: 'It was just a couple of years ago when they switched over from apk uploads to aab uploads, which are multi-arch capable.' Key change: Developer signs AAB to upload, Google re-signs with their key for distribution. Rationale: 1) Multi-architecture support (single upload serves different devices), 2) Smaller downloads (device gets only needed code), 3) Key management - 'owner could change signing keys in the play store webapp without hurting actual installs. For instance when a company fired members that they were afraid would have a copy of the signing keys.' Security implications: Users trust Google's signature, not developer's directly. This mirrors F-Droid model where platform controls final signing. Both approaches require trusting distribution infrastructure. For cryptocurrency wallets: Neither Play Store nor F-Droid provide end-to-end verification that binary matches source. Reproducible builds solve this - allowing users to verify any build matches auditable source code. Currently EC doesn't have reproducible Android builds, making this trust necessary."
        },
        {
          "question": "Does F-Droid require reproducible builds for app inclusion?",
          "answer": "Unclear but highly encouraged. Kallisti states: 'Fdroid requires reproducible builds afaik.' Jonas seeks clarification: 'Do you know if there is any verification of it done by f-droid before it's published?' Kallisti: 'They have some kind of review process I think.' Reality: F-Droid encourages reproducible builds but doesn't strictly require them. They do mandate building from source on their infrastructure. Verification approach: Shadow mentions: 'I read somewhere that F-Droid has some automation tools that verify the binary was indeed built from the provided source.' Jonas suggests workaround: 'The apk wont be reproducible, but there are scripts that will strip signatures and compare the files.' Trust implications: Without reproducibility, users trust F-Droid build infrastructure. With reproducibility, users can independently verify. Signal messenger has done significant work on reproducible Android builds. Challenge for EC: Chaquopy (Python-on-Android framework) may introduce non-deterministic elements. Needs investigation. Best practice: Aim for reproducible builds even if not strictly required."
        },
        {
          "question": "Why would hashing arbitrary scriptSig pushes as P2SH addresses be dangerous?",
          "answer": "Could generate nonsense addresses that appear valid. Dustin's draft PR #3148 attempts: Hash last push as P2SH20 address. Calin identifies flaw: 'your current hack has the following properties: if the thing is actually a p2sh20, it will match p2sh20 perfectly... if the thing is anything but a p2sh20 (such as p2sh32, p2pk, p2pkh), it will incorrectly think it's p2sh20 and return a nonsense address.' Dustin's concern: 'My fear is if it's an unbroadcast transaction that is re-serialized and pays to somewhere else because the wrong address was returned during deserialization.' Calin confirms: 'yes. and you will thus get a nonsense p2sh address that doesn't correspond to what is useful to anybody.' Real danger: Software might use incorrect address for accounting, refunds, or transaction construction. Dustin accepts: 'Ok, good, my gut was right, it would be a terrible idea. Thank you for confirming.' Lesson: Better to return 'unknown' than wrong answer. Incorrect data worse than missing data for security-critical applications."
        },
        {
          "question": "Why does SLIP-39 lack full wallet support and what limitations exist?",
          "answer": "Specification incomplete and implementation partial. eloyesp asks: 'is there a reason it had not been added?' JF answers: 'The only real problem here is that Electrum only does partial implementation. You can restore a SLIP39 seed but you can't actually create a new wallet with one, if im remembering right.' Tom identifies deeper issues: 'But I think the slip itself is a nice but unfinished design. It lacking a derivation path, for example is interesting.' SLIP-39 defines seed splitting (Shamir's Secret Sharing), not wallet structure. Usage concern: eloyesp: 'My main doubt, is if it would make sense to use it, given the lack of support.' JF: 'its advanced and niche... so it would be low hanging fruit to do just do what electrum did.' Workaround: SeedCash hardware wallet supports SLIP-39 natively. Mart: 'You can create a SLIP-39 BCH wallet using SeedCash and then export the xpub to electron cash.' Hardware generates seed, EC uses watch-only wallet from xpub. Tom's vision: NFC tags storing shares for physical seed recovery."
        },
        {
          "question": "What is trustless wallet operation and why is it important?",
          "answer": "Wallet verifies everything locally, doesn't depend on server honesty. When user asks about trustless, Andy explains: 'That means the wallet doesn't require you to trust any servers.' Context: Standard EC connects to Fulcrum servers for blockchain data (balance, history, broadcast). Trusts servers to give correct information. Trustless operation: Run your own Fulcrum server connected to BCHN full node, wallet only trusts your infrastructure. Benefits: 1) Server can't lie about your balance, 2) Can't hide transactions, 3) Can't refuse to broadcast, 4) Maximum privacy (no third-party sees your queries). Trade-off: Requires running full node (disk space, bandwidth, technical knowledge). Most users trust public Fulcrum servers - generally honest due to reputation. High-value users or privacy-focused should consider own infrastructure. StartOS making this easier with packaged BCHN+Fulcrum. Goal: Make trustless operation accessible to non-technical users. EC itself is open source (code trustable), but server infrastructure typically third-party."
        },
        {
          "question": "Why is NFC storage of SLIP-39 shares an interesting application?",
          "answer": "Physical seed recovery without typing 20+ words. Tom's vision: 'Would like to add it to our NFC writer so you can have various NFC tags to restore a seed.' Use case: M-of-N threshold scheme where each share stored on NFC tag. Distribute tags to different locations/people. Recovery: Collect enough tags, tap each to reader, device reconstructs seed. Benefits: 1) No typing long word sequences (error-prone), 2) Physical security (tags can be hidden/secured), 3) Social recovery (give shares to family/friends), 4) Disaster recovery (geographically distributed). Challenges: NFC tag security (can be cloned if accessed), need secure reader (SeedCash device), lose M tags = lose funds. Tom's concern: 'I would love to see someone work out a user experience of storing and restoring the shards to an actual wallet. And improve the interoperable design from that.' SLIP-39 spec defines share encoding but not storage medium or recovery UX. This is frontier of BCH seed security - combining physical and cryptographic protection."
        },
        {
          "question": "What does trustless mean in cryptocurrency wallet context?",
          "answer": "Verifying information yourself rather than trusting third parties. Andy's explanation when asked: 'That means the wallet doesn't require you to trust any servers.' Levels of trust in EC: 1) SOFTWARE TRUST: EC open source, code auditable, reproducible builds - you can verify binary matches source. 2) SERVER TRUST: Most users connect to public Fulcrum servers - trust servers report correct blockchain data. 3) NETWORK TRUST: SPV (Simplified Payment Verification) trusts that longest chain is valid. Full trustless: Run BCHN full node (validates all rules), connect EC to your Fulcrum server (controls your data), verify transaction history yourself. Why matters: Servers could theoretically hide deposits, misreport balances, refuse broadcasts. Your own infrastructure can't lie to you. Most users accept server trust as reasonable (servers are public, reputational risk to lie), but high-value storage warrants own infrastructure. Progressive trust model: Start with public servers, graduate to own infrastructure as needs grow. This is core Bitcoin principle: Don't trust, verify."
        }
      ]
    },
    {
      "name": "Transactions & Fees",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "Can you reverse or cancel an unconfirmed BCH transaction?",
          "answer": "No, once broadcast transactions cannot be reversed by anyone. User asks: 'Can someone reverse or stop a transaction?? It hasn't confirmed yet.' Blockchain fundamentals: 1) Once transaction is broadcast to network, it propagates to all nodes, 2) No central authority can cancel it, 3) Recipient controls funds once transaction is valid, 4) Even unconfirmed transactions are typically irreversible. Exception: Double-spend attempt possible but unreliable (need to broadcast conflicting transaction quickly with higher fee, most merchants wait for confirmation). BCH specific: 10-minute block times mean short wait for confirmation, 0-conf transactions considered reliable for small amounts due to first-seen-safe miner policies. Prevention better than cure: Always triple-check recipient address before sending. User resolved issue: 'Never mind all sorted out' - likely realized address was correct. This is feature not bug: Censorship resistance means no reversals, but also means no one can stop legitimate transactions."
        },
        {
          "question": "How can you derive P2SH address from redeem script if you have it?",
          "answer": "Hash the redeem script and encode appropriately. Dustin: 'I can plug both redeem scripts into my little address generation script and get the right address for both of them, but at that point, I'm not using heuristics.' Calin confirms: 'yeah if you know for SURE it's a redeemScript as your last push.. then yeah hash it and voila! correct address.' Process: 1) Extract last push from scriptSig (this is redeem script in P2SH), 2) For P2SH20: HASH160(redeemScript)  20 bytes, 3) For P2SH32: SHA256(redeemScript)  32 bytes, 4) Encode with Cash Address format. Challenge: 'but the general purpose transaction parser has no way of knowing that for sure... unless... it can examine the locking script of previous txn.' Can't assume last push is always redeem script - could be P2PKH signature followed by pubkey, or other patterns. Dustin: 'I can derive the address from that script (though I was wrong about using bitcash, I used cryptos).' Python libraries like cryptos or EC's own Address class can handle encoding. Key insight: If you control the script and know it's P2SH, address derivation is trivial. General-purpose parsers can't make that assumption."
        }
      ]
    },
    {
      "name": "Wallets & User Experience",
      "description": "Technical Q&A from Electron Cash Telegram community discussions",
      "source": "Electron Cash",
      "faqs": [
        {
          "question": "How do I send the maximum amount from a specific coin in Electron Cash?",
          "answer": "After right-clicking a coin and selecting 'Send', click the 'Max' button on the Send tab. The amount field is intentionally left blank because you can multi-select coins and don't have to send the full amount. The Max button calculates the coin value minus fees automatically. Note: The Max button may be greyed out until you enter a destination address first."
        },
        {
          "question": "Can I create paper wallets with Electron Cash?",
          "answer": "Not easily with Electron Cash directly. For paper wallet generation, use dedicated tools: 1) Go to minisatoshi.cash/ecosystem and search for 'Paper Wallet', 2) Use paperwallet.fullstack.cash, or 3) For metal backup, check opensourcemetalwallet.com. These tools are specifically designed for secure paper wallet creation."
        },
        {
          "question": "Does the inter-wallet-transfer plugin respect frozen/locked addresses?",
          "answer": "Yes, the inter-wallet-transfer plugin respects frozen addresses. When you freeze an address or coin in Electron Cash, the plugin will not include those in the transfer operation. This is useful when you want to migrate most of a wallet but keep certain UTXOs or addresses in place (e.g., unfused coins you don't want to move). Always test on a small wallet first to verify this behavior."
        },
        {
          "question": "How do I verify funds arrived at my paper wallet address?",
          "answer": "Use any block explorer to check the address balance. Simply enter your public address (the one starting with bitcoincash:) into a block explorer website. If concerned about privacy, use a VPN or different internet connection than your normal one when checking, though for paper wallet balance checks this is usually not critical."
        },
        {
          "question": "How do I sweep/import a paper wallet back into Electron Cash?",
          "answer": "Electron Cash can import individual private keys from paper wallets. Go to Wallet menu > Private Keys > Sweep or Import. Enter the private key from your paper wallet. Note: Once you enter the private key on your computer, that secret is exposed to your possibly-infected system. For practice, always test with small amounts first: create paper wallet, send test amount, verify arrival, import/sweep it back to ensure the full cycle works before storing significant funds."
        },
        {
          "question": "Why does an address show as 'used' in the Addresses tab when I've never sent funds to it?",
          "answer": "When you copy an address from the Receive tab, Electron Cash assumes you requested a payment to that address. Since you shouldn't request multiple payments to the same address (for privacy), EC marks it as 'used' by that payment request. The Tx column in the Addresses tab shows actual transaction count - if it's 0, the address has no real transactions. To get addresses without marking them used, copy directly from the Addresses tab instead of the Receive tab."
        },
        {
          "question": "How do I restore my wallet on a new device?",
          "answer": "Wallet files don't automatically copy between devices. You have two options: 1) Restore wallet from seed phrase - create new wallet and select 'I already have a seed', enter your backup seed words, or 2) Send coins from old device to new device if you still have access. You can also manually copy wallet files from the old device's data directory (e.g., AppData/Roaming/Electroncash/wallets on Windows) to the new device."
        },
        {
          "question": "Does Electron Cash work with Electrum BTC wallet files?",
          "answer": "Electron Cash and Electrum use different wallet directories (e.g., Electroncash/wallets vs Electrum/wallets) so they won't interfere with each other's files. Wallet files aren't cross-compatible since they're for different blockchains. However, if you have a pre-fork BIP39 seed from before the BCH/BTC split, you can restore it in both wallets to access coins on both chains. Always keep backups of wallet files regardless."
        },
        {
          "question": "Where are Electron Cash wallet files stored and what do they contain?",
          "answer": "On Linux, wallet files are stored in `~/.electron-cash/wallets/`. Each wallet is a single file containing: addresses, transactions, labels/descriptions for transactions and addresses, and private keys (if not a watch-only wallet). If the wallet is password-protected, the file is encrypted and appears as a single long line when opened in a text editor. All your custom transaction descriptions ('labels') are stored in this file, so backing up the wallet file preserves everything. The file name is the wallet name you chose during creation."
        },
        {
          "question": "How do I transfer partially signed transactions between multisig cosigners?",
          "answer": "Several methods: 1) Cosigner Pool - built-in feature that passes transactions through server (enable in Optional Features), 2) QR codes - display QR of partial transaction for other party to scan (may be too large for complex transactions), 3) Raw hex - use Ctrl-T to load transaction from hex string, paste in messenger (easier for remote parties), 4) File export - save transaction to file and send to cosigner. For remote users, raw hex through secure messenger is often easiest. Note: Cosigner Pool doesn't work with hardware wallets."
        },
        {
          "question": "Why did my transaction descriptions disappear after restoring my wallet on a new system?",
          "answer": "Transaction labels (descriptions) are stored in the wallet file itself, not on any server or blockchain. If labels are missing after restore: 1) Check you're using the correct/latest wallet file backup (older backups won't have recent labels), 2) Verify the file isn't corrupted during copy, 3) Ensure the file loaded correctly in new EC. The wallet file location on Linux is `~/.electron-cash/wallets/`. Your coins are always recoverable from seed phrase, but labels are only in the wallet file, so keep multiple timestamped backups."
        },
        {
          "question": "What is the difference between Bits and Sats in Electron Cash?",
          "answer": "1 Bit = 100 Satoshis. Bits are a larger denomination than sats. In EC preferences (Tools > Preferences > General), you can choose your preferred unit: BCH (1.0), mBCH (0.001), bits (0.000001), or sats (0.00000001). Bits are sometimes called 'microbitcoin' or BCH. The conversion: 1 BCH = 1,000,000 bits = 100,000,000 sats. Many users prefer bits for everyday transactions as the numbers are more manageable than sats."
        },
        {
          "question": "How do I find the xpub (Master Public Key) in Electron Cash mobile?",
          "answer": "On Android: Open wallet > Three dot menu (top right) > Wallet information > Master public key. On iOS: This feature is NOT currently available. The iOS version lacks the wallet information/xpub display feature. You'll need to use the desktop version to view your xpub. This is a known gap in iOS functionality. If you need the xpub for services like Blockonomics, either install EC desktop and restore your wallet there, or submit a feature request on GitHub."
        },
        {
          "question": "Can I connect my Electron Cash wallet to my bank account?",
          "answer": "No, EC cannot connect directly to bank accounts. It's a Bitcoin Cash wallet, not a banking application. To convert BCH to fiat currency: 1) Send BCH to a cryptocurrency exchange that supports BCH and fiat withdrawals (like Kraken, Coinbase, etc.), 2) Sell BCH for fiat on the exchange, 3) Withdraw fiat to your bank account. To find exchanges: visit https://minisatoshi.cash/ecosystem and search for exchanges. There's no 'wallet connection' - you simply send BCH to the exchange's deposit address."
        },
        {
          "question": "Why does Electron Cash show clock icons up to 6 confirmations instead of just 1?",
          "answer": "This is inherited tradition from Bitcoin Core/Electrum. In early Bitcoin, exchanges required 6 confirmations for deposits (roughly 1 hour at 10 min/block). The convention became deeply ingrained - 6 confs provided sufficient security against double-spends and reorgs. While BCH has instant/0-conf for point-of-sale transactions thanks to DSP, the 6-conf display remains as legacy indicator. The clock faces filling up gives visual feedback of increasing security. EC is intentionally 'retro' in some UI aspects."
        },
        {
          "question": "Why doesn't Electron Cash Android support creating raw transactions for cold storage workflows?",
          "answer": "EC Android has limited cold wallet functionality compared to desktop: 1) It CAN sign transactions received via QR code or raw text on offline device, 2) It CANNOT save unsigned transactions to files like Electrum Android can, 3) Screen size constraints make full feature parity with desktop infeasible. Workaround: Use EC desktop (watch-only wallet) to create and save unsigned transactions, then sign them on Android offline device. The feature gap exists because: mobile development resources are limited, and the codebase diverged from Electrum about 7 years ago (an eternity in software development), making porting features non-trivial."
        },
        {
          "question": "Why can't I mix private keys and watch-only addresses in a single EC wallet?",
          "answer": "This is a current limitation of EC's wallet architecture. You cannot have a wallet file that contains both: 1) Addresses with private keys you control, and 2) Watch-only addresses (addresses you monitor but don't control). This 'seemingly arbitrary limit' is inherited from EC's wallet model where a wallet is either fully controlled (has all private keys) or entirely watch-only. Workaround: Create separate wallet files - one with your controlled keys, another watch-only for monitoring external addresses. This limitation affects some advanced use cases like coin control workflows where you want to track external UTXOs alongside your own. May be addressed in future wallet architecture updates."
        },
        {
          "question": "What does 'Freeze' mean for addresses or coins in Electron Cash?",
          "answer": "Freezing prevents automatic selection when sending transactions. Key points: 1) Frozen addresses/coins won't be used as inputs when you send BCH, 2) It does NOT prevent others from sending TO that address - funds can still be received, 3) Only prevents the coins from being spent unintentionally, 4) Useful for coin control - separating funds for different purposes, 5) You can still manually select frozen coins if needed. Use cases: segregating business vs personal funds, keeping specific UTXOs for token operations, preventing accidental spending of labeled coins. Remember: freeze is local wallet setting, not blockchain-level lock."
        },
        {
          "question": "Why do businesses need unique invoice addresses instead of RPA for most transactions?",
          "answer": "Accounting and reporting requirements favor invoicing model: 1) 'Issue invoice, receive payment' matches standard accounting practices, 2) HD wallets with unique addresses per invoice solve 'who paid what' tracking, 3) Exchange rates require specific BCH amounts per transaction, 4) Auditing requires clear payment trails internally, 5) Monthly bills have varying amounts (usage-based, exchange rate fluctuations). RPA excels only when: no prior interaction possible (public donations), or backend simplification (no address generation system) outweighs scanning overhead. For standard B2B/B2C transactions with communication channels, unique invoice addresses provide same privacy benefits without RPA complexity. KISS principle applies: use simplest solution that meets requirements."
        },
        {
          "question": "Can Electron Cash open Electrum (BTC) wallet files?",
          "answer": "Uncertain - it may or may not work due to codebase divergence. EC and Electrum split 7+ years ago and developed differently. Potential issues: 1) Different wallet file format versions, 2) Different derivation paths (BTC vs BCH), 3) Different encryption implementations possibly. If password-protected file opens in EC and prompts for password, the format might be compatible. After decryption, you could export private keys. Important: Even if file opens, addresses will show BCH amounts, not BTC. If you had BTC in 2018, you'll need to open in current Electrum for BTC, and separately in EC for BCH (if it existed on those addresses during 2017 fork)."
        },
        {
          "question": "What's the proper way to restore a wallet file versus a seed phrase in EC?",
          "answer": "Two different restoration methods: 1) Wallet File: File -> Open, browse to .wallet file. If encrypted, enter password. The file contains complete wallet data including labels, addresses, transaction history. 2) Seed Phrase: File -> New/Restore, choose 'I have a seed', enter 12/24 words. Recreates wallet from scratch by deriving keys. DON'T open wallet file in text editor and paste contents - that's the encrypted JSON/binary data, not useful as text. Seed phrases are your ultimate backup - they regenerate everything. Wallet files are convenience backups that preserve metadata but require password if encrypted."
        },
        {
          "question": "What are Cash Accounts and should I still use them?",
          "answer": "Cash Accounts is an older BCH protocol for human-readable payment addresses (like email addresses for crypto). How it works: Register name on-chain with block height tag (e.g., 'Donations#12345') plus emoji checksum to prevent squatting. Purpose: Memorable addresses instead of long hex strings. Current status: Somewhat deprecated - requires trusted indexer servers for lookups. Better alternatives: 1) BCMR (Bitcoin Cash Metadata Registries) provides similar identity features with SPV-verifiable proofs and decentralized hosting, 2) RPA for privacy-focused donations. Community recommendation: Let Cash Accounts 'gently die' in favor of BCMR which is more trustless. For simple donation addresses, just use standard BCH address with description label."
        },
        {
          "question": "What's the difference between Electrum and Electron Cash wallet files?",
          "answer": "They use similar but not identical formats since they forked 7+ years ago. Key differences: 1) Created for different blockchains (BTC vs BCH), 2) May have incompatible encryption or serialization versions, 3) Address derivation paths may differ. Cross-compatibility: Sometimes EC can open Electrum files if encryption is similar, but it's not guaranteed. If you have 2018 wallet: Open in Electrum (BTC) first, decrypt, export seed phrase or private keys, then use those to create new wallet in EC for BCH access. Remember: Post-2017-fork Electrum wallet likely has no BCH (created after split). Pre-fork keys could have both BTC and BCH from before split."
        },
        {
          "question": "What is BCMR and how does it compare to Cash Accounts?",
          "answer": "BCMR (Bitcoin Cash Metadata Registries) is newer protocol for on-chain identity and metadata. Advantages over Cash Accounts: 1) SPV-verifiable proofs make it trustless, 2) Can be hosted on your own server or sent in payment requests, 3) More flexible - supports personal and corporate identities, 4) Works for tokens and other use cases beyond payment addresses. Cash Accounts limitations: Requires trusted indexer server for lookups (centralizing element), on-chain registration with block height tags, primarily proof-of-concept. Community direction: BCMR is preferred path forward though JSON spec is currently over-designed and mainly used for tokens. Both aim to solve human-readable addresses, but BCMR has better trust model and extensibility."
        },
        {
          "question": "What is the proposed sub-wallet or xpriv-based wallet feature?",
          "answer": "Feature idea: Import multiple seed phrases or xprivs into single EC wallet instance. Use cases: 1) Migrate funds from old wallet to new via fusion (old seed as sub-wallet, outputs go to primary), 2) Import RPA wallet into HD wallet, 3) Spend from multiple sources in one transaction, 4) Consolidate donation addresses with main wallet. Tom's xpriv approach: Child wallets derived from parent seed can be used on mobile separately - if phone stolen, attacker can't access parent or sibling wallets. Only compromises that specific child. Jonas' approach: Import arbitrary seeds as sub-wallets with toggle to enable/disable. Both solve wallet migration and address consolidation problems while maintaining security isolation."
        },
        {
          "question": "Why doesn't EC show 'first seen' time for transactions instead of mined time?",
          "answer": "EC currently shows mined timestamp (block time) for confirmed transactions. Request: Show when your wallet first saw the transaction instead, emphasizing zero-conf capability. Challenges: 1) 'First seen by who?' - your wallet's timestamp vs Fulcrum server's timestamp, 2) If wallet offline when tx arrives, first-seen would be when wallet syncs (misleading), 3) Multiple transactions mined in same block get identical timestamps, making ordering unclear (CTOR makes it worse). Proposed solution: Use local wallet timestamp for transactions seen while wallet running, fall back to block time for transactions discovered after confirmation. This emphasizes BCH's instant transaction capability while remaining accurate. Not currently implemented in EC but suggested as UX improvement."
        },
        {
          "question": "Can Electron Cash scan QR codes directly from my desktop screen without a webcam?",
          "answer": "Yes! EC has screen scanning feature that captures your entire desktop and searches for QR codes. Super useful if: 1) Your computer doesn't have webcam, 2) QR code is displayed on website/PDF on your screen, 3) You want to avoid camera permissions. How to use: Click QR scan button, EC requests screen recording permission (macOS may show this as 'Accessibility' access), scans screen for QR codes. Calin's advice: Only grant this permission if you actually need the feature - decline if you don't plan to use it. Alternative: Use external QR scanner app that reads screen (KDE has this built into screenshot tool), then paste text into EC. Feature works for addresses, payment URIs, and potentially WIF private keys for sweeping."
        },
        {
          "question": "How do I sweep or import private keys (WIF) in Electron Cash?",
          "answer": "Two methods depending on your goal: 1) Sweep (move funds to current wallet): Wallet menu -> Private Keys -> Sweep. Enter WIF, EC creates transaction moving all funds from that address to your wallet. You can scan WIF from QR code. After sweep, original address is empty. 2) Import (add address to wallet): File -> New/Restore -> 'Import Private Keys' option. Creates wallet containing that specific private key. Address becomes part of your wallet. Use sweep when: you want funds consolidated into existing HD wallet. Use import when: you need to control specific address directly. QR scanning works for both - EC has QR button in relevant dialogs. Proposed enhancement: Support for 'bch-wif:' protocol handler for easier integration with services like stamps.cash."
        },
        {
          "question": "What is the cosigner pool feature in Electron Cash?",
          "answer": "Cosigner pool is EC's multi-signature coordination feature for 2-of-2 or m-of-n wallets. Use case: User wants OTP (one-time password) as second factor for transactions. Flow: 1) User creates partially signed transaction in EC, 2) Exports to JSON file, 3) Uploads to server/cosigner service, 4) After OTP verification, service adds its signature, 5) Broadcasts fully signed transaction. Security benefit: Even if main computer is compromised, attacker needs OTP device too. JF notes feature exists but 'not widely used or maintained.' Alternatives discussed: User's smartphone could cosign directly (becomes 2-of-2 multisig with phone), or use sign/verify message feature for authentication. Challenge: Requires external infrastructure (server running cosigning service) and workflow is manual (export/upload/verify). True 2FA for crypto is 'something you have' twice (wallet + OTP device) but adds useful separation of compromise surfaces."
        },
        {
          "question": "What exotic derivation paths does EC's scanner support and why?",
          "answer": "EC includes derivation path scanner (Tools menu) that searches for funds across multiple HD wallet paths. Standard path: m/44'/145'/0' (BIP-44 for BCH). Exotic paths in scanner: m/144'/..., m/0'/..., m/0/..., and others. Origin: Different wallet software historically used non-standard paths before standards solidified. Example: Some wallets used m/144' instead of m/44'/145', causing funds to appear 'lost' when restoring in different wallet. Pierre K: 'I'm especially curious about the m/144'/... ones' - these were likely used by early BCH wallets during chainsplit confusion. Jonas: 'I remember I found a document somewhere (probably an excel sheet) of different paths that had been used by some wallet at some point.' Documentation largely lost (honest-dot-cash went offline taking comprehensive list). Scanner improvement: Pierre reports adding 'number of transactions found' after timeout to help users with large histories. This feature saves users who have funds but wrong derivation path configured."
        },
        {
          "question": "Can you receive BCH with a watch-only wallet on Android EC app?",
          "answer": "Yes, but with workaround needed due to UX limitation. User Henrique: 'when I click the receive button it appears This is a watch-only wallet message.' Jonas confirms bug/limitation: 'I can confirm that it does not work to just hit the request button and the wallet will complain that it's watch only.' Workaround: 'You can however go to the Assets tab and choose Addresses with Type: Receiving and Status: Unused to get a QR code to an address.' Background: pat explains watch-only purpose: 'many automated services use this to monitor the payment addresses (associated with cold wallets for example) to credit funds or release goods to buyer.' JF warns about scam vector: 'its a likely scam, people give people a wallet' - receiving to someone else's wallet is losing funds. Key distinction: Watch-only wallets CAN receive funds (blockchain doesn't care), but you CANNOT spend without private key. Android app's Request button just has unnecessarily restrictive UX that blocks QR generation."
        },
        {
          "question": "What is the gap limit issue with EC payment requests and how does Electrum solve it?",
          "answer": "Addresses from expired invoices not reused, causing address exhaustion.  explains: 'Basically get_unused_address doesn't reuse addresses from expired invoices.' Problem: HD wallets generate sequential addresses. When payment request expires without payment, address marked 'used' even though never funded. Eventually hits gap limit (default 20) and no more addresses available. Concern: 'I wonder if it's bad that getrequest requestaddress will start returning the new request, and old request information is basically overwritten forever.' Electrum's solution: 'introduce request ids for payment requests, and they are used to query for them, not request address.' Request ID approach: UUID identifies payment request, address is implementation detail. Can reuse address if request expired without payment. Allows querying old request info even after address reused. EC currently uses address as primary key - changing to request IDs is breaking change. : 'Not sure how to proceed here.' Needs careful consideration of backwards compatibility and data migration."
        }
      ]
    }
  ]
}
