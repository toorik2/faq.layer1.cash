{
  "source": "Electron Cash Telegram",
  "total_batches": 47,
  "date_coverage": "2025-01-01 to 2025-11-14",
  "total_faqs": 327,
  "faqs": [
    {
      "question": "How do I get detailed error logs from Electron Cash?",
      "answer": "Run the Electron Cash AppImage from terminal with the -v (verbose) flag. This will show the full Python traceback including source code line numbers. The error dialog in the GUI often only shows the final error message without the stack trace. Example: ./ElectronCash.AppImage -v",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why do I get 'IndexError: list index out of range' when signing transactions with Satochip hardware wallet?",
      "answer": "This is a known bug in the Satochip plugin's CashToken handling code. The tx.token_datas() method returns output token data, but the code incorrectly uses it to check inputs. When there are more inputs than outputs, it causes an IndexError. Workaround: Send coins one at a time (single input per transaction) instead of combining multiple coins. This bug affects old Satochip wallets created before CashTokens.",
      "category": "Hardware Wallets"
    },
    {
      "question": "How do I send the maximum amount from a specific coin in Electron Cash?",
      "answer": "After right-clicking a coin and selecting 'Send', click the 'Max' button on the Send tab. The amount field is intentionally left blank because you can multi-select coins and don't have to send the full amount. The Max button calculates the coin value minus fees automatically. Note: The Max button may be greyed out until you enter a destination address first.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Can I create paper wallets with Electron Cash?",
      "answer": "Not easily with Electron Cash directly. For paper wallet generation, use dedicated tools: 1) Go to minisatoshi.cash/ecosystem and search for 'Paper Wallet', 2) Use paperwallet.fullstack.cash, or 3) For metal backup, check opensourcemetalwallet.com. These tools are specifically designed for secure paper wallet creation.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does Electron Cash show 'no module found pathvalidate' error after updating on Arch Linux?",
      "answer": "This happens after a Python version update (e.g., to Python 3.13). The python-pathvalidate package from AUR needs to be reinstalled to compile against the new Python version. Run your AUR helper to rebuild all Python packages that depend on the updated Python version. This is a common issue with Python version bumps on Arch-based systems.",
      "category": "Installation & Setup"
    },
    {
      "question": "Why is Electron Cash still using Qt5 instead of Qt6?",
      "answer": "Migrating to Qt6 requires switching from PyQt to PySide2, which is not a huge code change but requires extensive testing of every GUI component. Python's dynamic typing means there's no compile-time safety check, so all UI elements need manual testing. Ubuntu is planning to eventually stop packaging Qt5, so this migration is on the roadmap but not yet prioritized due to the testing overhead.",
      "category": "Development & Architecture"
    },
    {
      "question": "How do I install Electron Cash on Ubuntu?",
      "answer": "You can: 1) Download the AppImage from electroncash.org and run it directly, 2) Run from source by cloning the GitHub repository, or 3) Use a PPA if available. Most developers run it from source for testing. PPAs provide OS-integrated package management but require someone to maintain the packaging.",
      "category": "Installation & Setup"
    },
    {
      "question": "Can I run Electron Cash on Raspberry Pi or other ARM-based systems?",
      "answer": "There is no ARM AppImage for Electron Cash. You must run it from source, ideally in a Python virtual environment (VENV). Building an AppImage for ARM is impractical because many binary dependencies required for the build are not available for ARM architecture. Each unsuccessful build attempt takes about 3 hours. The setup process depends on your specific OS version and pip/apt installations. This approach has worked on various versions of EC on Ubuntu and Pi OS on Pi4 and Pi5.",
      "category": "Installation & Setup"
    },
    {
      "question": "Does the inter-wallet-transfer plugin respect frozen/locked addresses?",
      "answer": "Yes, the inter-wallet-transfer plugin respects frozen addresses. When you freeze an address or coin in Electron Cash, the plugin will not include those in the transfer operation. This is useful when you want to migrate most of a wallet but keep certain UTXOs or addresses in place (e.g., unfused coins you don't want to move). Always test on a small wallet first to verify this behavior.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does my Electron Cash show an incorrect BCH price (e.g., showing $13,000 instead of actual price)?",
      "answer": "This happens when the price API source (like CoinCap) has incorrect data. Electron Cash fetches live prices from external APIs, and if that API returns wrong data, your wallet will display incorrect fiat values. This can be costly if you're making trades based on the displayed price. Solution: Go to Tools > Preferences > Fiat and switch to a different price source. Always verify the displayed price against other sources before making important transactions.",
      "category": "Configuration & Settings"
    },
    {
      "question": "What is Electron Cash Wallet Connect?",
      "answer": "Electron Cash Wallet Connect is a plugin that allows Electron Cash to connect to decentralized applications (dApps) on Bitcoin Cash. Version 0.02-alpha added support for complex contracts requiring user's public key and signature. It enables signing transactions and messages from web-based dApps directly in your Electron Cash wallet. Future versions will support multi-connection (connecting to multiple dApps simultaneously). The plugin is being actively developed with plans for eventual integration into mainline EC.",
      "category": "Plugins & Extensions"
    },
    {
      "question": "Are there legal risks for Electron Cash developers regarding bugs like incorrect price display?",
      "answer": "Under the MIT license, the software comes with no warranty. However, legal risks depend on jurisdiction and political visibility. While the MIT license provides disclaimer protection, it's not absolute. Users have responsibility (caveat emptor/vendor) to verify critical information. Developers should focus on moral/personal responsibility to provide quality software. The fact that EC is FOSS (Free and Open Source Software) and WYSIWYG (What You See Is What You Get) provides some protection, but edge cases with determined litigants could be complex.",
      "category": "Legal & Licensing"
    },
    {
      "question": "How do I create a secure paper wallet with Electron Cash?",
      "answer": "EC can export individual private keys and QR codes from addresses (right-click address > Get private key). For maximum security: 1) Remove hard drive from laptop, 2) Boot from Linux LiveUSB (use UNetbootin to create it), 3) Download paper wallet generator from trusted source, 4) Generate and print wallet while offline, 5) Turn off computer - all traces vanish since nothing writes to disk. If you must use your normal system, disconnect internet before generating, then completely wipe ALL browser data (cache, history, local storage) afterward. Never generate wallets on smartphones. For the easiest approach, use EC directly: create new wallet from LiveUSB, print seed phrase and receive address QR code, test with small amount before committing larger funds.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How do I verify funds arrived at my paper wallet address?",
      "answer": "Use any block explorer to check the address balance. Simply enter your public address (the one starting with bitcoincash:) into a block explorer website. If concerned about privacy, use a VPN or different internet connection than your normal one when checking, though for paper wallet balance checks this is usually not critical.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "How do I sweep/import a paper wallet back into Electron Cash?",
      "answer": "Electron Cash can import individual private keys from paper wallets. Go to Wallet menu > Private Keys > Sweep or Import. Enter the private key from your paper wallet. Note: Once you enter the private key on your computer, that secret is exposed to your possibly-infected system. For practice, always test with small amounts first: create paper wallet, send test amount, verify arrival, import/sweep it back to ensure the full cycle works before storing significant funds.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does 'No FX rate available' appear in Electron Cash?",
      "answer": "This occurs when the configured price API provider is down or blocked. Common causes: 1) The specific API provider is having issues (CoinCap has been unstable, BitcoinAverage is dead), 2) Your firewall is blocking connections, 3) VPN is blocked by the API provider. Solution: Go to Tools > Preferences > Fiat and switch providers. Working providers (as of Jan 2025): CoinGecko, Coinbase, Kraken, BitPay, Bitstamp, Yahoo Finance. CoinCap and BitcoinAverage should be avoided.",
      "category": "Configuration & Settings"
    },
    {
      "question": "Which fiat price providers work best in Electron Cash?",
      "answer": "Recommended working providers: CoinGecko (most commonly used), Coinbase, Kraken, BitPay, Bitstamp, Yahoo Finance. Avoid: CoinCap (unstable, sometimes shows wrong prices like $13k), BitcoinAverage (dead service, should be removed). Access via Tools > Preferences > Fiat. Note: VPNs may cause issues as many sites blanket-block known VPN providers.",
      "category": "Configuration & Settings"
    },
    {
      "question": "How do I create a bootable Linux USB for secure wallet generation?",
      "answer": "Use UNetbootin (https://unetbootin.github.io/), a legendary open-source tool that creates bootable USB drives automatically. It can download Linux ISOs for you or use ones you've downloaded. Best practice: download ISO directly from the official Linux distribution website (e.g., Ubuntu, Linux Mint) rather than third-party sources. Once created, you can boot from this USB to generate paper wallets in a secure, isolated environment where nothing is written to your hard drive.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why does an address show as 'used' in the Addresses tab when I've never sent funds to it?",
      "answer": "When you copy an address from the Receive tab, Electron Cash assumes you requested a payment to that address. Since you shouldn't request multiple payments to the same address (for privacy), EC marks it as 'used' by that payment request. The Tx column in the Addresses tab shows actual transaction count - if it's 0, the address has no real transactions. To get addresses without marking them used, copy directly from the Addresses tab instead of the Receive tab.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "What seed phrase lengths are supported in Electron Cash?",
      "answer": "EC supports BIP39 seed phrases of 12, 15, 18, or 24 words on desktop. Mobile version only supports 12 words currently. BIP39 doesn't define anything longer than 24 words, and longer would be pointless since 24 words already provide 256 bits of entropy (more than sufficient security). You can also add an optional passphrase to any BIP39 seed, though this is not recommended because there's no checksum - if you mistype it or forget it, recovery becomes extremely difficult.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What are the security risks with offline wallet generation that most people don't consider?",
      "answer": "Beyond hard drive isolation, consider: 1) BIOS/firmware malware can persist even without hard drive and steal keystrokes, 2) LiveCD images can auto-connect to unsecured WiFi, 3) Malicious USB sticks may contain firmware exploits that survive reformatting (processor managing NAND chip can be hacked), 4) Hardware keyloggers on keyboard ports. These are called 'Evil Maid Attacks'. Best practice: dedicate a machine to permanent offline duty, only use new USB sticks from trusted sources, and ideally disable/remove WiFi hardware physically.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How do I verify my Electron Cash download is authentic?",
      "answer": "Always verify downloads using GPG signatures or at minimum, checksums. Download GPG public keys for developers (jonald2 and Calin) from https://github.com/Electron-Cash/keys-n-hashes/tree/master/pubkeys. Import these keys into your GPG keychain, then verify the signature file against your download. This confirms the binary wasn't tampered with. Even if downloading from electroncash.org directly, verification is recommended security practice.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How do I restore my wallet on a new device?",
      "answer": "Wallet files don't automatically copy between devices. You have two options: 1) Restore wallet from seed phrase - create new wallet and select 'I already have a seed', enter your backup seed words, or 2) Send coins from old device to new device if you still have access. You can also manually copy wallet files from the old device's data directory (e.g., AppData/Roaming/Electroncash/wallets on Windows) to the new device.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Is there a CashTokens transaction history export feature in Electron Cash?",
      "answer": "No, currently there is no dedicated CashTokens history export function in Electron Cash. Regular BCH transaction history can be exported, but token-specific transaction data export is not yet implemented as a built-in feature.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Where can I view CashFusion statistics and usage data?",
      "answer": "CashFusion statistics are available at https://fusionstats.redteam.cash/. This site shows fusion activity, participation rates, and other metrics about CashFusion usage on the network. It's maintained by Rucknium (aka RedTeam), a privacy researcher in the BCH ecosystem.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What does 'RuntimeError: dictionary changed size during iteration' mean and can it corrupt my wallet?",
      "answer": "This Python error occurs when EC's internal data structures are modified during iteration (threading issue). Yes, this can potentially corrupt your coins list, requiring a wallet rebuild. If you see this error, run EC with the -v flag for more detailed information. Consider rebuilding your wallet (Wallet menu > Information > Rebuild) to ensure coin data integrity. This is a known threading bug that occasionally occurs.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Does Electron Cash work with Electrum BTC wallet files?",
      "answer": "Electron Cash and Electrum use different wallet directories (e.g., Electroncash/wallets vs Electrum/wallets) so they won't interfere with each other's files. Wallet files aren't cross-compatible since they're for different blockchains. However, if you have a pre-fork BIP39 seed from before the BCH/BTC split, you can restore it in both wallets to access coins on both chains. Always keep backups of wallet files regardless.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "How does Electron Cash connect to the Bitcoin Cash network?",
      "answer": "Electron Cash is not 'pure SPV'. It uses Fulcrum as middleware - EC talks to Fulcrum servers, which in turn talk to full nodes. Pure SPV would mean querying any full node directly using bloom filters, but EC uses dedicated indexers (Fulcrum) that maintain address and transaction indexes for fast queries. This architecture provides better performance than pure SPV while maintaining lightweight client benefits. Users can run their own Fulcrum server for maximum privacy and control.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why doesn't Electron Cash have a map feature to show wallet users?",
      "answer": "Privacy is the main reason. Users don't usually want to inform the network of their location. Additionally, there's a lack of good open and free map solutions. Most BCH vendor maps are closed/proprietary (like bitcoin.com map) which could block access, and many have outdated entries. OpenStreetMap has been suggested but adoption has been slow. EC prioritizes user privacy over network visibility features.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Where can I get help with running a Fulcrum server?",
      "answer": "There's a dedicated Telegram group for Fulcrum server support: @electroncashserver. This is the appropriate place for questions about Fulcrum setup, configuration, maintenance, and troubleshooting. The main Electron Cash group focuses on wallet usage, while the server group handles infrastructure topics.",
      "category": "Network & Architecture"
    },
    {
      "question": "How can I learn about SPV and thin client technology in Bitcoin Cash?",
      "answer": "Good resources include: 1) The original Bitcoin whitepaper section on SPV, 2) https://flowee.org/news/2023-08-thin-clients/ which explains thin client concepts for BCH, 3) Understanding that EC uses indexed servers (Fulcrum) rather than pure bloom filter SPV. Key concept: EC queries Fulcrum which maintains address/transaction indexes, rather than querying full nodes directly with bloom filters like original SPV design.",
      "category": "Network & Architecture"
    },
    {
      "question": "What is the technical definition of SPV and how does Electron Cash implement it?",
      "answer": "SPV (Simplified Payment Verification) is defined as a wallet that validates transactions by: 1) Checking merkle proofs to verify transaction inclusion in a block, 2) Confirming the block is in the chain with most Proof-of-Work. EC does perform these SPV checks. However, EC is more accurately described as an 'RPC/SPV' wallet - it uses SPV to verify proofs but relies on Fulcrum servers (RPC) for blockchain queries. This differs from BIP-37 'pure' SPV which uses bloom filters to query any full node directly. The distinction is primarily about networking architecture and has privacy implications.",
      "category": "Network & Architecture"
    },
    {
      "question": "Is Electron Cash a fork of another wallet?",
      "answer": "Yes, Electron Cash is a fork of Electrum (the Bitcoin wallet). It was created for Bitcoin Cash. EC is one of many Electrum forks - others exist for Litecoin, Dogecoin, Dash, Zcash, BSV, eCash, Ergon, and more. Because EC inherits Electrum's codebase, it uses the same general architecture including PyQt for the GUI and the client-server model with dedicated indexers. The first EC release occurred just one day before the BCH fork in August 2017.",
      "category": "Development & Architecture"
    },
    {
      "question": "What are the privacy implications of Electron Cash's architecture compared to BIP-37 SPV?",
      "answer": "EC/Electrum-style architecture has a significant privacy downside: the wallet directly tells the server all addresses of interest, allowing the server to build a complete profile of your wallet. BIP-37 SPV uses probabilistic bloom filters instead, which provides some plausible deniability (though not perfect). However, BIP-37 has its own issues. The trade-off is that EC's approach is more efficient and reliable. For maximum privacy in EC, run your own Fulcrum server or use Tor/VPN connections to public servers.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "How do I view CashToken metadata (names, icons) in Electron Cash?",
      "answer": "Currently, BCMR (Bitcoin Cash Metadata Registry) resolution requires explicit user action via a context menu in CashToken-related tabs. Right-click on a token and select 'Resolve Metadata'. This was intentional to prevent fraud (someone could mint fake tokens with misleading metadata). However, many users don't know about this feature and only see cryptic token IDs. The EC team is considering: 1) Auto-resolve with opt-in/opt-out toggle, 2) Show metadata but mark tokens as 'unknown' until user approves. Note: EC's BCMR resolver doesn't fully support the spec yet and doesn't follow auth-chains for updates.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Why don't CashToken tabs show by default in Electron Cash?",
      "answer": "The CashToken tabs are currently hidden by default and must be enabled manually in preferences. To enable them: go to Tools > Preferences > General and check the option to show token tabs. The development team is considering enabling these tabs by default in future versions since CashTokens are now a core part of the BCH ecosystem. Until then, users need to manually enable them to see their tokens.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Where can I find documentation about SPV protocol for Bitcoin Cash?",
      "answer": "Key resources: 1) Original Bitcoin whitepaper section on SPV, 2) https://documentation.cash/protocol/spv.html - BCH-specific SPV documentation, 3) BIP-37 specification for bloom filter SPV. The documentation.cash site covers the merkle proof verification concept and its implementation in BCH. Remember that 'SPV' as defined in the whitepaper is the verification concept, while BIP-37 was the first network-level implementation using bloom filters.",
      "category": "Development & Architecture"
    },
    {
      "question": "What is the Paytaca BCMR Indexer and can Electron Cash use it?",
      "answer": "The Paytaca BCMR Indexer (https://github.com/paytaca/bcmr-indexer) is a service that indexes Bitcoin Cash Metadata Registry information for CashTokens. It provides API endpoints for resolving token metadata. While EC currently does its own BCMR resolution (with limitations), developers are considering using Paytaca's indexer as an alternative since it's more complete and follows auth-chains properly. The trade-off is that it's a centralized service, but it's easier and more reliable than EC's current implementation.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "How do I fetch NFT-specific metadata (icons, names) in Electron Cash?",
      "answer": "As of Feb 2025, EC supports NFT-specific BCMR metadata. Right-click on an NFT in the tokens tab and select 'Fetch NFT Metadata' to download and apply the token's icon and name. This is different from category-level metadata - NFTs can have individual images/names. EC now uses Paytaca's BCMR indexer for fast metadata downloads, with blockchain lookup as fallback. Note: Icons appear small in the current UI but the data is accurate. The 'Category Properties...' context menu is for token category metadata, not individual NFTs.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Why doesn't Electron Cash work on Fedora when running from source?",
      "answer": "Fedora switched to BTC's libsecp256k1 which has incompatible Schnorr signatures (BCH uses different Schnorr). This causes conflicts when running EC from source. Solution options: 1) Use the AppImage which bundles compatible libraries, 2) Build BCH's libsecp256k1 from BCHN source and copy the .so file, 3) Wait for someone to package libsecp256k1-bch separately for Fedora repos. CashFusion specifically requires working secp256k1, so fallback to Python code isn't sufficient.",
      "category": "Installation & Setup"
    },
    {
      "question": "How do I build an Electron Cash AppImage from source?",
      "answer": "Run the build script: `contrib/build-linux/appimage/build.sh 4.4.2` (replace version number as needed). This creates an AppImage with all bundled dependencies. AppImages are useful when running from source has environment issues (libsecp256k1 conflicts, Qt/PyQt version mismatches, protobuf conflicts). The AppImage bundles its own Python environment, Qt libraries, and cryptographic libraries to avoid host system conflicts.",
      "category": "Development & Architecture"
    },
    {
      "question": "What are the advantages of running Electron Cash from source vs AppImage?",
      "answer": "Running from source offers: 1) Easy testing of master branch or feature branches via git pull, 2) Ability to tweak config files directly, 3) Native Qt appearance (AppImage can look slightly different), 4) Package manager integration (dnf/apt updates). Disadvantages: Environment conflicts (libsecp256k1, protobuf versions, PyQt compatibility), SSL certificate issues with self-signed certs. AppImage benefits: Isolated environment, no dependency conflicts, works out of box. Trade-off based on your use case.",
      "category": "Installation & Setup"
    },
    {
      "question": "What common Python environment issues prevent EC from running from source?",
      "answer": "Common issues include: 1) libsecp256k1 version conflicts (BTC vs BCH Schnorr signatures), 2) protobuf version mismatches ('cannot import runtime_version'), 3) PyQt5 vs PyQt6 conflicts, 4) SSL certificate verification failures with self-signed certs (switch to Let's Encrypt), 5) Python version incompatibilities after system updates. Solutions: Use virtual environment (venv) with site-packages, try Anaconda for clean environment, or fall back to AppImage. Running from source on ARM additionally requires manually compiling secp256k1.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Can I configure Electron Cash to use my own BCMR indexer instead of Paytaca's?",
      "answer": "Not yet configurable via UI (as of Feb 2025). EC hardcodes Paytaca's indexer with blockchain fallback. To use custom indexer, it must follow Paytaca's API format (there's no universal standard yet). Options for custom metadata: DNS-resolved BCMR (part of spec but less supported) or matching Paytaca's API. The authority/registry providing metadata should ideally be shown in UI for transparency, but this isn't implemented yet.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "What does 'could not find paymentrequest_pb2.py' error mean when running EC from source?",
      "answer": "This error occurs when the protobuf file hasn't been compiled. Run the command shown in the error message: `protoc --proto_path=electroncash/ --python_out=electroncash/ electroncash/paymentrequest.proto`. You need to install the protobuf compiler first (protoc). This is a recent requirement - the pb2.py file needs to be generated from the .proto definition. This started happening around late 2024/early 2025 and affects running from source. The AppImage doesn't have this issue since it includes pre-compiled files.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why are self-signed SSL certificates risky for public Fulcrum servers?",
      "answer": "Self-signed certs enable Man-in-the-Middle (MITM) attacks on public WiFi or unsecured networks. Users cannot easily verify if a certificate is legitimate (just a long number), making forgery trivial. While self-signed certs can be secure if you pin the specific certificate, typical users don't verify this. Web browsers treat them as untrusted for this reason. For public Fulcrum servers, use Let's Encrypt or other CA-signed certificates. Self-signed is only appropriate for private servers where you control both ends and can verify the certificate fingerprint.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How can I help maintain Electron Cash packages for Linux distributions like Fedora?",
      "answer": "You can become a co-maintainer for official Fedora packages. Responsibilities include: 1) Following Fedora package guidelines, 2) Bumping version numbers when maintainer is away, 3) Reviewing new BCH-related packages before submission, 4) Creating RPMs for dependencies like libsecp256k1-bitcoin-cash. Contact existing package maintainers (like Jonny in the EC Telegram) to start. Benefits: faster introduction of BCH-specific packages, easier installation via `dnf install electron-cash`, and community ownership of packaging. Fedora maintainer policy documentation: https://docs.fedoraproject.org/en-US/fesco/Packager_sponsor_policy/",
      "category": "Development & Architecture"
    },
    {
      "question": "What happened to the official Electron Cash Twitter/X account?",
      "answer": "The @electroncash X/Twitter account was lost due to dormancy lockout - X/Twitter wouldn't allow login after a period of inactivity. The account has ~2k followers but no one can access it. Recovery attempts are being made with X support, but success is uncertain. In the meantime, the EC community needs volunteers to manage social media if the account is recovered or if a new one is created. The handle and existing followers make recovery valuable, but X support is difficult to reach.",
      "category": "Community & Resources"
    },
    {
      "question": "How does BCH's libsecp256k1 differ from Bitcoin's version?",
      "answer": "BCH uses a different Schnorr signature implementation than BTC's libsecp256k1. The BCH version (from BCHN) is effectively frozen and incompatible with newer BTC versions. This causes conflicts on distros like Fedora that package BTC's version. Solutions: 1) Package libsecp256k1-bitcoin-cash separately (like GNU Guix does), 2) Use static linking to bundle BCH version within the app, 3) Use AppImage which includes compatible libraries. The naming convention '-bitcoin-cash' is recommended to avoid conflicts while allowing both to be installed.",
      "category": "Development & Architecture"
    },
    {
      "question": "Where are Electron Cash wallet files stored and what do they contain?",
      "answer": "On Linux, wallet files are stored in `~/.electron-cash/wallets/`. Each wallet is a single file containing: addresses, transactions, labels/descriptions for transactions and addresses, and private keys (if not a watch-only wallet). If the wallet is password-protected, the file is encrypted and appears as a single long line when opened in a text editor. All your custom transaction descriptions ('labels') are stored in this file, so backing up the wallet file preserves everything. The file name is the wallet name you chose during creation.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "How do I tell if my wallet file is encrypted?",
      "answer": "Open the wallet file in a text editor. If it shows as one very long single line (like an address), the file is encrypted with your wallet password. Unencrypted wallet files show structured JSON data with readable keys like 'addresses', 'labels', 'transactions'. Note: Encrypted wallet files can be very large and may crash regular text editors - use an editor like Notepad++ that handles large files well. You can decrypt the file by loading it in EC and removing the password temporarily to inspect the contents.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Where is the Cosigner Pool plugin in Electron Cash?",
      "answer": "The Cosigner Pool is a built-in optional feature, not an external plugin. Find it under Tools > Preferences > Optional Features, not under Plugins. It allows multisig wallet participants to share partially signed transactions through a server. The server is still running (as of Feb 2025) and works for software wallets, but NOT for hardware wallets. Alternative methods for sharing PSBTs: QR codes (Tools > Show QR), raw hex (Ctrl-T to load), or through secure messaging apps.",
      "category": "Plugins & Extensions"
    },
    {
      "question": "How do I transfer partially signed transactions between multisig cosigners?",
      "answer": "Several methods: 1) Cosigner Pool - built-in feature that passes transactions through server (enable in Optional Features), 2) QR codes - display QR of partial transaction for other party to scan (may be too large for complex transactions), 3) Raw hex - use Ctrl-T to load transaction from hex string, paste in messenger (easier for remote parties), 4) File export - save transaction to file and send to cosigner. For remote users, raw hex through secure messenger is often easiest. Note: Cosigner Pool doesn't work with hardware wallets.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Who are the current Electron Cash maintainers with GitHub merge privileges?",
      "answer": "As of February 2025, only two people have GitHub merge privileges: Calin Culianu (cculianu) and JF (Jf010). The project is open to more contributors joining with merge access. For social media accounts, Twitter/X accounts can be delegated without sharing passwords. The team follows a trust-based model where social media managers should be accountable and transparent about their identity. Anyone wanting to contribute code should submit pull requests which will be reviewed by these maintainers.",
      "category": "Community & Resources"
    },
    {
      "question": "Why did my transaction descriptions disappear after restoring my wallet on a new system?",
      "answer": "Transaction labels (descriptions) are stored in the wallet file itself, not on any server or blockchain. If labels are missing after restore: 1) Check you're using the correct/latest wallet file backup (older backups won't have recent labels), 2) Verify the file isn't corrupted during copy, 3) Ensure the file loaded correctly in new EC. The wallet file location on Linux is `~/.electron-cash/wallets/`. Your coins are always recoverable from seed phrase, but labels are only in the wallet file, so keep multiple timestamped backups.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Where can I find the Double Spend Proof (DSP) plugin for Electron Cash?",
      "answer": "The DSP plugin is available as a GitHub pull request (PR #2331: https://github.com/Electron-Cash/Electron-Cash/pull/2331). It's not yet merged into the main release. To use it, you need to either: 1) Run from the specific PR branch, or 2) Wait for it to be merged and released officially. The plugin enables double-spend proof detection in EC. Status as of Feb 2025: waiting for code review from maintainers. Report any issues in the PR comments or the EC Telegram group.",
      "category": "Plugins & Extensions"
    },
    {
      "question": "Why do I get protobuf version mismatch errors when running EC from source?",
      "answer": "The protoc compiler version and Python protobuf library version must match. Common scenario: System protoc (e.g., 3.19) generates *_pb2.py files that are incompatible with your Python protobuf library version (e.g., 5.27). Solutions: 1) Update Python protobuf: `pip install -U protobuf`, 2) Regenerate the pb2 files: `protoc --proto_path=electroncash/ --python_out=electroncash/ electroncash/paymentrequest.proto`, 3) Recreate your venv. The generated files contain version info in their headers - check both match your installed Python library. AppImages avoid this by bundling matching versions.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Where can I find Electron Cash's Fedora RPM packaging specification?",
      "answer": "The Fedora RPM spec file is at: https://src.fedoraproject.org/rpms/electron-cash/blob/rawhide/f/electron-cash.spec. This defines how EC is packaged for Fedora Linux, including dependencies, build steps, and protobuf file compilation. The spec downloads .proto files separately since they're not in the sdist tarball. Useful for understanding how official Linux packages handle EC dependencies like libsecp256k1, protobuf, and PyQt.",
      "category": "Development & Architecture"
    },
    {
      "question": "What is the current status of protobuf in EC's requirements.txt?",
      "answer": "Protobuf is listed in requirements.txt (recently moved from requirements-hw.txt). To install properly: `pip install -U -r contrib/requirements/requirements.txt`. The bundled AppImage uses protobuf==5.27.3 with matching *_pb2.py files. If running from source with older Python protobuf library, you'll get import errors. Either upgrade protobuf or regenerate the pb2 files with your local protoc version. Version mismatch is the #1 cause of 'could not find paymentrequest_pb2.py' errors.",
      "category": "Installation & Setup"
    },
    {
      "question": "What is the difference between Bits and Sats in Electron Cash?",
      "answer": "1 Bit = 100 Satoshis. Bits are a larger denomination than sats. In EC preferences (Tools > Preferences > General), you can choose your preferred unit: BCH (1.0), mBCH (0.001), bits (0.000001), or sats (0.00000001). Bits are sometimes called 'microbitcoin' or Î¼BCH. The conversion: 1 BCH = 1,000,000 bits = 100,000,000 sats. Many users prefer bits for everyday transactions as the numbers are more manageable than sats.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "What does 'Spend only confirmed coins' option do in Electron Cash?",
      "answer": "When enabled (Tools > Preferences > Transactions), EC will only spend UTXOs that have at least one confirmation. This provides slight security benefit: prevents spending unconfirmed change from previous transactions that might not confirm. It's useful when: 1) Making multiple transactions in succession, 2) During network congestion, 3) For extra assurance coins are truly spendable. Downside: you can't immediately respend coins from unconfirmed transactions, which may slow down workflows. For most users, leaving it off is fine since BCH confirms quickly.",
      "category": "Configuration & Settings"
    },
    {
      "question": "Does Electron Cash support BIP21 URI format for CashTokens?",
      "answer": "As of Feb 2025, EC does not yet implement the proposed BIP21-style query parameters for CashTokens. The proposal (documented at bitcoincashresearch.org) suggests adding token information to bitcoincash: URIs, like: bitcoincash:addr?token_category=xxx&token_amount=yyy. This would enable QR codes and payment links to request specific token payments. Feature is on the radar but not implemented. For now, CashToken transfers require manual entry of token category and amount in EC's token sending interface.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Does changing CashFusion mode reset the fusion round counter?",
      "answer": "No, the fusion round counter is preserved when you switch modes (Normal, Consolidate, Fan-out). If your coins have been fused 2 times out of a target of 3 rounds, switching modes keeps that count at 2/3. The round tracking is per-coin, not per-mode. This allows you to change strategies mid-fusion without losing progress. The fusion plugin tracks each coin's history regardless of which mode was used for each fusion.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Can I set up Electron Cash to auto-start and fuse without entering a password?",
      "answer": "Yes, but ONLY with an unencrypted wallet. The password is used to decrypt the wallet file itself, so there's no way to auto-start an encrypted wallet. For automatic fusion: 1) Create an unencrypted wallet (leave password blank during setup), 2) Configure your OS to launch EC at boot with that wallet, 3) Enable auto-fusion in CashFusion settings. WARNING: Unencrypted wallets can be stolen by anyone with device access - it's equivalent to hanging the key next to a locked door. Use this only on dedicated, secured machines.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What are the security implications of running an unencrypted wallet for continuous fusion?",
      "answer": "Anyone with physical or remote access to your device can copy the wallet file and drain your funds. The security trade-off is identical to 'saving the password' - you're effectively storing the decryption key alongside the encrypted content. Mitigations: 1) Use a dedicated device (like Raspberry Pi) only for fusion, 2) Ensure strong OS-level security (disk encryption, limited user access), 3) Keep only modest amounts in the fusion wallet, 4) Place device in physically secure location. Running 24/7 is optimal for CashFusion liquidity, similar to BitTorrent seeding.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why is there no ARM AppImage for Electron Cash?",
      "answer": "Several technical challenges: 1) No prebuilt PyQt5 wheel for ARM (Qt6 has one, but EC requires Qt5), 2) Build process is extremely slow on ARM devices (~3+ hours per attempt on Pi4), 3) Many binary dependencies lack ARM versions, 4) Complex deterministic build requirements for security verification, 5) Technical debt from early Electrum development. Cross-compiling from x86 Docker container is theoretically possible but not implemented. Current solution: Run from source in Python virtual environment on ARM devices, accepting the setup complexity.",
      "category": "Installation & Setup"
    },
    {
      "question": "How do I install Electron Cash on Fedora Linux?",
      "answer": "Simple one-line install: `sudo dnf install electron-cash`. Fedora maintains an official EC package in their repositories. This is the easiest installation method on Fedora, handling all dependencies automatically including libsecp256k1, protobuf compilation, and PyQt5. Updates come through regular Fedora updates. Alternative: Use the AppImage for any Linux distro, or run from source in a Python virtual environment for development/testing.",
      "category": "Installation & Setup"
    },
    {
      "question": "Should I use Python virtual environments for running Electron Cash from source?",
      "answer": "Yes, using venv is strongly recommended, especially on rolling-release distributions like Arch Linux. Benefits: 1) Isolates EC dependencies from system Python packages, 2) Survives system upgrades that would break dependencies, 3) Easier to match specific library versions EC needs (protobuf, PyQt5, etc.), 4) Simple to recreate if broken. Setup: `python -m venv --system-site-packages ec_venv && source ec_venv/bin/activate && pip install -r requirements.txt`. Only minor hassle: may need to recreate venv on major Python version upgrades.",
      "category": "Installation & Setup"
    },
    {
      "question": "How do I report a bug in Electron Cash?",
      "answer": "Submit bug tickets to GitHub: https://github.com/Electron-Cash/Electron-Cash/issues. Include: 1) Steps to reproduce the bug, 2) Operating system and version (iOS, Android, Windows, Linux distro), 3) EC version number, 4) Screenshots if applicable, 5) Any error messages. For mobile-specific bugs (iOS/Android), mention device model and OS version. Test on different platforms if possible to narrow down the issue. The community appreciates detailed bug reports as they help developers fix issues faster.",
      "category": "Community & Resources"
    },
    {
      "question": "Why doesn't CashFusion appear in my Electron Cash installation on Raspberry Pi?",
      "answer": "CashFusion requires working libsecp256k1 for cryptographic operations. When running from source on ARM, libsecp256k1 may not be properly compiled/linked. Check Tools > Plugins > CashFusion to see if it's enabled. If missing: 1) Ensure libsecp256k1 is compiled for ARM (run `contrib/make_secp`), 2) Install in a proper virtual environment with all dependencies, 3) Verify Python can import the crypto library without falling back to pure Python. The pure Python fallback is too slow for fusion operations.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "How do I find the xpub (Master Public Key) in Electron Cash mobile?",
      "answer": "On Android: Open wallet > Three dot menu (top right) > Wallet information > Master public key. On iOS: This feature is NOT currently available. The iOS version lacks the wallet information/xpub display feature. You'll need to use the desktop version to view your xpub. This is a known gap in iOS functionality. If you need the xpub for services like Blockonomics, either install EC desktop and restore your wallet there, or submit a feature request on GitHub.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Can I connect my Electron Cash wallet to my bank account?",
      "answer": "No, EC cannot connect directly to bank accounts. It's a Bitcoin Cash wallet, not a banking application. To convert BCH to fiat currency: 1) Send BCH to a cryptocurrency exchange that supports BCH and fiat withdrawals (like Kraken, Coinbase, etc.), 2) Sell BCH for fiat on the exchange, 3) Withdraw fiat to your bank account. To find exchanges: visit https://minisatoshi.cash/ecosystem and search for exchanges. There's no 'wallet connection' - you simply send BCH to the exchange's deposit address.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Does Electron Cash support SLP tokens?",
      "answer": "No, Electron Cash does not support SLP (Simple Ledger Protocol) tokens. SLP tokens were an earlier token standard on BCH that has been largely superseded by CashTokens. SLP is considered a 'failed experiment' with very limited exchange support remaining. EC focuses on CashTokens as the native token protocol. If you have SLP tokens, you'll need to use specialized SLP-compatible software (though options are limited). CashTokens provide better functionality and are built directly into the BCH protocol.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "If I can browse with Tor Browser, why doesn't Electron Cash connect through Tor?",
      "answer": "Tor Browser and EC use Tor differently. EC needs to connect to Fulcrum servers via SOCKS5 proxy. Configuration: 1) Tools > Network > Proxy tab > Select SOCKS5, 2) Set Host: 127.0.0.1, Port: 9050 (or 9150 if using Tor Browser's proxy), 3) Enable 'Use Tor proxy for all connections'. Also consider using .onion server addresses for Fulcrum. EC won't automatically use your system's Tor setup - it needs explicit proxy configuration. For CashFusion over Tor, ensure the fusion server is also reachable over Tor.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Does Electron Cash support BIP38 encrypted paper wallets?",
      "answer": "Yes, EC supports BIP38 encrypted private keys. To sweep: 1) Go to Wallet > Private keys > Sweep, 2) Enter the BIP38 encrypted private key (starts with '6P'), 3) EC will prompt for the password to decrypt it. BIP38 adds a password layer to private keys for secure paper wallet storage. If you created a BIP38 paper wallet, you'll need both the encrypted private key and the password you set during creation. Desktop EC fully supports this feature.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What is the 'Fetch Category Metadata' option in CashTokens tab?",
      "answer": "This is a newer feature (added to master branch around March 2025) that allows you to fetch BCMR metadata for token categories directly from the Token History tab. Right-click on a token transaction or category and select 'Fetch Category Metadata' to download names, icons, and descriptions. This is more convenient than the older method of going into 'Category Properties' and clicking 'Apply'. The feature uses Paytaca's BCMR indexer to quickly resolve token information. Future versions may include 'Update All' functionality to fetch metadata for all tokens at once.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "What is the difference between BIP38 and CashStamps for paper wallets?",
      "answer": "BIP38 encrypts the private key (WIF) with a password - you need both the encrypted key and password to sweep. EC supports BIP38 sweep (it prompts for password). CashStamps uses a simpler approach: it just presents the plain WIF for sweeping without encryption. This 'dumb' approach was deliberately chosen to make it easier for wallets to support. Few wallets besides EC support BIP38 encrypted keys. Both methods work for paper wallets, but BIP38 provides an extra security layer if the paper is physically compromised.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What is happening with the CoinCap price API in Electron Cash?",
      "answer": "CoinCap deprecated their v2 API on March 31, 2025. The v3 API requires an API key and charges for requests. EC users should switch to alternative price providers: CoinGecko, Kraken, Coinbase, BitPay, or Bitstamp (Tools > Preferences > Fiat). CoinGecko is recommended as a free alternative. This is a reminder that free API services often get discontinued, so relying on multiple sources is wise. EC developers may need to remove CoinCap from options or implement the new paid API.",
      "category": "Configuration & Settings"
    },
    {
      "question": "How do I install Electron Cash on Whonix?",
      "answer": "Download and run the AppImage directly. Get it from https://electroncash.org/downloads/4.4.2/win-linux/Electron-Cash-4.4.2-x86_64.AppImage. Make it executable (chmod +x) and run. Since Whonix routes all traffic through Tor, EC will automatically use Tor for network connections. Whonix is Debian-based, so the Linux AppImage works perfectly. The AppImage bundles all dependencies, avoiding package compatibility issues.",
      "category": "Installation & Setup"
    },
    {
      "question": "Why does Electron Cash show clock icons up to 6 confirmations instead of just 1?",
      "answer": "This is inherited tradition from Bitcoin Core/Electrum. In early Bitcoin, exchanges required 6 confirmations for deposits (roughly 1 hour at 10 min/block). The convention became deeply ingrained - 6 confs provided sufficient security against double-spends and reorgs. While BCH has instant/0-conf for point-of-sale transactions thanks to DSP, the 6-conf display remains as legacy indicator. The clock faces filling up gives visual feedback of increasing security. EC is intentionally 'retro' in some UI aspects.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "What is BCH's rolling checkpoint and how does it work?",
      "answer": "BCH's rolling checkpoint prevents deep reorganizations. The rule: 10 confirmations OR 2 hours, whichever is LONGER. This means: 1) If blocks are mined quickly (high hashrate), must still wait 2 hours for finality, 2) If blocks are slow, need minimum 10 confirmations. This prevents scenarios where hashrate spikes cause rapid block production followed by reorgs. You could theoretically reorg 100 blocks if they were all mined in under 120 minutes (unlikely but mathematically possible). The 2-hour minimum provides temporal security independent of confirmation count.",
      "category": "Network & Architecture"
    },
    {
      "question": "What's the best practice for contributing icons or UI changes to Electron Cash?",
      "answer": "Always consult maintainers BEFORE investing significant time. Key points: 1) EC maintainers (especially Calin) prefer detailed, non-flat icon styles over modern minimalist designs, 2) EC intentionally maintains a 'retro' aesthetic, 3) Bug fixes and consistency improvements are welcome, 4) Reductionist/flat modern icons are likely to be rejected. When submitting PRs: include screenshots, expect feedback, and be prepared to modify or revert specific changes. The maintainers appreciate contributions but have strong aesthetic preferences that differ from modern design trends.",
      "category": "Development & Architecture"
    },
    {
      "question": "What happened to cashfusion.org's SSL certificate?",
      "answer": "The SSL certificate for cashfusion.org expired on March 30, 2025 due to lack of automatic renewal. This is a common issue with manually managed certificates. Solution for site operators: use certbot with automatic renewal via cron job or systemd timer to run the cert tool periodically. Sites like Let's Encrypt provide free certificates but require regular renewal (every 90 days). This doesn't affect CashFusion functionality in EC itself, just the informational website.",
      "category": "Community & Resources"
    },
    {
      "question": "How long is a Double Spend Proof (DSP) relevant for detecting fraud?",
      "answer": "A DSP is only relevant in the first 3-5 seconds after a transaction is broadcast. After that time window, the transaction has propagated across the network and miners have it in their mempools, making double-spend attempts extremely difficult. This is why BCH's 0-conf is considered safe for retail point-of-sale transactions. EC's DSP plugin (PR #2331) monitors for these proofs in real-time, but for historical transaction views, DSP information isn't particularly meaningful since the attack window has long passed.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why does Electron Cash not detect my KeepKey hardware wallet on Windows 11?",
      "answer": "This is a known issue: KeepKey works with Electrum (BTC) and the official KeepKey app on Windows 11, but EC reports 'no device detected'. It works fine on Linux with the same hardware. Troubleshooting: 1) Update firmware, 2) Verify USB drivers are installed, 3) Try different USB ports, 4) Run EC as administrator. The issue appears to be Windows-specific driver/permission handling in EC. Workaround: Use EC on Linux (even via Live USB) or report the issue on GitHub with Windows version and EC version details.",
      "category": "Hardware Wallets"
    },
    {
      "question": "Why does CashFusion on Android reject my correct wallet password?",
      "answer": "This is a reported bug where CashFusion on Android EC sometimes rejects the valid wallet password with 'password is not valid' error, even though it's the same password that unlocks the wallet. It doesn't happen with all wallets, only some. Workaround: File a bug report on GitHub with device model, Android version, EC version, and if possible, steps to reproduce. Include whether the wallet was created on Android or imported. This helps developers isolate the issue.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How do I fix EC AppImage menus not showing on Wayland?",
      "answer": "Run the AppImage with Wayland display disabled: `env -u WAYLAND_DISPLAY ./Electron-Cash-4.4.2-x86_64.AppImage`. This forces EC to use XWayland (X11 compatibility layer) instead of native Wayland. This fixes menu rendering issues on some Wayland compositors. The AppImage bundles Qt5 which has varying Wayland support. Not all users experience this issue - some run EC on Wayland without problems depending on compositor and configuration.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How do I fix tiny fonts in EC AppImage on 4K monitors?",
      "answer": "Set the Qt scale factor environment variable: `env QT_SCALE_FACTOR=2 ./Electron-Cash-4.4.2-x86_64.AppImage`. Adjust the number (1.5, 2, 2.5) based on your monitor's DPI and preference. For Wayland issues combined with scaling: `env -u WAYLAND_DISPLAY QT_SCALE_FACTOR=2 ./Electron-Cash-4.4.2.AppImage`. This is a Qt5 limitation - it doesn't have native high-DPI support like newer Qt6. Consider creating a desktop shortcut with these environment variables for convenience.",
      "category": "Configuration & Settings"
    },
    {
      "question": "What causes 'No module named pysatochip' error when installing EC from AUR?",
      "answer": "The AUR package might not have pysatochip as a dependency if you're trying to use a Satochip hardware wallet. Solutions: 1) Install pysatochip separately: `pip install pysatochip` or from AUR if available, 2) Use the AppImage which bundles all dependencies, 3) If not using Satochip hardware wallet, this shouldn't prevent EC from running - check if the error is fatal or just a warning. The AppImage avoids these dependency issues by including everything internally.",
      "category": "Installation & Setup"
    },
    {
      "question": "Should I use Windows for storing cryptocurrency?",
      "answer": "Security experts in the BCH community strongly recommend against using Windows for significant crypto holdings. Windows has more attack surface, telemetry, update issues, and security vulnerabilities. Linux provides better security through: open source verification, minimal bloat, better update model, stronger permission system. If you must use Windows: keep minimal funds in hot wallet, use hardware wallet, keep system fully updated, use dedicated machine. Consider Linux via dual-boot or Live USB for crypto operations. As community member says: 'don't expect your money to stay safe on Windows for long'.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What is Qt and why does it matter for Electron Cash?",
      "answer": "Qt is the GUI framework EC uses (via PyQt5). Qt determines: how windows render, menu appearance, font scaling, and platform compatibility. EC uses Qt5 (not Qt6 yet) which affects: 1) High-DPI support (needs manual QT_SCALE_FACTOR), 2) Wayland compatibility (varying success), 3) Native appearance on different OSes, 4) Available build options. Migration to Qt6 would require switching to PySide2 and extensive testing. The AppImage bundles specific Qt version, while running from source uses system Qt. Qt version mismatches cause many UI-related issues.",
      "category": "Development & Architecture"
    },
    {
      "question": "My KeepKey hardware wallet is not detected by Electron Cash - is there a fix?",
      "answer": "Yes, KeepKey detection has been fixed in EC's git master branch (as of April 2025) but isn't yet in an official release. Workarounds: 1) Use a pre-release build from https://ec.loping.net/ signed by ichundes (EC developer), 2) Wait for EC 4.4.3 or later official release, 3) Run EC from source using master branch. The issue affected Windows 11 particularly. Check GitHub issue #2995 for details. Always verify GPG signatures of any pre-release builds before using.",
      "category": "Hardware Wallets"
    },
    {
      "question": "Is CashFusion still operational in 2025?",
      "answer": "Yes, CashFusion is fully operational and actively used. The fusion servers are running and participants are fusing daily. Statistics available at https://fusionstats.redteam.cash/. CashFusion requires: 1) EC desktop (not available on mobile yet), 2) Plugin enabled in Tools > Plugins, 3) Minimum balance to participate in fusion rounds, 4) Patience as rounds fill up with participants. The protocol provides trustless mixing for improved privacy without custody risk.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What advantages would moving to Qt6 bring for Electron Cash?",
      "answer": "Key advantages: 1) Qt6 has prebuilt ARM wheels (Qt5 doesn't) making ARM AppImages feasible, 2) Better native high-DPI support without QT_SCALE_FACTOR hacks, 3) Improved Wayland compatibility, 4) Modern features and better performance, 5) Ubuntu planning to stop packaging Qt5 eventually. Challenges: Requires switching from PyQt5 to PySide2, extensive testing of all GUI components due to Python's dynamic typing, and maintainer time. GitHub issue #3053 tracks this migration discussion.",
      "category": "Development & Architecture"
    },
    {
      "question": "Why does EC mobile show 'invalid address' when scanning BitPay QR codes?",
      "answer": "BitPay changed their QR codes from simple address+amount format to URL-based format: `bitcoincash:?r=https://bitpay.com/i/xxxx`. Desktop EC supports these payment protocol URLs (fetches actual address from the URL), but EC mobile may not have implemented this BIP70/BIP72-style payment request feature yet. The merchant name and amount appear because they're in metadata, but the actual sending fails. Workaround: Use desktop EC to pay BitPay invoices, or wait for mobile update. Report as bug on GitHub for tracking.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What are the requirements for a CashToken to show BCMR metadata in Electron Cash?",
      "answer": "For your token's metadata to be resolvable in EC: 1) Register your token's BCMR (Bitcoin Cash Metadata Registry) JSON file according to the spec, 2) Have it indexed by Paytaca's BCMR indexer (EC's primary source), 3) For DNS-based resolution: publish BCMR at specific DNS location. The metadata JSON includes: token name, symbol, icon URLs, decimals, and other properties. EC fetches this data when user right-clicks token and selects 'Fetch Category Metadata' or 'Fetch NFT Metadata'. Not all BCMR spec features are supported yet (e.g., auth-chain following for updates).",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Does Qt5 support high DPI screens?",
      "answer": "Yes, Qt5 has decent HDPI support, but it requires explicit enabling in code. It's not automatic like Qt6. For EC users: set QT_SCALE_FACTOR environment variable manually. The issue is that Qt5 doesn't automatically detect and adjust for high-DPI screens, especially when combined with Wayland. Only in the last couple of years have frameworks started automatically handling this through cooperation with the graphics stack. EC's Qt5 dependency is one reason why high-DPI support requires manual configuration.",
      "category": "Development & Architecture"
    },
    {
      "question": "Does Electron Cash desktop already support offline transaction signing like Electrum?",
      "answer": "Yes, EC desktop fully supports offline transaction signing identical to Electrum. The workflow: 1) Create watch-only wallet on online computer using xpub, 2) Build unsigned transaction, 3) Save transaction (QR code or file), 4) Transfer to offline computer with full wallet (contains private keys), 5) Sign transaction offline, 6) Transfer signed transaction back to online computer, 7) Broadcast. You can manually select specific inputs by right-clicking coins in the Coins tab. This feature has existed in EC desktop 'forever'. The main gap is Android EC cannot save unsigned transactions to files (though it can sign transactions received as QR codes or raw text).",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why doesn't Electron Cash Android support creating raw transactions for cold storage workflows?",
      "answer": "EC Android has limited cold wallet functionality compared to desktop: 1) It CAN sign transactions received via QR code or raw text on offline device, 2) It CANNOT save unsigned transactions to files like Electrum Android can, 3) Screen size constraints make full feature parity with desktop infeasible. Workaround: Use EC desktop (watch-only wallet) to create and save unsigned transactions, then sign them on Android offline device. The feature gap exists because: mobile development resources are limited, and the codebase diverged from Electrum about 7 years ago (an eternity in software development), making porting features non-trivial.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does EC Android get stuck on 'generating your addresses' when offline?",
      "answer": "This issue can occur on older Android devices (Android 7 from 2018 reported). The address generation process itself doesn't require network connectivity - EC should generate initial 20 addresses and stop if it can't verify usage on blockchain. Possible causes: 1) Very slow processor on old device (though stuck for days is excessive), 2) Potential bug specific to older Android versions, 3) Device resource limitations. Testing confirms EC Android works offline in airplane mode on modern devices. If experiencing this: try latest EC version, test same device online first to isolate the issue, and report bug on GitHub with device model and Android version.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why did CashFusion break after updating EC from git master with protobuf error?",
      "answer": "Error 'ImportError: cannot import name runtime_version from google.protobuf' occurs when your installed protobuf version (e.g., 3.20.1) is incompatible with regenerated fusion_pb2.py files that require newer protobuf features. The master branch updated the protobuf .proto files and regenerated Python stubs. Fix: Reinstall dependencies to get the new required protobuf version. Check that protobuf version in requirements.txt matches what's installed in your virtual environment. The 'runtime_version' import was added in protobuf 5.x, so you need to upgrade from protobuf 3.x. This is why using a Python virtual environment is recommended - you can easily update dependencies without affecting system packages.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How does HD wallet address generation work with the gap limit?",
      "answer": "HD (Hierarchical Deterministic) wallets generate addresses sequentially from a master seed using BIP32 derivation. The 'gap limit' (default 20 in EC) determines when to stop generating new addresses: the wallet generates addresses until it finds 20 consecutive UNUSED addresses, then stops. Online: wallet queries blockchain to check which addresses have transaction history. Offline: without blockchain access, wallet cannot determine usage, so it just generates the initial 20 addresses and stops there. This is why offline wallets work fine - they don't need to search for used addresses, they just generate the base set. The gap limit prevents infinite address generation while ensuring you don't miss funds sent to addresses further down the derivation path.",
      "category": "Network & Architecture"
    },
    {
      "question": "How divergent are Electron Cash and Electrum codebases now?",
      "answer": "Very divergent - they split about 7 years ago (circa 2017-2018 when BCH forked from BTC). Electrum underwent massive refactoring since then, making it nearly impossible to port features or fixes between them. A developer attempted to port a performance fix and found the code so different they couldn't even determine if the fix was applicable. This means: 1) EC can't easily adopt Electrum's newer features, 2) Each codebase has evolved with different priorities (EC added CashTokens, CashFusion; Electrum added Lightning), 3) Security patches must be evaluated independently, 4) Android versions have different feature sets despite similar origins. Seven years is 'an eternity in software land'.",
      "category": "Development & Architecture"
    },
    {
      "question": "Why don't all BCH wallets properly display balance when CashToken change outputs contain both tokens and satoshis?",
      "answer": "When a transaction creates a change output containing both remaining tokens AND remaining satoshis (common with airdrop tools), some wallets fail to recognize the satoshis portion in their balance. EC was actually one of the few wallets that showed the change output, but even EC didn't list those satoshis in the normal balance or allow spending them via 'send max'. Fix: Send all tokens from that output back to yourself, which forces creation of a separate BCH-only output that wallets recognize. You may need to send yourself some satoshis first to cover the transaction fee. This is a wallet UI/accounting issue, not a protocol problem - the satoshis are safe on-chain.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Does Electron Cash mobile support hardware wallet connections?",
      "answer": "Currently, no. Hardware wallet support exists only in EC desktop (KeepKey, Trezor, Ledger, Satochip). Mobile hardware wallet integration faces challenges: 1) iOS restricts USB connections and would require air-gap or Bluetooth, 2) Android could potentially use USB OTG but implementation is complex, 3) Development resources are limited, 4) Each hardware wallet has different connection protocols. Users requesting this feature should: submit feature request on GitHub, understand it's a significant development effort, and for now use EC desktop for hardware wallet management. Some users manage hardware wallets on desktop and use mobile only for spending from hot wallets.",
      "category": "Hardware Wallets"
    },
    {
      "question": "Why do I get timeout errors when using CashFusion over Tor?",
      "answer": "Tor connection timeouts are completely normal and expected behavior. Tor routes traffic through multiple relays which introduces latency and connection failures. These errors don't indicate a problem with CashFusion itself. Solution: Just ignore the timeout errors and wait for successful fusions. EC will automatically retry connections. The timeouts are common whether using Tor for web browsing or other purposes. Your coins remain safe - failed fusion attempts don't affect your funds. Eventually fusions will succeed when connections stabilize.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "How long does it take to fuse large amounts like 100-800 BCH?",
      "answer": "Fusing large amounts can take considerable time depending on: 1) Current number of active fusion participants (low activity = slower), 2) How your funds are structured (one big UTXO vs many smaller ones), 3) Fusion mode selected. Real-world example: ~20 BCH fused per day with moderate activity, so 100 BCH could take 5+ days, 800 BCH potentially weeks. Speed improves over time as coins get split into fusion-friendly sizes. Key insight: Use 'Fan-out' mode for large consolidated UTXOs to split them up first, which dramatically speeds subsequent fusions. Fusion speed depends on matching with other participants in similar value tiers.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "When should I use CashFusion's 'Fan-out' mode vs 'Consolidate' mode?",
      "answer": "Choose based on your current UTXO structure: 1) Fan-out (Spread out): Use when you have large consolidated piles (e.g., one 700 BCH UTXO). This splits big UTXOs into many smaller ones, making them match more fusion tiers and dramatically speeding up the process. 2) Consolidate: Use when you have many tiny UTXOs that need combining. 3) Normal: Balanced approach for typical usage. All modes are equally safe security-wise - they just optimize for different UTXO structures. The fusion round counter is preserved when switching modes, so you won't lose progress. Tip: Switch modes if fusions are too slow - your coin structure probably needs adjustment.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What is Fusion Fridays and when are fusion participants most active?",
      "answer": "Fusion Fridays is a community initiative where BCH users focus on running CashFusion on Fridays to increase participant count and improve fusion speed. Higher participation means: more fusion rounds complete faster, better anonymity sets, shorter wait times. Activity varies with events (e.g., during conferences like BCH events in Slovenia, fewer people may be fusing). There's no guaranteed 'best time' but Fridays historically have higher activity. The community encourages running fusion clients 24/7 (similar to BitTorrent seeding) to provide consistent liquidity for everyone. Check fusionstats.redteam.cash for current activity levels.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What is the WalletConnect (WC) plugin for Electron Cash?",
      "answer": "The WalletConnect plugin (developed by OPReturn, funded via Flipstarter) allows EC desktop to connect with web3 BCH dApps like Cauldron DEX. It's currently in alpha stage. Features: scan QR code to connect EC to websites, approve transactions from dApps directly in EC, interact with CashTokens and DeFi protocols. Known issues: some users report crashes when approving transactions (likely threading-related bugs), repeated password prompts before crash. The plugin is actively developed with new versions coming. To use: enable in Tools > Plugins, scan WalletConnect QR from dApp website. This brings MetaMask-like functionality to BCH ecosystem.",
      "category": "Plugins & Extensions"
    },
    {
      "question": "Why does my BCMR token show 'no metadata available' in Electron Cash?",
      "answer": "EC fetches BCMR metadata primarily from Paytaca's indexer. If your token shows 'no BCMR data available': 1) Token's BCMR JSON file may not be properly registered according to BCMR spec, 2) Paytaca's indexer hasn't indexed it yet, 3) DNS-based resolution isn't configured correctly. Verification steps: check if token metadata appears on tokenexplorer.cash (if yes, indexer problem; if no, registration problem). Solutions: ensure BCMR JSON is published at correct location per spec, contact Paytaca about indexer inclusion, verify token was minted with proper genesis metadata. Not all tokens have BCMR metadata - it must be explicitly set up by the token creator.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Can I speed up CashFusion by acting as multiple participants?",
      "answer": "Yes! EC has an option to 'fuse as 2 players' which contributes multiple sets of inputs/outputs to fusion rounds. Benefits: helps rounds fill up faster, increases your chance of participating in rounds, contributes to overall fusion liquidity. This is especially useful when participant count is low. The option is in CashFusion settings. Note: you need sufficient wallet balance to act as multiple players since each 'player' contributes different coin tiers. This feature is similar to contributing extra seeders in BitTorrent - helps everyone while also helping yourself get faster fusions.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "How do I rescan transactions if my EC wallet is missing transaction history?",
      "answer": "EC provides two options: 1) 'Wallet -> Rebuild History...' - Deletes local history and re-downloads everything from Fulcrum servers. Use this if you see addresses in your Addresses tab but transactions are missing. 2) 'Wallet -> Scan more addresses...' - Extends the gap limit to search for addresses further down the derivation path. Use this if addresses aren't showing up at all. If 'Scan more addresses' times out, retry - it switches servers on timeout. Check Addresses tab first: if receiving address shows under 'Used' or change address under 'Empty', but transaction history is missing, use Rebuild History. If addresses themselves are missing, use Scan more addresses.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Is the BCH dust limit always 546 satoshis for every output?",
      "answer": "No! The commonly cited 546 sat limit is specifically for P2PKH outputs with 1000 sat/kb minimum relay fee. The actual dust limit varies based on: 1) Output script type - P2SH outputs have different sizes, 2) Token data - CashToken outputs include additional data making them larger, 3) Minimum relay fee rate. Dust limit is calculated as 3x the cost to spend the output (based on input size). For P2SH with tokens, the limit can be significantly higher than 546. EC had the 546 value hardcoded, but a PR was created to calculate actual dust limits dynamically. Reference: libauth.org/functions/getDustThreshold.html documents the calculation method clearly.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why do some CashFusion transactions not get labeled in my history?",
      "answer": "This is a known long-standing bug that hasn't been thoroughly investigated yet. About 90% of fusions are labeled correctly, but occasionally some aren't. Possible causes: 1) App crash during fusion (labels added locally on restart don't reflect fusion metadata), 2) Timing issue in label assignment. The fusion info IS in the transaction data - theoretically could be regenerated on wallet load by analyzing tx structure (multiple inputs/outputs matching fusion pattern). Feature request: auto-mark fusion transactions with CF icon based on transaction analysis rather than relying on stored labels. For now, you can manually identify fusion txs by their characteristic structure (many inputs and outputs of similar values).",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What is RPA (Reusable Payment Address) and how does it work in Electron Cash?",
      "answer": "RPA enables receiving payments privately without revealing a static address or requiring sender interaction. How it works: 1) Recipient provides RPA (derived from wallet's public key), 2) Sender uses RPA to derive unique payment destination that only recipient can find, 3) Recipient scans blockchain for transactions to their RPA-derived addresses. Current EC implementation: Requires separate wallet type (not integrated into standard HD wallets yet), doesn't use change addresses (sends change back to same address like Cashonize), derives only a few keys from the seed. Limitations: Can't be used with hardware wallets (yet), not compatible with CashFusion (no change addresses). Future: Calin plans to integrate RPA as a feature of standard wallets rather than separate wallet type.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "How do I back up an RPA wallet in Electron Cash?",
      "answer": "RPA wallets use seed words and are backed up the same way as standard HD wallets. Despite EC's RPA wallet having some limitations (no change addresses, limited key derivation), it still uses a BIP39-style seed phrase for recovery. When creating an RPA wallet, you'll receive 12/24 word seed phrase - write it down securely. Important: Using the same seed for both a hardware wallet and RPA wallet creates privacy linkage between them (same pubkey exposed). Ideally RPA should use a separate derivation path to avoid this correlation, which may be addressed in future EC versions. For now, use dedicated seed for RPA wallet if privacy is critical.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Is Electron Cash technically an SPV wallet?",
      "answer": "EC is described as 'RPC/SPV' wallet. It uses SPV (Simple Payment Verification) in that it performs merkle proof verification of transactions without downloading the full blockchain. However, purists note it doesn't connect directly to Bitcoin Cash nodes - instead it connects to Fulcrum servers which then connect to nodes. This two-step separation: 1) Improves scaling and performance (Fulcrum optimized for address queries), 2) Can enhance privacy (your IP separated from nodes), 3) Enables features like address indexing that nodes don't provide natively. You can run your own Fulcrum server connected to your own node for maximum trustlessness. The architecture is inherited from Electrum (BTC) and wasn't changed when EC forked.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why can't I mix private keys and watch-only addresses in a single EC wallet?",
      "answer": "This is a current limitation of EC's wallet architecture. You cannot have a wallet file that contains both: 1) Addresses with private keys you control, and 2) Watch-only addresses (addresses you monitor but don't control). This 'seemingly arbitrary limit' is inherited from EC's wallet model where a wallet is either fully controlled (has all private keys) or entirely watch-only. Workaround: Create separate wallet files - one with your controlled keys, another watch-only for monitoring external addresses. This limitation affects some advanced use cases like coin control workflows where you want to track external UTXOs alongside your own. May be addressed in future wallet architecture updates.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "What is the bandwidth cost of using RPA (Reusable Payment Addresses)?",
      "answer": "RPA requires constantly scanning every new block for potential payments. However, BCH's RPA implementation is optimized: instead of downloading full blocks (like BTC's stealth addresses), it only downloads transactions matching your prefix. With EC's prefix size, this is less than 1% of all transactions. Trade-off: As blockchain usage grows, download requirements grow proportionally (1% of 1GB blocks is still 10MB). Compare to traditional SPV with merkle proofs: download size stays constant regardless of block size. The scanning is a small price to pay for privacy in exchange scenarios, but it's why RPA wallets need to be running more frequently than standard wallets.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What's the difference between Bloom filters and RPA for privacy?",
      "answer": "They serve different purposes: 1) Bloom filters: Privacy technique for querying blockchain without revealing exact addresses. You share hash patterns (with false positives for privacy) to nodes, which return matching transactions. Connect to thousands of nodes for privacy. 2) RPA (Stealth Addresses): Enables receiving payments without revealing a static address publicly. Sender derives unique destination that only you can find. These aren't directly comparable - bloom filters improve query privacy for standard HD wallets, while RPA provides completely different functionality (non-interactive private receiving). You don't need RPA for privacy if you use HD wallets with unique addresses per payment. RPA shines specifically when you can't interact with the sender to provide fresh addresses.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What are the best use cases for RPA/stealth addresses?",
      "answer": "RPA excels in non-interactive payment scenarios: 1) Donations: Public QR code where anyone can send privately, 2) Subscription services: Customer saves one address, tops up anytime without requesting new addresses, 3) Software sales: Single paycode for all buyers - they paste txid to verify payment, 4) Recurring payments: No 'this address expires in 2 hours' warnings, 5) Account top-ups: Services assign one RPA per customer. NOT ideal for: Regular business transactions where buyer/seller interact (just use unique invoice addresses), exchanges (need to track deposits precisely), any scenario requiring sender identification. RPA simplifies backend (no address generation system needed) but adds blockchain scanning overhead.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Why don't Bitcoin Cash nodes serve SPV proofs directly?",
      "answer": "Current BCH node p2p protocol limitations: 1) No direct txid->SPV proof query - you can't ask 'give me merkle proof for txid X', 2) 'getdata' only returns mempool/unspent transactions, not arbitrary historical ones (unless txindex enabled), 3) merkleblock (BIP-37) returns filtered transactions+proofs but requires bloom filter setup first. This is why SPV wallets must use intermediary services: either Electrum protocol (via Fulcrum servers) which provides convenient merkle proof API, or implement full BIP-37 bloom filter workflow. Alternative: BIP-157 (neutrino/compact block filters) but not implemented in BCHN. Result: EC's Fulcrum dependency isn't a design choice but a practical necessity given current node capabilities.",
      "category": "Network & Architecture"
    },
    {
      "question": "What advantages does Electrum protocol provide over direct node connections?",
      "answer": "Electrum protocol (what Fulcrum implements) offers features nodes don't: 1) Merkle roots/proofs over headers - clients can store just root + minimal tip instead of entire header chain, 2) Address-based transaction queries - nodes can't query 'all transactions for address X', 3) Convenient SPV proof API - single call to get merkle proof for txid, 4) Header chain pruning support - verify once, store root, discard headers. For light clients wanting minimal trust: download header chain, verify it, compute trusted root, then discard headers. Future ideas: add header root/proof messages to node p2p protocol, service discovery so nodes can advertise if they run Fulcrum alongside. Currently, any SPV verification requires Electrum protocol.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why haven't exchanges adopted CashAddr format yet?",
      "answer": "Despite CashAddr being standard since 2018, many exchanges still only support legacy (Base58/BTC-compatible) addresses. Reasons: 1) Low priority - BCH is small market cap coin for them, 2) Development resources allocated elsewhere, 3) Legacy addresses still work (wallets auto-convert), 4) No strong business incentive to update. This affects RPA/stealth address adoption prospects - if exchanges won't even support basic CashAddr, expecting them to implement complex stealth address infrastructure is unrealistic. Community expectation: adoption will follow market cap growth. When BCH reaches top 5-10, exchanges will prioritize BCH features. Until then, advanced features like RPA will remain wallet-to-wallet primarily.",
      "category": "Community & Resources"
    },
    {
      "question": "What is the Point-of-Sale (POS) gap in the Bitcoin Cash ecosystem?",
      "answer": "The BCH ecosystem lacks a well-developed point-of-sale system for HD wallets. Ideal POS requirements: 1) Open source for trust and customization, 2) Easy to deploy (no complex server setup), 3) Native app (not browser-based for performance), 4) Multi-platform: desktop, tablet, mobile, 5) HD wallet support (unique address per transaction), 6) Invoice generation with QR codes, 7) Payment detection and confirmation. Current solutions are fragmented - some browser-based, some closed source, some require server infrastructure. This remains a 'sore point' that RPA could partially address (static QR codes), but a proper POS solution with HD support is still needed for retail adoption.",
      "category": "Community & Resources"
    },
    {
      "question": "How much storage does downloading all blockchain headers require for SPV wallets?",
      "answer": "Approximately 4MB per year of blockchain history. For context: BCH has been running since 2009, so total header storage is ~64MB (16 years x 4MB). This is trivial on modern devices - most smartphone cameras take single photos larger than 4MB. Even downloading, parsing, and storing all headers from genesis to tip is orders of magnitude cheaper than watching one minute of YouTube. Mobile phones with 64GB+ storage don't notice this. SPV clients can also prune older headers once verified, keeping only recent 1000 headers plus a verified merkle root. This makes light wallet operation extremely efficient compared to full node requirements.",
      "category": "Network & Architecture"
    },
    {
      "question": "What does 'Freeze' mean for addresses or coins in Electron Cash?",
      "answer": "Freezing prevents automatic selection when sending transactions. Key points: 1) Frozen addresses/coins won't be used as inputs when you send BCH, 2) It does NOT prevent others from sending TO that address - funds can still be received, 3) Only prevents the coins from being spent unintentionally, 4) Useful for coin control - separating funds for different purposes, 5) You can still manually select frozen coins if needed. Use cases: segregating business vs personal funds, keeping specific UTXOs for token operations, preventing accidental spending of labeled coins. Remember: freeze is local wallet setting, not blockchain-level lock.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Does CashFusion work with wallets that contain CashTokens?",
      "answer": "Yes, but tokens are automatically excluded from fusion. How it works: 1) CashFusion scans wallet for eligible UTXOs, 2) Any UTXO containing tokens (fungible or NFT) is automatically skipped, 3) Only BCH-only UTXOs participate in fusion rounds, 4) Token UTXOs stay frozen during fusion process, 5) The satoshis locked with tokens also don't get fused. This is by design - tokens require special transaction handling and can't be mixed in standard fusion protocols. If you need to fuse BCH locked with tokens, first move tokens to a separate output, then the freed BCH becomes fusable. Your tokens remain safe on their original addresses.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Why is the Electron Cash iOS app experiencing bugs on newer iPhones?",
      "answer": "The iOS app hasn't been updated in approximately 3 years. Issues reported: FaceID setting doesn't persist (resets on app restart) on iPhone 15 Pro with iOS 17.7.2. Root causes: 1) iOS API changes over three years not reflected in app, 2) Apple's walled garden makes updates difficult (requires Mac hardware, paid developer account), 3) Limited iOS development resources in EC community. Workarounds: try PIN-only authentication, update to latest iOS version (may fix compatibility), or use alternative wallets. One developer attempted to build from Hackintosh VM but Apple's server detected non-authentic hardware. The iOS ecosystem's closed nature is a significant barrier to open source wallet development.",
      "category": "Installation & Setup"
    },
    {
      "question": "How would a change to BCH block time target affect Electron Cash?",
      "answer": "EC would need code modifications to SPV proof checking, but it wouldn't be a huge project. Key impacts: 1) Header verification timing assumptions would need updating, 2) Difficulty adjustment algorithm references need modification, 3) With faster blocks, can still prune headers - store only 1k recent headers plus verified merkle root. Good news: EC already uses header merkle roots/proofs, so even with 1-minute blocks (vs current 10-minute), storage remains minimal. The full node software changes are more involved than wallet changes. EC has proven adaptable - it survived the BCH fork from BTC and subsequent consensus changes.",
      "category": "Development & Architecture"
    },
    {
      "question": "Why is there a python-dateutil version requirement (<2.9) in EC and how does it cause packaging issues?",
      "answer": "EC's requirements.txt specifies python-dateutil less than 2.9, causing conflicts with newer Linux distributions (like Fedora rawhide shipping 2.9.0). The library is only used in electroncash/paymentrequest.py for date parsing. History: A higher version likely broke something in the past, prompting the version cap. Issue: Distribution packagers can't include EC when system dateutil exceeds 2.9. Solutions being explored: 1) Test with newer dateutil to see if original issue is resolved, 2) Remove dateutil dependency entirely (Electrum BTC doesn't use it), 3) Update code to work with newer versions. This exemplifies challenges of maintaining cross-distribution compatibility with pinned dependencies.",
      "category": "Development & Architecture"
    },
    {
      "question": "What corporate or business use cases benefit from stealth/RPA addresses?",
      "answer": "Primary corporate benefit: Financial privacy from competitors and public. Use cases: 1) Paying invoices privately - competitors can't see resource allocation, 2) Receiving payments without exposing revenue in real-time, 3) Quarterly reporting vs forced transparency - choose when to disclose financials, 4) Payroll privacy - employees' salaries not publicly visible, 5) Subscription billing - one stealth address per customer prevents cross-customer data leakage. Non-public companies especially benefit - they don't want general public or competitors analyzing their blockchain activity. Stealth addresses enable corporate BCH adoption while maintaining traditional financial privacy expectations businesses are accustomed to.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Why do businesses need unique invoice addresses instead of RPA for most transactions?",
      "answer": "Accounting and reporting requirements favor invoicing model: 1) 'Issue invoice, receive payment' matches standard accounting practices, 2) HD wallets with unique addresses per invoice solve 'who paid what' tracking, 3) Exchange rates require specific BCH amounts per transaction, 4) Auditing requires clear payment trails internally, 5) Monthly bills have varying amounts (usage-based, exchange rate fluctuations). RPA excels only when: no prior interaction possible (public donations), or backend simplification (no address generation system) outweighs scanning overhead. For standard B2B/B2C transactions with communication channels, unique invoice addresses provide same privacy benefits without RPA complexity. KISS principle applies: use simplest solution that meets requirements.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Does CashFusion work on iOS Electron Cash?",
      "answer": "No, iOS EC does not implement CashFusion and there are no current plans to add it. Primary reason: iOS doesn't support apps running continuously in the background, which CashFusion requires. The UX would be poor since you'd need to keep the app open constantly for fusion rounds. Alternative: Stack Wallet on iOS supports CashFusion but also requires keeping the app open. For best fusion experience, use desktop EC running 24/7 on a computer while using mobile wallet for spending. You can run the same seed on both - desktop handles fusions while mobile handles transactions.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Can I run CashFusion on desktop while using the same wallet on mobile?",
      "answer": "Yes, this works well. Setup: 1) Use same seed phrase on both desktop EC and mobile EC, 2) Enable CashFusion on desktop with Tor running, 3) Keep desktop running 24/7 (many users run BCH nodes on same machine anyway), 4) Use mobile for everyday transactions. The desktop will continuously fuse coins in background while mobile wallet reflects the fused balance. Both instances sync with same Fulcrum servers so balance stays consistent. This is a popular setup for iOS users since iOS EC lacks native fusion support.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Why does Electron Cash sync so much faster than other BCH wallets?",
      "answer": "EC's architecture uses Fulcrum servers (Electrum protocol servers) that maintain pre-indexed databases of all BCH transactions. When wallet comes online: 1) Downloads new block headers (small, fast), 2) Queries server with address list, 3) Server uses its index to return only relevant transactions for that wallet. Other wallets (Stack, Cake) may use different sync methods requiring more blockchain scanning. Key optimization: BCH ecosystem (EC, Fulcrum, BCHN) has been continuously developed for fast, efficient, scalable performance. Fulcrum's address-based indexing is the main speed advantage - you only download data relevant to your specific wallet.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why is Electron Cash having libsecp256k1 issues on Fedora?",
      "answer": "Fedora changed their libsecp256k1 package upstream to Bitcoin Core version and created separate libsecp256k1-abc for Bitcoin ABC version. Problem: Both packages use the same shared library name (.so file), making them mutually exclusive - can't install both simultaneously. EC requires the ABC version (with Schnorr signatures), but if you have Electrum (BTC) installed, it needs Core version, causing conflicts. Solutions: 1) Use EC AppImage (bundles its own libsecp256k1), 2) Set up LD_LIBRARY_PATH for private lib, 3) Contribute fix as PR if you have Linux dev skills. The AppImage bypasses system package conflicts entirely.",
      "category": "Installation & Setup"
    },
    {
      "question": "Why does my antivirus block Electron Cash as malware?",
      "answer": "This is a common false positive with crypto wallet software. Antivirus programs (Avast, Norton, etc.) flag legitimate crypto apps because: 1) Stealth mining trojans use similar open source code, 2) Wallet-stealing malware triggers pattern matches, 3) Crypto operations look suspicious to heuristic scanners. EC is safe if downloaded from official source (electroncash.org). Verification steps: 1) Download ONLY from electroncash.org, 2) Verify GPG signatures or SHA256 checksums against published values, 3) Add exception in antivirus for the program, 4) Consider using Linux to avoid such issues entirely. Never download EC from random links in DMs or unofficial sources.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Can I recover a password-protected Electron Cash wallet file if I forgot the password?",
      "answer": "Unfortunately, no easy solution exists. If you have encrypted wallet file but forgot password: 1) EC cannot help you bypass password - that would defeat security purpose, 2) Try common passwords you've used, write them down as you test, 3) Check if you wrote password down somewhere in 2018-2019, 4) The wallet file SHOULD have had a seed phrase backup at creation - search for 12/24 word phrase, 5) Seed phrase can restore wallet without password. The encrypted file contains private keys but they're AES-encrypted with your password. Password cracking is theoretically possible but extremely slow without specialized tools. Lesson: Always backup both seed phrase AND remember/secure your password.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Can Electron Cash open Electrum (BTC) wallet files?",
      "answer": "Uncertain - it may or may not work due to codebase divergence. EC and Electrum split 7+ years ago and developed differently. Potential issues: 1) Different wallet file format versions, 2) Different derivation paths (BTC vs BCH), 3) Different encryption implementations possibly. If password-protected file opens in EC and prompts for password, the format might be compatible. After decryption, you could export private keys. Important: Even if file opens, addresses will show BCH amounts, not BTC. If you had BTC in 2018, you'll need to open in current Electrum for BTC, and separately in EC for BCH (if it existed on those addresses during 2017 fork).",
      "category": "Wallets & User Experience"
    },
    {
      "question": "What's the proper way to restore a wallet file versus a seed phrase in EC?",
      "answer": "Two different restoration methods: 1) Wallet File: File -> Open, browse to .wallet file. If encrypted, enter password. The file contains complete wallet data including labels, addresses, transaction history. 2) Seed Phrase: File -> New/Restore, choose 'I have a seed', enter 12/24 words. Recreates wallet from scratch by deriving keys. DON'T open wallet file in text editor and paste contents - that's the encrypted JSON/binary data, not useful as text. Seed phrases are your ultimate backup - they regenerate everything. Wallet files are convenience backups that preserve metadata but require password if encrypted.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does my balance show incorrectly in some wallets after using CashFusion?",
      "answer": "This is typically a gap limit issue. CashFusion creates many outputs across different derivation paths. When you import the same seed into other wallets (Paytaca, Stack, etc.), they may have smaller gap limits (default 20) and stop scanning before finding all your fused UTXOs. EC handles this well because: 1) It tracks addresses used during fusion, 2) Has better gap limit management, 3) Was designed with fusion in mind. Selene wallet (no fusion support) also shows correct balance because it may scan more addresses. Fix: In other wallets, increase gap limit or use 'scan more addresses' feature. Sending all UTXOs back to yourself consolidates them into addresses the wallet expects to find.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Why is CashFusion icon missing when I build Electron Cash from source?",
      "answer": "If you built EC from source but CashFusion icon doesn't appear in the bottom status bar, you likely didn't install the plugin correctly or missed dependencies. The CashFusion plugin needs specific setup when running from source: 1) Ensure all dependencies in requirements.txt are installed (especially protobuf), 2) CashFusion is a plugin that must be enabled, 3) Check Tools > Plugins to see if it's available. The AppImage version includes everything pre-configured with proper plugin setup. If building from source, follow the complete build instructions including plugin dependencies. Quick workaround: Use official AppImage which bundles fusion plugin correctly.",
      "category": "Installation & Setup"
    },
    {
      "question": "How does coinbase maturity affect spending newly mined coins?",
      "answer": "Coinbase outputs (block rewards including both subsidy and transaction fees) have a mandatory maturity period before they can be spent. This was coded by Satoshi: blockchain enforces 100 confirmations minimum, while original client required 120 confirmations for extra safety margin. Transaction shows 'mined in block X' but remains unspendable until maturity reached (~100-120 blocks = 16-20 hours on BCH). This prevents issues if the block gets orphaned in a reorg - premature spending of coins that might disappear causes bigger problems. Applies to entire coinbase output, not just subsidy. Mining pools wait for this reason before paying out.",
      "category": "Network & Architecture"
    },
    {
      "question": "What are Cash Accounts and should I still use them?",
      "answer": "Cash Accounts is an older BCH protocol for human-readable payment addresses (like email addresses for crypto). How it works: Register name on-chain with block height tag (e.g., 'Donations#12345') plus emoji checksum to prevent squatting. Purpose: Memorable addresses instead of long hex strings. Current status: Somewhat deprecated - requires trusted indexer servers for lookups. Better alternatives: 1) BCMR (Bitcoin Cash Metadata Registries) provides similar identity features with SPV-verifiable proofs and decentralized hosting, 2) RPA for privacy-focused donations. Community recommendation: Let Cash Accounts 'gently die' in favor of BCMR which is more trustless. For simple donation addresses, just use standard BCH address with description label.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "What is the privacy trade-off between fixed donation addresses vs RPA?",
      "answer": "Fixed address donations: Anyone can see total donations received, timing, amounts, and potentially donor identities (unless they used CashFusion). Your donation history becomes public. RPA donations: Each payment goes to unique derived address only you can find - public sees random-looking addresses, can't connect donations to you or track totals. Only you know donor amounts. Major limitation: Only EC desktop currently supports sending TO RPA addresses. Donors need compatible wallet. For maximum reach: Use fixed address (simple, all wallets support). For privacy: Use RPA (limited support, more complex). Middle ground: Fixed address + ask donors to use CashFusion first.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What's the difference between Electrum and Electron Cash wallet files?",
      "answer": "They use similar but not identical formats since they forked 7+ years ago. Key differences: 1) Created for different blockchains (BTC vs BCH), 2) May have incompatible encryption or serialization versions, 3) Address derivation paths may differ. Cross-compatibility: Sometimes EC can open Electrum files if encryption is similar, but it's not guaranteed. If you have 2018 wallet: Open in Electrum (BTC) first, decrypt, export seed phrase or private keys, then use those to create new wallet in EC for BCH access. Remember: Post-2017-fork Electrum wallet likely has no BCH (created after split). Pre-fork keys could have both BTC and BCH from before split.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does Android EC require a separate Tor app for CashFusion?",
      "answer": "Android EC doesn't bundle Tor internally like desktop version. Technical reasons: 1) Android app sandboxing makes embedding Tor complex, 2) Code size and maintenance overhead, 3) Different platform constraints. Setup: Install Orbot (official Tor app for Android) separately, configure EC to use it as proxy. The fusion protocol itself works fine on Android once Tor connection is established through external app. Alternative for iOS: iOS EC has no fusion at all (not just Tor issue) due to background process restrictions. For best fusion experience: Use desktop EC which bundles Tor seamlessly and runs 24/7 easily.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "How do I convert BCH from Electron Cash to my bank account?",
      "answer": "EC is a non-custodial wallet - it doesn't handle fiat conversion. Process: 1) Create account on exchange (Coinbase, Kraken, Binance, etc.), 2) Complete KYC verification, 3) Get deposit address from exchange for BCH, 4) Send BCH from EC to that deposit address, 5) Wait for confirmations (varies by exchange), 6) Sell BCH for fiat on exchange, 7) Withdraw fiat to bank account. Important: Exchanges have withdrawal limits, fees, and processing times. Alternative: Peer-to-peer sales (LocalBitcoin.cash, etc.) for more privacy but more risk. EC just holds and sends BCH - all fiat conversion happens on external services.",
      "category": "Community & Resources"
    },
    {
      "question": "How do I know when my coins have been fused in CashFusion?",
      "answer": "Check your transaction history - fusion transactions appear with CF label/icon. The Coins tab shows which UTXOs came directly from fusion transactions. EC provides 'only spend fused coins' option in settings to prevent accidentally spending unfused coins. On desktop, right-click the CF icon to open progress dialog showing current fusion status. Each completed fusion is a separate transaction visible in history. Important: Multiple fusion rounds increase privacy - first fusion breaks direct link, subsequent rounds add more anonymity layers. The number of fusion rounds can be configured in CF settings. More rounds = better privacy but more fees consumed.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Which coins does CashFusion automatically exclude from fusing?",
      "answer": "CF excludes several UTXO types: 1) Coins on addresses with more than 3 UTXOs (anti-spam measure, though debated), 2) UTXOs containing CashTokens (tokens require special handling), 3) Coins on manually frozen addresses/UTXOs (except CF's temporary freezes during rounds), 4) Very small UTXOs below minimum fusion threshold. To exclude specific coins: use Freeze feature on addresses or individual UTXOs. To include excluded coins: unfreeze them or adjust settings. Note: You can't fuse single-input coins effectively - fusion requires multiple inputs from your wallet to obscure which outputs belong to which inputs. Single input = outputs can still be correlated.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What are Double Spend Proofs (DSP) and how does EC use them?",
      "answer": "DSProofs are cryptographic evidence that someone attempted to double-spend a transaction. How they work: When conflicting transactions (spending same UTXO) appear on network, nodes can construct proof using signatures from both. Fulcrum queries nodes for DSPs and provides them to wallets on request. EC can display DSP alerts for incoming transactions. Current status: Implementation exists but adoption is limited - most merchants don't see fraud because it's rare with first-seen rule. Practical value: Improves 0-conf reliability by detecting attacks in near real-time. Services like SideShift use DSPs. Not perfect security (probabilistic system), but adds valuable safety layer for unconfirmed transactions.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What are the trade-offs of reducing BCH block time from 10 minutes to 1 minute?",
      "answer": "Benefits: Faster first confirmation (~1 min vs 10 min), better UX for transactions ineligible for DSP (DeFi contracts, anyone-can-spend scripts), more responsive network. Costs: 1) 10x more block headers to validate and store (more overhead for SPV clients), 2) Higher orphan rates due to propagation delays, 3) Significant retooling required across ecosystem (wallets, nodes, services), 4) More frequent difficulty adjustments needed, 5) Coinbase maturity period (100 blocks) becomes 100 minutes vs 1000 minutes. Key debate: DSPs + first-seen rule already secure most 0-conf transactions, so faster blocks mainly help edge cases. KISS principle: Some argue improving DSP coverage is simpler than changing fundamental block timing.",
      "category": "Network & Architecture"
    },
    {
      "question": "What is Fulcrum and why is it important for BCH ecosystem?",
      "answer": "Fulcrum is high-performance Electrum protocol server developed by Calin Culianu. Role: Maintains indexed database of all BCH transactions, provides fast address-based queries to SPV clients. Why important: 1) Powers Electron Cash's fast sync and balance queries, 2) Enables SPV proof verification, 3) Provides DSProof data to wallets, 4) Serves as infrastructure for many BCH services beyond EC, 5) Optimized for scalability (handles large blocks efficiently). You can run your own Fulcrum connected to your node for maximum trustlessness. Public Fulcrum servers handle most user connections. It's the 'engine behind the scenes' that makes light wallet experience smooth compared to direct node connections.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why might hardware wallets be riskier than software wallets?",
      "answer": "Supply chain attack risks: 1) Wallets intercepted and modified during shipping, 2) Retail distribution tampering (resealed devices with compromised firmware), 3) Trust in manufacturer's security practices, 4) Physical device can be counterfeited. Real cases: $6.9M stolen from pre-compromised hardware wallets sold on TikTok - seeds were known to attackers before buyers received devices. Additional concerns: Proprietary closed-source firmware in many devices, limited ability to verify hardware hasn't been modified. Alternative: Software wallets on airgapped devices you control (old laptop running Linux offline), or EC's offline signing workflow with your own hardware. Key principle: You're trusting multiple parties in hardware wallet supply chain vs. verifiable open-source software.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How does zero-conf security work with first-seen rule?",
      "answer": "First-seen rule: Full nodes accept first valid transaction spending a UTXO and reject subsequent attempts. Network propagation ensures most nodes have same 'first' transaction. Why it's secure: 1) Miners generally follow first-seen (they receive transactions from honest nodes), 2) DSProofs alert recipients if double-spend attempted, 3) Merchants running nodes can verify their transaction propagated widely. Important insight: Security improves with adoption - more merchants running nodes means more enforcement of first-seen rule. Volunteers and merchants have strong incentive to maintain rule. Not perfect (probabilistic system), but practical security is high for typical retail transactions. Critical: Works only for standard transactions - anyone-can-spend scripts or complex DeFi operations may not be eligible.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What is BCMR and how does it compare to Cash Accounts?",
      "answer": "BCMR (Bitcoin Cash Metadata Registries) is newer protocol for on-chain identity and metadata. Advantages over Cash Accounts: 1) SPV-verifiable proofs make it trustless, 2) Can be hosted on your own server or sent in payment requests, 3) More flexible - supports personal and corporate identities, 4) Works for tokens and other use cases beyond payment addresses. Cash Accounts limitations: Requires trusted indexer server for lookups (centralizing element), on-chain registration with block height tags, primarily proof-of-concept. Community direction: BCMR is preferred path forward though JSON spec is currently over-designed and mainly used for tokens. Both aim to solve human-readable addresses, but BCMR has better trust model and extensibility.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "What's the difference between dumb NFC cards and smart cards for crypto storage?",
      "answer": "Two very different security models: 1) Dumb NFC cards: Just hold data (your seed phrase). No code, can't sign transactions, simply store information. The wallet software reads the seed phrase to derive keys. 2) Smart cards (Tangem, etc.): Have embedded firmware that signs transactions. Keys never leave the card - you tap the card to authorize each transaction. Important distinction: Dumb cards require wallet software to handle signing (keys in memory briefly), while smart cards do signing on-device but require trusting embedded firmware. Neither eliminates need for trusted software somewhere - it just moves the trust boundary. Some prefer dumb cards because less attack surface (no executable code on card).",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why do some experts recommend de-googled phones over hardware wallets?",
      "answer": "Several advantages: 1) Full control - you install the OS (LineageOS, GrapheneOS), apps are open source and auditable, 2) No supply chain risk - you buy generic phone from anywhere, 3) Familiar platform - standard Android apps work including EC, 4) Lower cost than dedicated hardware wallets, 5) Can run in airplane mode as airgapped device. Downsides: Larger attack surface than purpose-built device, requires technical knowledge to set up properly. Key insight: Hardware wallets have hidden complexities (firmware updates, driver requirements, manufacturer trust), while phones are well-understood attack surfaces. Best practice: Old de-googled phone running only EC, permanently offline for cold storage.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why are hardware wallet firmware updates a security concern?",
      "answer": "Several issues: 1) Continuous updates required - defeats purpose of 'cold' storage (must go online to update), 2) Each update is potential attack vector - one malicious update could steal funds, 3) Closed-source firmware common - you can't verify what code is running, 4) Driver updates also needed - more moving parts with trust requirements. Community perspective: 'If I have to continuously update firmware, it's not really cold storage anymore.' Alternative approach: Software wallet on device you control, with verifiable open-source code. Paper or steel backups are truly cold (no code to update). BTC-only firmware helps but still requires updates. Complex multi-coin firmware is highest risk due to large attack surface.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Does Electron Cash support QR codes for CashToken addresses?",
      "answer": "Currently no - EC doesn't have built-in option to generate QR codes for token-aware address format (prefixed with 'bitcoincash:z' instead of 'bitcoincash:q'). Important clarification: Token addresses and regular addresses are the SAME underlying address, just displayed differently. The 'z' prefix indicates to wallets that this address can receive tokens. If you send tokens to regular QR code (q-prefix), they still arrive at same address and EC will see them fine. For other wallets, they should also find the tokens since it's same key derivation. Workaround: Use external QR code generator with your token address string. GitHub issue #3096 tracks this feature request. Not many users have needed it yet.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "What happens if BCH implements 1-minute blocks and exchanges respond?",
      "answer": "Exchanges will likely increase confirmation requirements by 10x to maintain same security level (same cumulative proof-of-work). Current 6-conf requirement becomes 60-conf requirement. Result: No actual speed improvement for exchange deposits. Potential problems: 1) Some exchanges may forget to update settings (temporary faster deposits until they notice), 2) Block reward comparisons to BTC become confusing (0.1x per block), 3) Marketing becomes harder ('our blocks are faster but also worth less'). The 'benefit' relies on businesses not understanding the change or legacy systems with hardcoded confirmation counts. Ironic outcome: Main practical benefit is psychological (seeing confirmations tick faster) not actual faster finality for services requiring confirmations.",
      "category": "Network & Architecture"
    },
    {
      "question": "How do 1-minute blocks affect SPV wallets like Electron Cash?",
      "answer": "SPV clients download block headers to verify proof-of-work chain. With 1-minute blocks: Headers grow 10x faster - instead of ~4MB/year, now ~40MB/year. Impact: 1) Initial sync takes longer (download all historical headers), 2) Storage requirements increase for light wallets, 3) More bandwidth used for ongoing sync. For full nodes: Minimal impact since transaction data dominates storage. Headers are small (80 bytes each), but 10x more adds up over years. EC already handles header pruning (store only recent 1000 + verified merkle root), but this becomes more important with faster blocks. Trade-off is real but not catastrophic - modern phones handle it fine.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why is open source vs closed source more important than hardware vs software for security?",
      "answer": "Expert perspective from long-time engineers: Open source allows verification - you can read code, audit for backdoors, understand exactly what happens. Closed source requires trust in unknown parties. Hardware wallet problem: Even if open source, hardware is hard to verify (is this the actual firmware? was it modified in shipping?). Software on general-purpose hardware: Easier to verify - you can hash binaries, compile from source, audit changes. Trezor issues: Not hardware itself, but software complexity from supporting many altcoins. Large codebase = more bugs, harder to audit, more attack surface. Recommendation: Simple open-source software (EC) on hardware you control (de-googled phone, airgapped laptop) often provides better security model than complex proprietary hardware wallet.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What are the arguments against changing BCH block time to 1 minute?",
      "answer": "Multiple downsides identified by community: 1) SPV clients need 10x more header storage, 2) Higher orphan rates from network propagation delays, 3) Exchanges just increase confirmation requirements (no real speed gain), 4) Erodes Bitcoin heritage - block rewards no longer comparable to BTC, 5) Makes BCH harder to explain/market, 6) Massive ecosystem retooling required, 7) Doesn't actually solve DeFi MEV problems (bots adapt to faster blocks), 8) Psychological comfort only - first confirmation feels faster but same PoW security. Counter-argument: DeFi benefits from lower variance and faster state updates. Community consensus: Need extensive benchmarking (orphan rates with 32MB blocks at 1-min intervals) before any decision. KISS principle applies - don't change fundamentals without clear overwhelming benefit.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why do smart contracts need block confirmations when payments work with zero-conf?",
      "answer": "Smart contracts can have competing unconfirmed transaction chains in the mempool. Example: AMM DeFi where multiple users interact with same contract UTXO simultaneously. Problem: Until next block, it's uncertain which transaction chain becomes valid. If user builds transaction on 'wrong' unconfirmed chain, their transaction gets cancelled when block confirms different chain. This requires waiting for state reconciliation - average 10 minutes with current block time, outlier cases up to 1.5 hours. Regular payments don't have this issue because they spend from user's own UTXOs with no competition. This is key argument for faster blocks (1-minute) - reduces wait time for DeFi state updates.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why would 1-minute blocks help with large block scalability?",
      "answer": "Counter-intuitive benefit: Smaller, more frequent blocks are easier to process than infrequent large blocks. With current 10-minute target, scaling to 1GB blocks means processing 1GB every 10 minutes in one burst. With 1-minute blocks, same throughput splits into 100MB blocks every minute - steadier processing load, better for network propagation, smoother resource utilization. Mining nodes handle continuous smaller workloads better than periodic massive ones. This spreads CPU/bandwidth usage more evenly. However, trade-off: 10x more block headers to validate/store, more frequent difficulty adjustments needed, coinbase maturity becomes 100 minutes instead of ~1000 minutes for same block count.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why doesn't Tor Browser work for CashFusion on Android?",
      "answer": "Tor Browser on Android only routes browser traffic through Tor network - it doesn't provide system-wide proxy that other apps can use. CashFusion needs Tor SOCKS proxy accessible to EC app, not just browser routing. Correct setup: Install Orbot (official Tor app for Android) which runs as VPN/proxy service that any app can connect through. Some users report Orbot issues while Tor Browser app works, but technically for CashFusion you need the proxy functionality. EC Android specifically looks for SOCKS proxy on localhost port 9050 (Orbot default). Without proper Tor instance running, CF icon won't enable and fusion won't start.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What specific incident caused people to lose trust in Ledger hardware wallets?",
      "answer": "Ledger released firmware update that added 'Recover' feature - ability to backup private keys to cloud. This fundamentally violated core hardware wallet promise: 'keys never leave device.' Community outrage: 1) Feature contradicts entire security model users bought into, 2) If firmware CAN export keys, malicious update could steal them, 3) Closed-source firmware means users can't verify code, 4) Trust in 'cold storage' destroyed when device can go online. Lesson: Hardware wallet security depends on trusting company not to break promises via firmware updates. This is why many BCH developers now recommend: open-source software wallets on offline devices you control (GrapheneOS phone, de-googled Android, airgapped laptop).",
      "category": "Security & Best Practices"
    },
    {
      "question": "Does Ledger work with Electron Cash after firmware updates?",
      "answer": "Frequently breaks. Ledger updates firmware regularly and often breaks compatibility with third-party wallet software like EC. Recent reports: Latest Ledger Nano X firmware incompatible with EC. Root cause: Ledger changes APIs/protocols without coordinating with external wallet developers. Community response: Stop using Ledger. EC developers don't own Ledgers and don't test compatibility - they support what's reported working. Alternatives: Trezor (more open source), OneKey, or abandon hardware wallets entirely for GrapheneOS phone or offline laptop. Ledger's closed-source firmware and frequent breaking changes make it unreliable for non-Ledger-Live software.",
      "category": "Hardware Wallets"
    },
    {
      "question": "Does CashFusion actually work on Android EC?",
      "answer": "Yes, but requires correct setup: 1) Install Orbot (NOT just Tor Browser), 2) Start Orbot and wait for connection (look for onion icon in status bar), 3) Open EC with Tor active - CF icon should enable, 4) Press play button to start fusion, 5) Keep phone awake with EC open - mobile OS may kill background processes. Success indicators: Fusion transactions appear in history, balance changes as coins get fused. Common problems: Wrong Tor app (browser vs proxy), phone sleeping/killing app, insufficient balance for fusion rounds, changing settings incorrectly. Many users confirm it works - if issues persist, try desktop EC where it's more reliable and can run 24/7 easily.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What are the human factors in choosing between hardware wallets and offline computers?",
      "answer": "Security isn't purely technical - operational security matters: 1) Hardware wallets: Simpler UX but trusting manufacturer, supply chain, and firmware updates. Risk: Company betrayal, supply chain tampering, update vulnerabilities. 2) Offline computers: More control but requires technical knowledge to set up properly (OS installation, security hardening, air-gap discipline). Risk: User error breaking security. Key insight: No perfect solution exists. Hardware wallets have corporate trust issues; offline computers have human error issues. Best choice depends on your technical ability and threat model. Both can lose funds - hardware through company malfeasance, offline through user mistakes. Complexity itself is security enemy regardless of approach.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why is Windows particularly dangerous for cryptocurrency wallets?",
      "answer": "Multiple serious concerns: 1) Windows 11 Recall feature takes periodic screenshots of everything on screen - could capture seed phrases when wallet displays them, 2) Even if disabled, feature can be re-enabled via updates without user consent, 3) Telemetry sends data to Microsoft servers, 4) Closed-source OS means you can't verify what's running, 5) Historically most-targeted OS for malware. EC has no special protection against screenshot capture. Alternative: Use Linux (open source, verifiable) or at minimum macOS. For crypto security: Keep bulk of funds on dedicated device (old phone, offline laptop) not your daily Windows machine. Community consensus: 'Don't use Windows' is foundational crypto security advice.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How should I structure cold storage vs hot wallet for everyday use?",
      "answer": "Recommended setup: 1) Hot wallet on phone: Small amount for daily spending (week/month worth), 2) Cold storage: Bulk of funds on separate device kept physically safe at home. Important: 'Physically safe' doesn't require complex airgapped setup. Simple approach: Old phone or laptop kept at home (sock drawer, under bed) - key is it doesn't leave house where it could be stolen. Don't overthink security - avoid Windows, use strong password, keep seed phrase backed up separately. Splitting funds this way limits loss if phone is stolen or compromised. Cold device can be online occasionally for syncing - true airgap is unnecessary complexity for most users.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How do I burn unwanted tokens or dust in Electron Cash?",
      "answer": "Token burning creates transaction where tokens are inputs but not outputs - they cease to exist. Current EC doesn't have one-click burn feature (removed sending to OP_RETURN for tokens). Methods: 1) Wait for PRs adding burn functionality to merge, 2) Use CLI with text editor to craft transaction manually, 3) Send tokens to provably unspendable address. For BCH dust (tagged addresses from dusting attacks): Can still send to OP_RETURN in EC. Note: OP_RETURN itself is unneeded for burning - any transaction that doesn't include token in outputs destroys it. The OP_RETURN aspect just documents the intent. Feature request: Simpler burn UI for tokens.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Why would you want to rotate wallet seeds periodically?",
      "answer": "Security principle borrowed from encryption key rotation: Using same secret for years means one compromise reveals entire history. If seed is ever exposed (even years later), attacker sees all past transactions. Recommendation: Every year or two, create new wallet with fresh seed, migrate funds. Benefits: 1) Limits damage from future seed exposure, 2) Fresh derivation paths, 3) Clears accumulated transaction history (performance), 4) Can abandon old addresses. Migration challenge: Moving all funds in single transaction creates obvious on-chain link. Better: Use CashFusion to gradually move funds from old wallet to new, breaking linkage. This is why sub-wallet features being discussed - merge old seed into new wallet for fusion migration.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What is the proposed sub-wallet or xpriv-based wallet feature?",
      "answer": "Feature idea: Import multiple seed phrases or xprivs into single EC wallet instance. Use cases: 1) Migrate funds from old wallet to new via fusion (old seed as sub-wallet, outputs go to primary), 2) Import RPA wallet into HD wallet, 3) Spend from multiple sources in one transaction, 4) Consolidate donation addresses with main wallet. Tom's xpriv approach: Child wallets derived from parent seed can be used on mobile separately - if phone stolen, attacker can't access parent or sibling wallets. Only compromises that specific child. Jonas' approach: Import arbitrary seeds as sub-wallets with toggle to enable/disable. Both solve wallet migration and address consolidation problems while maintaining security isolation.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "What is Calin's roadmap for RPA in Electron Cash?",
      "answer": "Current RPA implementation is proof-of-concept as separate wallet type with limitations (no change addresses, no fusion support, limited key derivation). Planned improvement: Make RPA a feature of standard HD wallets rather than separate wallet type. Benefits: 1) One wallet file handles both regular and RPA payments, 2) Change addresses work normally, 3) CashFusion compatible, 4) No need to run separate wallet instances, 5) Better UX for receiving private payments. Timeline: Calin wants to work on this but needs development time. JF offered to help implement if given architectural guidance. Goal is seamless integration where users can optionally use RPA features within their normal HD wallet workflow.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Why doesn't EC show 'first seen' time for transactions instead of mined time?",
      "answer": "EC currently shows mined timestamp (block time) for confirmed transactions. Request: Show when your wallet first saw the transaction instead, emphasizing zero-conf capability. Challenges: 1) 'First seen by who?' - your wallet's timestamp vs Fulcrum server's timestamp, 2) If wallet offline when tx arrives, first-seen would be when wallet syncs (misleading), 3) Multiple transactions mined in same block get identical timestamps, making ordering unclear (CTOR makes it worse). Proposed solution: Use local wallet timestamp for transactions seen while wallet running, fall back to block time for transactions discovered after confirmation. This emphasizes BCH's instant transaction capability while remaining accurate. Not currently implemented in EC but suggested as UX improvement.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why doesn't CashFusion work with hardware wallets?",
      "answer": "Hardware wallets can't participate in CashFusion rounds. Technical reason: CashFusion requires signing many inputs/outputs rapidly during round coordination. Hardware wallets: 1) Require manual confirmation for each signature, 2) Have timeouts that would expire during fusion process, 3) Can't handle the complex multi-party signing protocol. Solution: Import seed phrase from hardware wallet into EC software wallet for fusion. However, this defeats hardware wallet security model (keys leave secure element). Workaround: After fusing with seed phrase in EC, move fused coins back to hardware wallet addresses. Not ideal but only current option. Better approach: Keep funds in software wallet (de-googled phone, offline laptop) and skip hardware wallet complexity entirely.",
      "category": "Hardware Wallets"
    },
    {
      "question": "Is Electron Cash Android available on Google Play Store?",
      "answer": "Yes, EC Android is still available on Google Play Store at: play.google.com/store/apps/details?id=org.electroncash.wallet. In August 2025, Google announced licensing requirements for crypto wallet apps that initially seemed to threaten all wallets, but they backtracked and clarified that non-custodial wallets (like EC) are exempt - only custodial services need special licensing. Community concern: Google controls major app distribution channel and has financial incentive (Google Pay) to restrict crypto wallets. Lesson: Don't rely solely on centralized app stores. EC is also available via: F-Droid (open source app store), direct APK download from electroncash.org, GitHub releases. Learn to sideload APKs - it's only a few clicks on Android.",
      "category": "Installation & Setup"
    },
    {
      "question": "Why doesn't Google banning custodial wallets affect Electron Cash?",
      "answer": "Google's crypto wallet licensing requirements target custodial services (exchanges, services holding user funds) not non-custodial wallets (user controls keys). Key distinction: EC is non-custodial - your keys stay on device, EC never controls your funds. Custodial services need licensing because they operate as financial institutions. This is actually positive: 1) Forces users/regulators to understand custodial vs non-custodial difference, 2) May cause exchanges to be labeled differently than wallets, 3) Highlights that EC is true self-custody. However, community remains vigilant - Google could still change policies. Alternative distribution (F-Droid, direct APK) remains important backup.",
      "category": "Community & Resources"
    },
    {
      "question": "Why doesn't EC automatically select the smallest viable UTXO for transactions?",
      "answer": "EC's coin selection algorithm considers privacy, not just minimizing UTXO usage. Problem with 'smallest viable': If EC always picks smallest UTXO that covers payment + fees, blockchain analysis can easily identify which output is change (the smaller one). Example: Pay 0.03 BCH using 0.08 BCH UTXO - obviously 0.05 BCH output is change. Better approach: Select UTXO where payment and change are similar sizes (closer to 2x payment amount), making it harder to distinguish outputs. Trade-off: Uses more of your 'good' (fused) UTXOs faster, requiring more frequent fusion. If you prefer conserving specific UTXOs, use manual coin selection (right-click in Coins tab). BIP69 output sorting also helps obscure payment vs change.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Does Electron Cash support Neutrino/BIP-157 compact block filters?",
      "answer": "No, EC doesn't implement Neutrino (BIP-157 compact block filters) and there are no current plans to add it. Background: Neutrino is alternative to bloom filters for SPV privacy - client downloads block filter commitments, matches locally, requests only relevant blocks. Benefits: Better privacy than bloom filters, don't reveal addresses to servers. EC's situation: Uses Electrum protocol (Fulcrum servers) instead of direct node connections, which provides similar benefits differently. BCHD node software supports Neutrino, but EC can't connect to it directly. Future possibility: Could be implemented as option alongside current Fulcrum connection, but requires significant development effort. Current priority is improving existing features (RPA integration, CashTokens support) over protocol changes.",
      "category": "Network & Architecture"
    },
    {
      "question": "How do I install plugins in Electron Cash if they fail to load?",
      "answer": "Common WalletConnect plugin installation issue: Error occurs when zip file is corrupted or wrong version. Troubleshooting: 1) Re-download plugin zip from official source (ensure latest version), 2) Verify file integrity (checksums if available), 3) Ensure zip isn't damaged during download, 4) Same version number doesn't mean identical files (updates within version possible), 5) Check GitHub releases for plugin changelog. Installation: Tools > Plugins > Install plugin from zip. If errors persist: check EC console for specific error messages, report to plugin developer with error details. Important: Only install plugins from trusted sources (official flipstarter campaigns, known developers). Plugins have full access to your wallet.",
      "category": "Plugins & Extensions"
    },
    {
      "question": "What is BIP69 and how does it improve transaction privacy?",
      "answer": "BIP69 is deterministic transaction output ordering standard. How it works: Orders outputs lexicographically (by script/amount) rather than by meaning (payment first, change second). Privacy benefit: Just looking at transaction, you can't tell which output is payment vs change based on position alone. Example: Without BIP69, first output might always be payment. With BIP69, outputs sorted algorithmically - position means nothing. Limitation: If payment is 0.01 BCH and change is 99.99 BCH, size difference still reveals which is which. Best privacy: Combine BIP69 with coin selection that makes payment and change similar sizes. EC uses BIP69 by default. Note: Even with these measures, sophisticated chain analysis can still make educated guesses based on spending patterns.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What are Electron Cash's scalability limits for wallets with many addresses or UTXOs?",
      "answer": "EC has practical limits: 1) After ~30,000 addresses, start a new wallet - performance degrades significantly, 2) Wallets with 60k+ UTXOs on single address cause freezing (can't access Coins tab, can't type amounts), 3) Long-running CashFusion (years of 24/7 operation) creates massive address/UTXO counts, consuming 5-8GB RAM. GUI issues are worse than backend - opening Addresses tab with huge address count crashes client. Workarounds: Use CLI instead of GUI for operations, avoid clicking Addresses/Coins tabs, migrate funds to new wallet periodically. Root cause: EC tries to load everything into GUI lists at once instead of lazy-loading only visible items. Fix would require significant GUI refactoring.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How do I recover funds from a wallet EC can't handle due to too many UTXOs?",
      "answer": "Multiple approaches: 1) Use EC CLI instead of GUI - may avoid GUI rendering issues, 2) Export individual private keys (WIF) from seed, import each address as separate wallet, 3) Set address gap to 0 to prevent wallet from scanning many addresses, 4) Use libauth or other library to derive private keys from seed phrase programmatically, 5) Create transactions programmatically using extracted private keys. For single address with 60k+ UTXOs: Even Fulcrum server may timeout on listunspent query - that much data challenges entire infrastructure, not just EC. Last resort: If it's testnet BCH (tBCH), consider starting fresh wallet and mining to new address instead of transferring.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why should I migrate to a new wallet after running CashFusion for extended periods?",
      "answer": "Several reasons: 1) Performance - EC becomes sluggish with thousands of addresses/transactions, 2) RAM usage grows unbounded (5-8GB for years of fusion), 3) GUI crashes on Addresses tab, 4) Security - using same seed for years means one compromise reveals all history (like encryption key rotation), 5) Transaction history becomes unwieldy. Migration process: Create new wallet with fresh seed, use CashFusion to gradually move funds from old wallet to new (breaks linkage better than single transfer). Challenge: Must backup new seed phrase securely. Recommendation: Migrate every 1-2 years or after ~30k addresses. Don't wait until wallet becomes unusable - migrate proactively.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Is BIP-157/158 (Neutrino/compact block filters) the same as Bloom filters?",
      "answer": "No, they're different privacy techniques: 1) Bloom filters (BIP-37): Send probabilistic filter to server/node, they return matching transactions. Privacy: false positives hide exact addresses, but still reveals info to server. 2) BIP-157/158 (Compact Block Filters): Client downloads block filter commitment, matches locally, requests only relevant blocks. Privacy: Server sees which blocks you request, not which addresses. BIP-157/158 is p2p protocol extension - requires node support (BCHD implemented it, BCHN hasn't). EC uses neither directly - it uses Electrum protocol (Fulcrum servers) which provides different privacy model. JF notes: 'completely different than how EC works - almost apples and oranges'.",
      "category": "Network & Architecture"
    },
    {
      "question": "Can I see my hardware wallet seed phrase after initial setup?",
      "answer": "Typically no - seed phrases are displayed only during initial device setup. Security model: Hardware wallets are designed so private keys never leave the device. If you could extract seed phrase anytime, defeats security purpose. Backup verification: Some devices (Ledger) have 'Check Recovery Phrase' feature through Ledger Live that verifies your backup matches what's on device without exposing it. Important: Ledger's controversial 'Recover' firmware update showed they technically CAN extract seeds, which undermined trust. Best practice: Write down seed phrase carefully during setup, store securely. If you forgot to backup or lost backup, move funds to new wallet with fresh backup rather than trying to extract seed.",
      "category": "Hardware Wallets"
    },
    {
      "question": "What's the difference between GUI freezing and backend issues in EC?",
      "answer": "Important distinction for troubleshooting: GUI issues freeze interface but wallet data may still be accessible via CLI or programmatic access. Example: Wallet with 60k UTXOs - Coins tab freezes GUI, but CLI commands or direct wallet access might work. EC's GUI renders entire lists in Qt widgets, causing hangs when data is large. CLI bypasses GUI rendering entirely. Solution path: If GUI freezes, try EC CLI commands (payto, listunspent, etc.) or export private keys and use external tools. Backend issues (Fulcrum timeout, database corruption) affect all access methods. Diagnosis: If wallet loads but specific tabs freeze = GUI issue. If wallet won't sync or balance wrong = backend/network issue.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why can't I view my hardware wallet seed phrase in Electron Cash?",
      "answer": "EC doesn't show seed phrases for hardware wallet-connected wallets because the seed never leaves the hardware device. Key security principle: Hardware wallets are designed so private keys (including seed) stay in secure element chip forever. EC only knows your xpub (public key) for watching addresses. To verify your backup: Use manufacturer's software (Ledger Live, Trezor Suite) with 'Check Recovery Phrase' feature - you enter your backup phrase and it confirms if correct without displaying the actual seed. This verification is different from viewing - device checks hash internally. If you need to see seed phrase, you should have written it down during initial device setup - that's the only time it's displayed.",
      "category": "Hardware Wallets"
    },
    {
      "question": "Why do some community members prefer seed phrase backups over hardware wallets?",
      "answer": "Plausible deniability argument: Hardware wallets are physical objects that reveal you own cryptocurrency. If police/authorities/thieves find your Ledger/Trezor, they know you have crypto - even if they can't access it, they can seize it or use '$5 wrench attack' (physical coercion). Alternative: Seed phrase carved/written in hidden location (under floorboard, in wall, encrypted on USB). Benefits: 1) Nobody knows you own crypto unless they find the hidden backup, 2) Recovery requires only Linux LiveCD + EC, 3) No firmware updates to trust, 4) No supply chain attack risk. Encoding options: Convert 12 words to hex/binary before writing, encrypt with additional password. Trade-off: Requires more technical knowledge and secure storage location.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What are secure ways to backup seed phrases without hardware wallets?",
      "answer": "Multiple approaches discussed by community: 1) Titanium/steel plate engraved with words (fire/water resistant), cement in wall, 2) KeePass encrypted database with strong password, distribute file copies to multiple locations (USB drives, trusted cloud storage in password-protected zip), 3) Paper/DVD with words encrypted using additional passphrase, 4) Convert words to binary/hex/decimal before physical storage for extra obfuscation, 5) Multiple geographic locations for redundancy (if house burns, have backup elsewhere). Key insight: Threat model matters - protect against fire/flood (multiple copies), theft (encryption/hiding), government seizure (plausible deniability). No single solution fits all - evaluate your specific risks.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Can open source hardware wallet chips still have backdoors?",
      "answer": "Yes, significant concern even with 'open source' hardware: 1) You can't manufacture chips yourself - must buy from supplier, 2) Even if design is open source, how do you verify YOUR specific chip follows that design?, 3) Government can order manufacturer to add backdoors under NDA (you'll never know), 4) Secure element chips with tamper-resistance are black boxes by design. JF's insight: 'if you're relying on hardware, for all intents and purposes you are trusting the device.' Mitigation: Use generic hardware (old phone, laptop) running verified open source software - easier to audit software than hardware. Trust moves from chip manufacturer to software developers whose code you can inspect.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How do I verify I downloaded legitimate Electron Cash and not malware?",
      "answer": "Critical security step: 1) Download ONLY from electroncash.org, 2) Verify GPG signatures or SHA256 checksums against published values on website, 3) Don't trust unofficial sources, app stores, or DMs sharing download links. Red flags that indicate malware: suspicious binary strings in GUI, app requesting unusual permissions, unexpected network connections, different file hash than official. Real example from chat: User showed EC with suspicious binary appearing in interface - community immediately identified as malware, advised to delete immediately and redownload from official source. Never type seed phrase into compromised software - malware steals seeds instantly. When in doubt, verify signatures or ask in official channels before using.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why is code complexity the enemy of security in cryptocurrency wallets?",
      "answer": "Expert insight from community: Every line of code is potential attack surface. Problems compound with: 1) GitHub repositories grow massive - who reviews all code plus dependencies?, 2) Compilers and build tools themselves could be compromised (compilation trust chain), 3) Multi-coin support in hardware wallets exploded firmware complexity, 4) More features = more bugs, harder audits, larger attack surface. Recommendation: Prefer simpler wallets focused on fewer chains (BCH-only firmware on Trezor safer than multi-coin). EC benefits from being specialized for BCH rather than supporting every cryptocurrency. Complexity enables monetization (supporting shitcoins makes money) but undermines security. Simple tools with focused functionality are easier to verify and trust.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Can Electron Cash scan QR codes directly from my desktop screen without a webcam?",
      "answer": "Yes! EC has screen scanning feature that captures your entire desktop and searches for QR codes. Super useful if: 1) Your computer doesn't have webcam, 2) QR code is displayed on website/PDF on your screen, 3) You want to avoid camera permissions. How to use: Click QR scan button, EC requests screen recording permission (macOS may show this as 'Accessibility' access), scans screen for QR codes. Calin's advice: Only grant this permission if you actually need the feature - decline if you don't plan to use it. Alternative: Use external QR scanner app that reads screen (KDE has this built into screenshot tool), then paste text into EC. Feature works for addresses, payment URIs, and potentially WIF private keys for sweeping.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "How do I sweep or import private keys (WIF) in Electron Cash?",
      "answer": "Two methods depending on your goal: 1) Sweep (move funds to current wallet): Wallet menu -> Private Keys -> Sweep. Enter WIF, EC creates transaction moving all funds from that address to your wallet. You can scan WIF from QR code. After sweep, original address is empty. 2) Import (add address to wallet): File -> New/Restore -> 'Import Private Keys' option. Creates wallet containing that specific private key. Address becomes part of your wallet. Use sweep when: you want funds consolidated into existing HD wallet. Use import when: you need to control specific address directly. QR scanning works for both - EC has QR button in relevant dialogs. Proposed enhancement: Support for 'bch-wif:' protocol handler for easier integration with services like stamps.cash.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does EC AppImage crash after running for extended periods on Linux?",
      "answer": "Some users report EC 4.4.2 AppImage crashing silently after hours of running (especially during screen lock). Debugging steps: 1) Run EC from terminal in verbose mode to capture logs when crash occurs, 2) Check system logs (journalctl) for segfaults or OOM killer, 3) Monitor memory usage - EC can grow to 5-8GB RAM with large wallets, 4) Ensure AppImage has execute permissions, 5) Try different compositors (X11 vs Wayland differences). Possible causes: Memory leak over time, Qt/GUI framework issue, CashFusion threading problems. Most users report stable operation for weeks - if yours crashes consistently, likely specific to your configuration. Report issue on GitHub with verbose logs, distro version, desktop environment. Workaround: Restart EC periodically as preventive maintenance.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Can BCH integrate with Nostr protocol for tipping and payments?",
      "answer": "Yes, and easier than previously thought! Initial concern: BCH uses secp256k1 ECDSA while Nostr uses Schnorr signatures - different signature algorithms would produce incompatible keypairs. Reality: Bastian Carmichael's proof-of-concept showed you CAN derive BCH address from Nostr npub (public key) directly. Same elliptic curve (secp256k1) underlies both, just different signature schemes. Implication: No NIP (Nostr Improvement Proposal) needed - can pay directly to BCH address derived from someone's Nostr identity. Use cases: Tip content creators, zap-style payments, social media micropayments. Current status: Proof-of-concept exists, needs wallet integration. Nostr currently uses Lightning Network but creator (fiatjaf) dislikes it - BCH could be better fit for instant payments.",
      "category": "Community & Resources"
    },
    {
      "question": "What permissions does EC request on macOS and are they suspicious?",
      "answer": "EC may request several permissions: 1) Screen Recording/Accessibility - for scanning QR codes on desktop screen, 2) Camera access - for scanning QR codes via webcam, 3) Audio (sometimes bundled with camera) - likely inherited from Qt framework's multimedia module. These are legitimate features, not malware indicators. However, be cautious: If EC shows strange binary strings in GUI, unusual behavior, or requests unexpected permissions, it may indicate compromised binary. Safety steps: 1) Download only from electroncash.org, 2) Verify GPG signatures, 3) Grant minimum permissions needed, 4) Deny permissions you don't need (can always grant later), 5) If suspicious, delete and redownload verified version. macOS Gatekeeper warnings are normal for non-App Store apps.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What is a potential workaround for wallets with too many UTXOs that EC can't handle?",
      "answer": "Tom's suggestion for extreme UTXO count (60k+): Import wallet from later block height to get partial view. This means: 1) When restoring from seed, specify recent block height instead of genesis, 2) Wallet only sees transactions/UTXOs from that height forward, 3) Avoids loading entire transaction history that causes GUI freeze. Limitations: Loses access to older UTXOs (need full import for those), primarily useful for chipnet/testnet scenarios where history is less critical. Other approaches: Extract individual private keys and import each address separately (spreads load), use CLI instead of GUI (bypasses rendering issues), or programmatically construct transactions using libauth. Note: 60k UTXOs also challenges Fulcrum server - 'listunspent' query may timeout regardless of EC client.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Is Electron Cash affected by npm supply chain attacks or infected JavaScript dependencies?",
      "answer": "No, EC is completely unaffected by npm/JavaScript vulnerabilities because it's written in Python, not JavaScript. Recent attacks targeting crypto wallets through infected npm packages (which replace deposit addresses with attacker addresses) only affect web apps and JavaScript-based wallets. EC's security measures: 1) External Python packages are audited daily via automated GitHub Actions, 2) During builds, developers check GPG signatures of dependencies, 3) No JS code means no npm dependency chain. Jonas: 'No js code in EC. External packages used are audited daily.' Additionally, Python ecosystem typically has fewer external dependencies than JavaScript projects, reducing supply chain attack surface. This is one advantage of EC using native Python over Electron/JavaScript frameworks (despite the confusing name, Electron Cash is not built with Electron.js).",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why is the number of dependencies more important than programming language for wallet security?",
      "answer": "Programming language alone doesn't determine security - the cumulative number of external dependencies is more indicative of supply chain risk. Example: Flowee Pay uses Java (Android integration), JavaScript (UI), and C++ (core logic) - multiple languages but controlled dependencies. Contrast with typical JavaScript apps that pull hundreds of npm packages. Python (EC's language) has same 'fetch dependencies before build' model as JavaScript, but Python projects typically have substantially fewer dependencies. More dependencies = more attack surface, more code to audit, more potential for malicious insertions. EC benefits from: focused functionality (BCH-only), mature Python ecosystem with better package vetting, and manual signature verification during builds. The recent npm supply chain attack affected wallets not because of JavaScript per se, but because those wallets pulled in compromised packages deep in their dependency tree.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How does moderation work in Nostr-Telegram bridges, and why is centralization unavoidable?",
      "answer": "Bridges between decentralized (Nostr) and centralized (Telegram) platforms face inherent moderation challenges. Current approaches: 1) Blacklist - Client operator maintains JSON file of banned pubkeys, frontend filters out their posts (doesn't involve relay), 2) Whitelist/NFT gating - Users purchase $1 NFT to gain posting rights, creating economic barrier to spam, 3) Channel owner bans - Nostr group owner can ban users, bridge respects this. Why centralization is unavoidable: Bridge must aggregate messages from one platform to another, so someone controls that aggregation. Unlike pure Nostr where users can ignore relays, Telegram users can't individually mute bridged messages (normal users can't mute others in group chat). Best solution: Whitelist approach (NFT = whitelist) rather than reactive blacklist, since spam takes time to notice and ban. Trade-off: Loses some of Nostr's censorship-resistance properties when bridging to centralized platforms.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why doesn't Electron Cash show the CashTokens tab by default?",
      "answer": "In EC version 4.4.x releases, CashTokens functionality exists but requires manual enabling via View menu. This confuses new users expecting token support. Good news: The fix to show CashTokens tab by default is already in the codebase (master branch), just awaiting next official release. JF: 'its already in the codebase, we just haven't done a release in a while.' For immediate access: 1) Enable via View > Show Tokens (current releases), 2) Use EC SLP edition (different wallet, not recommended for CashTokens), 3) Build from source to get latest features, 4) Wait for upcoming release (planned for late 2025). Note: EC SLP edition is different product optimized for SLP tokens, not CashTokens. For testnet token experimentation, building from source or waiting for release is recommended over EC SLP.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "What causes Electron Cash AppImage build failures and how are they investigated?",
      "answer": "AppImage builds can fail even when nothing appears to have changed, often due to Python dependency issues. Example: cryptography package (required for TLS/encryption) pulls setuptools-rust which requires semantic_version, causing build errors. Puzzling aspects: 1) Dependencies pinned to specific versions in Docker containers should be deterministic, 2) Same version worked for releases a year ago, 3) No code changes but builds suddenly fail. Investigation steps: 1) Check GitHub Actions logs for specific error messages, 2) Identify which package is failing (often deep in dependency tree), 3) Try building locally vs CI environment to isolate issue, 4) Consider updating to newer package versions (but requires security review), 5) Verify Docker container hasn't changed base image. Solution often involves balancing: updating to latest (more secure, less audited) vs keeping old versions (tested but may not build). Package manager complexity is a can of worms requiring careful review to prevent malicious code insertion.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How does BCH-Nostr integration work for tipping and social media payments?",
      "answer": "BCH and Nostr share the same elliptic curve (secp256k1), enabling direct integration. Key insight: The npub (Nostr public key) is calculated from same private key that generates BCH address. Implementation: 1) User's Nostr identity directly maps to BCH address, 2) Tips can be sent without separate wallet setup, 3) No need for additional protocols (unlike Lightning Network zaps). Chris Troutner's slpdex.com demonstrates: group chat, Telegram bridge, E2EE DMs, profiles, leaderboards - all using Nostr with BCH payment capability. Benefits: Social media tipping without custodial service, accessible via VPN/Tor without captchas, decentralized identity tied to payment capability. Current implementations use web apps for accessibility, with BCH transactions happening on-chain. This contrasts with Lightning Network which Nostr currently uses - BCH offers simpler integration and aligns with creator (fiatjaf) who dislikes Lightning complexity.",
      "category": "Community & Resources"
    },
    {
      "question": "What are OstrichGram and Pumpstr in the BCH ecosystem?",
      "answer": "Both are Nostr clients with BCH integration: 1) OstrichGram - Cross-platform (desktop, mobile) Flutter-based Nostr client created by JF. Supports basic DM and group chat, with vision of adding Telegram bridge and wallet functionality. Open source: github.com/OstrichGram/OstrichGram. 2) Pumpstr - Web-based Nostr client for Bitcoin Cash. These represent community efforts to integrate BCH into decentralized social media infrastructure. Why this matters: Combines censorship-resistant messaging (Nostr) with censorship-resistant money (BCH). Both leverage that Nostr and BCH use same cryptographic curve, enabling payment addresses to derive directly from social identities. Competition between implementations drives innovation - different UX approaches (native app vs web), different feature priorities (privacy DMs vs public posting vs tipping). OstrichGram unique feature: Telegram bridge to allow cross-posting between platforms.",
      "category": "Community & Resources"
    },
    {
      "question": "What caused EC AppImage build failures in September 2025 and how was it fixed?",
      "answer": "Root cause: python-qrcode package version 6.1 had '[console-scripts]' group in entry_points.txt with dash in name, which setuptools doesn't allow. This caused semantic_version package installation to fail during cryptography package build. Debugging process by EchterAgo: 1) Traced error to pkg_resources AttributeError in egg_info, 2) Found qrcode-6.1.dist-info/entry_points.txt contained problematic [console-scripts], 3) Discovered upstream fix in python-qrcode PR #229. Solution: Update qrcode to version 7.4.2 (not 8.2 because srcdist builder uses Python 3.8 from Ubuntu 20.04, and qrcode v8+ dropped Python 3.8 support). Additional considerations: Must include SHA256 hashes for new package version, may need to add pypng as dependency, and typing-extensions also needed update. This exemplifies why 'messing with python packages is a can of worms' - even pinned versions in Docker containers can break due to transitive dependency issues.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How do GitHub phishing attacks target cryptocurrency developers?",
      "answer": "Sophisticated phishing campaign observed in September 2025: Emails appear to come from legitimate github.com mail servers (pass SPF/DKIM) but contain links to phishing domains. Attack vector: Attacker creates GitHub issue mentioning @username, GitHub sends notification email, link in email points to malicious site. Targets: Specifically cryptocurrency developers who maintain wallet/blockchain repositories. Protection: 1) U2F/FIDO2 security keys - won't authenticate to wrong domain, 2) Password manager autofill - only fills credentials for correct domain, 3) Never click links in emails - navigate directly to github.com, 4) Check domain carefully before entering credentials. GitHub removes malicious repos quickly but notification emails persist. EchterAgo: 'good reason to have a U2F key registered and only use your password managers autofill, both will prevent phishing domains.' This is targeted attack on crypto ecosystem's most valuable assets - developer credentials.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What is Anubis and how does proof-of-work prevent bot abuse?",
      "answer": "Anubis (github.com/TecharoHQ/anubis) is a proof-of-work challenge system for web applications. How it works: Before processing request, server requires client to solve SHA256 hash puzzle (find nonce that produces hash with certain number of leading zeros). Impact: 1) Bots running millions of instances must spend 1000x compute resources per request, 2) Normal users barely notice (browser does computation in background), 3) Makes mass-scraping/spam economically unfeasible. Use case discussed: Block explorer getting hammered by botnet with random user agents - rate limiting affects legitimate users, but PoW targets automated abuse specifically. Shadow's insight: 'Bots are usually cheap to run, are run in millions, billions instances. If they have to spend 1000x the resources on a request, they would maybe decrease the share of resources used to scan your website.' Alternative to CAPTCHAs that doesn't require third-party services and respects user privacy.",
      "category": "Network & Architecture"
    },
    {
      "question": "What is the cosigner pool feature in Electron Cash?",
      "answer": "Cosigner pool is EC's multi-signature coordination feature for 2-of-2 or m-of-n wallets. Use case: User wants OTP (one-time password) as second factor for transactions. Flow: 1) User creates partially signed transaction in EC, 2) Exports to JSON file, 3) Uploads to server/cosigner service, 4) After OTP verification, service adds its signature, 5) Broadcasts fully signed transaction. Security benefit: Even if main computer is compromised, attacker needs OTP device too. JF notes feature exists but 'not widely used or maintained.' Alternatives discussed: User's smartphone could cosign directly (becomes 2-of-2 multisig with phone), or use sign/verify message feature for authentication. Challenge: Requires external infrastructure (server running cosigning service) and workflow is manual (export/upload/verify). True 2FA for crypto is 'something you have' twice (wallet + OTP device) but adds useful separation of compromise surfaces.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does Electron Cash reject JPP (JSON Payment Protocol) invoices from Paytaca?",
      "answer": "EC's JPP support is hardcoded to only accept payment requests from bitpay.com domain. When scanning QR code with bitcoincash:?r= payment URL pointing to watchtower.cash (Paytaca's payment processor), EC returns error: 'payment URL not pointing to a bitcoincash payment request handling server'. Technical details: EC successfully fetches the JSON payment request (returns valid response with payment_id, outputs, amounts, addresses, expiry time), but domain whitelist check fails. Jonas confirms: 'Only for paymentrequests from bitpay.com'. Impact: Merchants using Paytaca's WooCommerce plugin can't accept payments from EC users. Workaround: Use Paytaca wallet instead, or merchant provides plain address QR code. Fix needed: Expand EC's JPP domain whitelist to include other payment processors, or remove domain restriction entirely (security trade-off). This exemplifies tension between security (restricting to known providers) and ecosystem openness (supporting all JPP servers).",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why is Python 3.8 usage in EC build system problematic?",
      "answer": "EC's source distribution (srcdist) builder uses Ubuntu 20.04 which includes Python 3.8, but Python 3.8 reached End of Life (EOL) in 2024. Problems: 1) Newer packages drop 3.8 support (qrcode v8+ requires Python 3.9+), 2) Security vulnerabilities in EOL Python won't be patched, 3) Limits which dependency versions can be used. Example: Wanted to use qrcode 8.2 but had to fall back to 7.4.2 to maintain 3.8 compatibility. EchterAgo: 'ideally we'd also update srcdist to use a newer python, 3.8 is EOL.' Solution path: Update srcdist Docker container to use Ubuntu 22.04 (Python 3.10) or 24.04 (Python 3.12), but this is breaking change requiring extensive testing. Package version selection becomes constrained by oldest supported Python version in build matrix. This is why maintaining build reproducibility across years is challenging - upstream ecosystem moves forward while pinned versions create growing technical debt.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is BIP-21 vs JPP in payment requests?",
      "answer": "BIP-21 is URI scheme specification: 'bitcoincash:address?amount=X&label=Y' - simple standardized way to encode payment info in QR codes. JPP (JSON Payment Protocol) is full payment protocol: Interactive exchange between wallet and merchant server returning JSON with payment details, multiple outputs, expiry time, memo, etc. Relationship: BIP-21 URI can include 'r=' parameter pointing to JPP server URL (bitcoincash:?r=https://server/invoice/123). When EC scans such QR: 1) Parses BIP-21 URI, 2) Sees 'r=' parameter, 3) Fetches JSON from that URL using Accept: application/payment-request header, 4) Parses response for outputs array. JPP advantages: Multiple outputs in single payment, merchant can set exact fee rate, expiry times, invoice memos. JPP vs BIP-70: JPP uses JSON instead of protobuf, simpler implementation. Currently EC only accepts JPP from BitPay domain, limiting broader ecosystem adoption of this payment standard.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why do JPP (JSON Payment Protocol) invoices from Paytaca fail in wallets?",
      "answer": "URL encoding issue: QR code contains URL-encoded characters (%3A instead of :) that some servers don't properly decode. Kallisti (Paytaca dev): 'The %3A instead of : is throwing it off. We need to properly decode URLs in that format. Bug is on our end.' Additionally, EC's JPP implementation only accepts payment requests from bitpay.com domain (hardcoded security check). Jonas points to paymentrequest.py line 95 - when JPP was implemented, only BitPay used it. Even valid JPP responses fail EC's domain whitelist. Flowee Pay uses BIP-70 binary protocol, not JSON, and also has issues. Solution requires: 1) Server properly handling URL encoding, 2) EC expanding domain whitelist or removing restriction. BIP-70 (protobuf binary) vs JPP (JSON) both serve same purpose but different formats - BitPay invented JPP but servers should support both for broad wallet compatibility.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is the difference between BIP-70 and JSON Payment Protocol (JPP)?",
      "answer": "Both are payment request protocols but use different serialization: BIP-70 uses binary protobuf format, JPP uses JSON. BitPay invented JPP as alternative to BIP-70. Key insight from Tom: 'The wallet decides if they fetch from the server the binary or the json. The server has to do both' (if they want broad compatibility). Same URL can serve different formats based on Accept header in HTTP request. EC sends 'Accept: application/payment-request' to fetch JSON. Advantages of JPP: Easier to debug (human-readable), simpler implementation (no protobuf dependency), modern web-friendly. Advantages of BIP-70: More established, smaller payload size, certificate validation. In practice: BitPay supports both, Paytaca supports JPP only, Flowee Pay supports BIP-70 only. For maximum compatibility, servers should implement both protocols.",
      "category": "Network & Architecture"
    },
    {
      "question": "What is RPA's actual privacy benefit versus CashFusion?",
      "answer": "RPA and CashFusion solve different privacy problems and are complementary, not alternatives. RPA's specific benefit: Allows posting public receiving address without third parties monitoring your balance. Dustin's clarification: 'RPA allows you to post a receiving address in public without third parties being able to see what is sent to you, that's it, nothing more. It doesn't magically prevent any other knowledge leakage.' On-chain reality: RPA outputs look identical to any other P2PKH transaction - completely indistinguishable. Tom's elevator pitch: 'Instead of giving a new address to each sender, you give a code that allows the sender to generate a personal address to send to.' Limitations: Sender always knows where they sent, receiver always knows their addresses, can't combine RPA outputs without revealing they belong to same person (need CashFusion for that). Andy: 'You can't combine outputs from two RPA transactions before CF.' Use together: RPA for private receiving addresses, CashFusion for breaking on-chain linkage.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "Would an 'Electron Cash Private Edition' with enforced privacy settings be feasible?",
      "answer": "Proposal: EC variant with hardcoded privacy settings - Tor default, CashFusion for all sends, RPA for all receives. Intent: Compete with Monero by preventing users from accidentally compromising privacy. Technical challenges: 1) RPA and CashFusion don't currently work together in EC (implementation limitation, not protocol limitation), 2) Restricting to RPA-only addresses severely limits usability (can't pay merchants without RPA support), 3) RPA outputs are normal P2PKH - no special on-chain privacy beyond address reuse prevention. Jonas: 'Work to be done in EC regarding RPA, more basic than this Private Edition, and I don't think anyone is doing that work.' JF: EC roadmap includes RPA as feature of standard wallets rather than separate wallet type - this foundational work must happen first. Community debate: Some argue RPA provides Monero-level privacy, but fundamentally different - RPA just generates fresh address client-side instead of server-side, doesn't hide amounts or provide ring signatures.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "How are RPA addresses distinguishable from regular BCH addresses?",
      "answer": "Two levels of distinction: 1) Address format (off-chain): RPA uses 'paycode:...' prefix, regular BCH uses 'bitcoincash:...' - completely different encoding. This allows wallets to recognize when user wants RPA functionality. 2) On-chain transactions: Completely indistinguishable. Adaptive Blocksize Limit: 'RPA are indistinguishable from any normal bitcoin cash address on chain.' Jonas confirms: 'Outsiders can't see if a transaction output is to a RPA or not.' This is key privacy feature - third parties monitoring blockchain can't identify RPA payments. The paycode format contains public key material that sender uses with ECDH to derive unique one-time address. Receiver scans all transactions using their private key to detect payments. Result: Standard P2PKH output on chain, but receiver didn't have to communicate fresh address each time. Enormous anonymity set because looks identical to all other BCH transactions.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What is SLIP-39 and why would it be useful in Electron Cash?",
      "answer": "SLIP-39 is Shamir's Secret Sharing for seed phrase backup - splits seed into multiple shares where only threshold number required for recovery. JF suggested as potential future EC feature. Benefits: 1) Distribute backup across locations (give shares to trusted family members), 2) Losing one share doesn't compromise funds (unlike single seed phrase), 3) No single point of failure, 4) Can require N-of-M for recovery (e.g., 3-of-5 shares needed). Example: Create 5 shares, give to 5 family members, need any 3 to recover. If one is lost/compromised, still secure. Current EC uses standard BIP-39 mnemonic (12/24 words) - single point of failure. SLIP-39 would provide more robust backup scheme. Already supported in Trezor hardware wallets. Implementation challenge: Additional complexity in wallet setup/recovery flow, compatibility with existing backup methods.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Does CashFusion require HD (hierarchical deterministic) wallet structure?",
      "answer": "No, CashFusion doesn't rely on HD wallets as part of its design. JF clarifies: 'every wallet nowadays typically uses HD, but fusion doesn't rely on HD as part of its design, it would work in theory even with a wallet that uses a bunch of unrelated addresses.' HD wallets conveniently generate new addresses from single seed, which CashFusion uses for sending outputs to fresh addresses. But fundamentally, CashFusion just needs: 1) UTXOs to mix (inputs), 2) Addresses to receive mixed outputs, 3) These addresses can be from any source - imported, HD-derived, or arbitrary. This means CashFusion could theoretically work with imported address wallets, multi-sig arrangements, or any wallet structure. In practice, EC uses HD for convenience and CashFusion outputs go to next HD-derived change address, but protocol itself is address-source agnostic.",
      "category": "Privacy & CashFusion"
    },
    {
      "question": "What is Fulcrum 2.0 and why is it significant for Electron Cash?",
      "answer": "Fulcrum is the Electrum Protocol server (written by Calin Culianu) that EC connects to for blockchain data. Version 2.0 released September 2025 is major milestone. Fulcrum serves as bridge between full nodes (BCHN) and lightweight wallets (EC). Why significant: 1) EC depends on Fulcrum servers for address history, balance queries, transaction broadcasting, 2) Performance improvements benefit all EC users, 3) New features may enable EC functionality, 4) Critical infrastructure for BCH ecosystem. Fulcrum 2.0 adds support for newer protocols, better performance, bug fixes. Community celebrated release - shows active development of BCH infrastructure. Running your own Fulcrum server increases privacy (don't query third-party servers) and network resilience. StartOS integration discussions underway to make running BCHN+Fulcrum easier for home users.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why doesn't Electron Cash provide ARM64/aarch64 AppImage builds?",
      "answer": "Several challenges prevent official ARM64 AppImage: 1) EC uses older Python version requiring dependencies without prebuilt ARM64 binaries, 2) Reproducible build process is complex ('arcane' in maintainer's words), 3) Cross-compilation from x86-64 to aarch64 requires additional Docker setup, 4) Limited developer time for maintenance, 5) Testing infrastructure needed. Workarounds: Run from source using Python virtual environment (miniconda/conda recommended). Performance notes: Without compiling libsecp256k1, cryptographic operations are slow. With compiled libsecp256k1, casual use fine but CashFusion may still be slow on Raspberry Pi 4. Chris Troutner successfully built EC on Raspberry Pi (arm64), creating step-by-step README. Jonas: 'It should be possible to add some packages to the AppImage Dockerfile and cross compile it to aarch64 from an x86-64 host. But who has the time to do it and then maintain it.'",
      "category": "Installation & Setup"
    },
    {
      "question": "Why are EC AppImage builds not reproducible and what causes this?",
      "answer": "Reproducible builds mean building same source code produces bit-for-bit identical binary, allowing verification. Current issue: protobuf package breaks reproducibility. When protobuf was bumped from 3.x to 5.x, new UPD (Universal Proto Deserializer) backend compiles at build time, embedding build paths into .so files. Different build directories = different hashes. Jonas: 'The package that causes a diff... *drumroll*... protobuf! When bumping from 3.x to 5.x there is a new backend (UPD) that is compiled at build time. It seems like some build paths ends up in the compiled .so file.' Concerning because: Users can't independently verify released binaries match source code - must trust developers. Solutions: Pin protobuf to older version (loses features), fix build paths in protobuf compilation, or accept non-reproducibility (undesirable). Tom notes: 'The main way to avoid issues with it is to stop using their generated code and their library... Their protocol is stable, it's the software that's been a disaster for a decade.'",
      "category": "Security & Best Practices"
    },
    {
      "question": "How do you run Electron Cash from source instead of AppImage?",
      "answer": "Running from source offers latest features and avoids binary trust issues. Steps: 1) Clone EC repository from GitHub, 2) Use virtual environment (conda/miniconda recommended by devs - JF: 'it does a wonderful job of managing python envs'), 3) Install Python dependencies from requirements.txt, 4) Optionally compile libsecp256k1 for performance (instructions in repo). Common issues: System packages (apt) conflicting with pip packages. Jonas: 'A problem is when system wide packages interfere with user local packages.' Solution: Use isolated virtual environment. For ARM64: More complex due to missing prebuilt wheels - may need to compile dependencies. emergent_reasons: 'except for libsec, not necessary to build to run from source. You can just literally run from source.' EC currently uses Python 3.11 in official builds (maintained by EchterAgo), but source can run on newer versions. Arch Linux users report success with latest Python versions via AUR package.",
      "category": "Installation & Setup"
    },
    {
      "question": "What exotic derivation paths does EC's scanner support and why?",
      "answer": "EC includes derivation path scanner (Tools menu) that searches for funds across multiple HD wallet paths. Standard path: m/44'/145'/0' (BIP-44 for BCH). Exotic paths in scanner: m/144'/..., m/0'/..., m/0/..., and others. Origin: Different wallet software historically used non-standard paths before standards solidified. Example: Some wallets used m/144' instead of m/44'/145', causing funds to appear 'lost' when restoring in different wallet. Pierre K: 'I'm especially curious about the m/144'/... ones' - these were likely used by early BCH wallets during chainsplit confusion. Jonas: 'I remember I found a document somewhere (probably an excel sheet) of different paths that had been used by some wallet at some point.' Documentation largely lost (honest-dot-cash went offline taking comprehensive list). Scanner improvement: Pierre reports adding 'number of transactions found' after timeout to help users with large histories. This feature saves users who have funds but wrong derivation path configured.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why is Python dependency management difficult for EC and what helps?",
      "answer": "Python ecosystem challenges: 1) Frequent Python version deprecation (3.8 EOL, currently on 3.11), 2) Package backwards compatibility breaks (e.g., Keras API changes completely between versions), 3) System package manager (apt) conflicts with pip, 4) Transitive dependency version conflicts. Real examples from EC: qrcode v8+ dropped Python 3.8 support, protobuf 5.x broke reproducibility, cryptography package pulls setuptools-rust. Shadow: 'Python ecosystem seems like a complete mess to me.' Solutions: 1) Use conda/miniconda for isolated environments (JF and emergent_reasons both recommend), 2) Never mix system Python packages with pip packages, 3) Pin dependency versions in requirements.txt, 4) Use virtual environments religiously. Dustin: 'virtual environments can be a must on Linux due to OS dependencies.' Jonas notes EC maintains Python 3.11 in AppImage (EchterAgo does this maintenance work), avoiding EOL issues for users of official releases.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is StartOS and why are there barriers to BCH integration?",
      "answer": "StartOS (formerly Start9) is self-hosted server OS making it easy to run Bitcoin/Lightning nodes at home - plug-and-play sovereignty. Already supports BTC+Lightning, Fulcrum 2.0 now listed. Barrier to BCH (BCHN) integration: Primarily ideological, not technical. im_uname: 'historically the barrier is ideological, tho if they're somehow willing that would be fantastic.' StartOS team maintains specific perspective on Bitcoin maximalism. Technical packaging is straightforward - they provide hello-world-startos template and Matrix support channel for service packaging. Community efforts: Contact through Matrix (migrated from Telegram due to scammers), packaging BCHN+Fulcrum together, potentially including EC for CashFusion. Calin: 'Might be slight ideological reservation but that can be overcome I think.' Benefits if achieved: Home users could easily run full BCH infrastructure (BCHN node + Fulcrum + potentially EC) without Linux expertise, improving network decentralization and user privacy.",
      "category": "Community & Resources"
    },
    {
      "question": "Why does Electron Cash crash when my Linux computer is locked but works fine during active use?",
      "answer": "Likely Qt framework bug rather than memory issue. User reports: EC crashes after screen lock despite 32GB RAM, works fine for hours during active computer use (browsing, gaming). Calin's diagnosis: 'This leads me to think it's somehow related to bugs in qt hmm... Might not even be memory related might be some qt bugs in the EC version of qt.' Qt handles GUI rendering - when screen locks, compositor/display server behavior changes, potentially triggering Qt bugs. KDE Plasma updates may affect this. Additional factors: 1) EC does leak memory over time (confirmed by Calin), 2) Without swap, OOM killer may terminate EC abruptly, 3) Qt version bundled with EC AppImage may have incompatibilities. Troubleshooting: Enable swap (even 1GB), run from source with system Qt instead of AppImage, check dmesg/journalctl for OOM killer messages. Josh's specific case likely Qt-related since memory usage unchanged during issue.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Does Electron Cash have memory leaks and how much RAM does it use?",
      "answer": "Yes, EC has known memory leaks. Calin confirms: 'Yeah swap won't really fix it - EC leaks memory sadly.' Memory usage varies by wallet size: Small wallets: ~500MB-1GB, Large wallets (years of CashFusion history): 5-8GB normal, up to 8GB during spikes. Shadow's experience: '5GB (usual) - 8GB (extreme spikes) of RAM at all times' with large wallet. Leak causes: Python object references not released, transaction history accumulation, CashFusion state management. Symptoms: Gradual memory growth over runtime, eventual crash or OOM kill. Mitigation: 1) Restart EC periodically (workaround, not fix), 2) Enable swap to delay kill and allow graceful degradation, 3) Monitor memory usage with htop, 4) Consider migrating to fresh wallet if using CashFusion for years. Note: Memory leak is in EC codebase, not Qt or Python runtime, requires code-level investigation to fix properly.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why should Linux users enable swap even with plenty of RAM?",
      "answer": "Swap provides benefits beyond preventing out-of-memory situations. Calin explains: 'Because you give the kernel the opportunity to evict pages from ram that are dead memory that haven't been accessed in days - in favor of disk buffers.' Benefits: 1) Kernel can swap out inactive pages (processes allocated but not using memory), 2) More disk cache available for I/O operations, 3) Better overall system responsiveness, 4) Programs expecting swap may behave unexpectedly without it. Shadow reports: 'I had problems with random processes getting killed when I ran swapless. I still had 20GB of free RAM.' Some programs assume swap exists and crash otherwise. Calin: 'swap is beneficial even in non memory starved scenarios.' Recommended: At minimum 1GB swap on NVMe/SSD. ZSWAP compresses RAM before swapping, effectively increasing available memory 20-30%. Modern swapless trend problematic - convenience (faster system) but causes edge-case failures.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Does AppImage use more RAM than running from source?",
      "answer": "Yes, AppImage has overhead compared to running from source. Shadow explains: 'AppImage eats lots of ram, more than running from source, because it creates and mounts a container.' AppImage bundles entire application with dependencies in single file, then mounts as FUSE filesystem at runtime. Overhead includes: 1) Filesystem mounting layer, 2) Duplicate libraries (system has them, AppImage has own copies), 3) Potential memory mapping inefficiencies. Running from source uses system Python and libraries directly - more memory efficient but harder to set up. Trade-off: AppImage provides easy installation and version isolation, source provides better performance and transparency. For users with tight memory constraints or wanting to minimize overhead: Use Python venv with system packages. Jonas reports successfully running EC from source on Raspberry Pi (ARM64) with this approach.",
      "category": "Installation & Setup"
    },
    {
      "question": "What Python virtual environment approach is best for running EC from source?",
      "answer": "Multiple options with different trade-offs: 1) Python's built-in venv module: 2qx recommends 'The builtin venv module (-m venv) seems to give the least amount of headache over the long term, IMHO.' Lightweight, no external dependencies, straightforward. 2) Conda/Miniconda: JF and emergent_reasons prefer this - 'does a wonderful job of managing python envs.' More features, handles non-Python dependencies, but additional software to install. 3) System Python without venv: Can work (Tom uses on Arch via AUR) but risks system package conflicts. Common pitfall: Chris Troutner notes 'AI pointed out that the virtual environment was the source of some of the issue' - sometimes venvs add complexity. For EC specifically: Clone repo, create venv (python -m venv ec-env), activate it, pip install -r requirements.txt. EC GitHub README has instructions. Optionally compile libsecp256k1 for performance. Dustin: 'Once you have a venv, the EC readme on github gives you simple instructions.'",
      "category": "Installation & Setup"
    },
    {
      "question": "How does virtual vs reserved memory differ and why does it matter for EC?",
      "answer": "Critical distinction for monitoring memory usage: Virtual memory is address space mapped (can be huge - Shadow saw 500GB virtual for single process), reserved/resident memory is actual physical RAM consumed. Calin: 'Virtual is just the address space it's almost meaningless number.' When monitoring EC: Look at RSS (Resident Set Size) or RES in htop, ignore VIRT column. EC with large wallet uses 5-8GB RSS (actual RAM). Tools: htop shows both columns - focus on RES. Why this matters: Process may have 100GB virtual (pre-allocated address space for potential future use) but only 1GB resident (actually using physical RAM). OOM killer cares about resident memory, not virtual. When tracking EC memory leak: Monitor RES growing over time, that indicates leak. If only VIRT grows but RES stable, that's normal memory mapping behavior, not leak.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What are common Linux desktop environment issues affecting EC?",
      "answer": "KDE Plasma (Qt-based like EC) interactions discussed: 1) Memory usage - KDE uses ~750MB-1GB baseline (Jonathan reports 750MB), more than XFCE (minimal DE), but acceptable with modern RAM. 2) Qt version conflicts - EC bundles its Qt version in AppImage, system Qt (from KDE) may differ causing bugs. 3) Screen lock events - Josh's EC crashes only after screen lock, possibly compositor/session management triggering Qt bugs. 4) GPU/compositor interactions - Wayland vs X11 can affect Qt applications differently. Shadow notes: 'KDE was a RAM-eating monster last time I used it' but Josh counters: 'KDE 6 has been rock solid since I've started using it 2 years ago.' Jonathan: 'KDE is great... If you're on a memory starved machine, say 2gb or less, you might want consider other options.' Solution: If EC crashes only with certain DE behaviors (lock, suspend), try running from source with system Qt instead of AppImage's bundled Qt.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How was the protobuf reproducibility issue in EC AppImage builds fixed?",
      "answer": "Jonas created PR #3120 with clever workaround for protobuf 5.x build path embedding. Problem: Google's new UPD (Universal Proto Deserializer) backend compiles C library at build time, __FILE__ macro embeds absolute paths into .rodata section. These paths are randomized (/tmp/pip-install-xxx) causing different hashes on each build. Solution: Replace build path strings with deterministic strings of exact same length. Jonas: 'ended up bluntly changing the strings in the binary... My guess is that it's used for printing. But the .rodata is very sensitive since the machine code jumps around in it and offsets needs to be exact.' Why not proper fix: -fmacro-prefix-map flag (used for cryptography package) doesn't work because pip randomly generates build path and we can't control it. EchterAgo: 'the problem is you don't know the path beforehand so you can't pass it in CFLAGS.' Python's mkdtemp doesn't support deterministic seeding. Current fix works but fragile - if protobuf changes string format, would need updating.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is ZSWAP and how does it improve Linux memory management for EC?",
      "answer": "ZSWAP is kernel feature that compresses RAM pages before writing to swap. Works as compressed cache between RAM and disk swap. Benefits: 1) Effectively increases usable RAM 20-30%, 2) Reduces disk I/O (compressed pages stay in RAM longer), 3) Faster than disk swap due to compression/decompression being faster than disk read/write, 4) Extends SSD lifespan by reducing swap writes. Jonathan: 'I haven't used a swapfile/partition in almost a decade now... that was resolved with zswap for me. I still don't have an on-disk swap.' Shadow uses: 4GB swapfile + ZSWAP enabled, only 52MB actual swap used with 80% ZSWAP utilization. Setup: Enable CONFIG_ZSWAP in kernel, set swappiness (Shadow uses 40). Compression algorithms: lz4 (fast), lz4hc (higher compression), zstd. Note: ZSWAP is different from ZRAM - ZSWAP backs to disk swap if needed, ZRAM is pure RAM compression. Both help EC users running 24/7 CashFusion with growing memory usage.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is the difference between tmpfs and ramfs for Linux filesystem use?",
      "answer": "Critical difference for performance-sensitive applications: tmpfs can swap to disk, ramfs cannot. Shadow clarifies: 'Yes, you should not use tmpfs as ramdisks, it swaps to swap.' Usage: tmpfs is mounted to /tmp by default on many distros - files there may end up on disk swap under memory pressure. ramfs ('mount -t ramfs') stays strictly in RAM but has no size limit (can OOM). Josh uses tmpfs for Portage compilation: 'I use a tmpfs for my portage compilation to keep that in Ram. I think I'd need to convert it to A RAM disk to avoid it being swapped out.' For crypto operations where you want guaranteed RAM (like during signing), ramfs ensures data never touches disk. For general use where overflow is acceptable, tmpfs is safer (size-limited). Swap encryption helps either way - if swapfile on encrypted partition, swapped data remains encrypted. Best practice for EC: Run on system with adequate RAM, use ZSWAP to optimize, don't worry about filesystem type unless extreme security requirements.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What components in Electron Cash use protobuf and why is it dependency?",
      "answer": "Protobuf (Google's Protocol Buffers) used in multiple EC components: 1) CashFusion - for communication protocol between fusion participants, 2) BIP-70 payment requests - legacy payment protocol uses protobuf for message serialization, 3) CashShuffle - privacy mixing protocol communication, 4) KeepKey hardware wallet plugin - device communication. Jonas: 'Yes, BIP-70 and the KeepKey plugin... CashShuffle also uses protobuf.' Why protobuf: Efficient binary serialization, language-neutral, schema validation, backward compatible. Problem: Google's protobuf library has been 'disaster for a decade' (Tom's words) with frequent breaking changes. Alternative: Tom wrote custom protobuf implementation for Flowee - 'Their protocol is stable, it's the software that's been a disaster.' EC approach: 'we try to build as much from source as possible in appimage' (EchterAgo) for security/reproducibility, but this causes build challenges. Could fetch prebuilt binaries instead (already done for PyQt) but loses source-verification benefit.",
      "category": "Network & Architecture"
    },
    {
      "question": "How do you keep swap encrypted on Linux for security?",
      "answer": "Simple approach: Put swapfile on encrypted partition. Shadow: 'If you put your (not very used) swapfile on an encrypted partition, it becomes encrypted.' If using full disk encryption (FDE) with LUKS, all partitions including where swapfile resides are encrypted. Benefits: 1) Sensitive data paged to swap remains encrypted at rest, 2) No separate encryption key management, 3) Cold boot attacks less effective. Josh notes: 'better imo since I have fde and would like to keep swap encrypted as well.' Alternative: Dedicated encrypted swap partition, but more setup complexity. Shadow's setup: 'everything encrypted, RAM encrypted, Kernel structure randomized, no problems reported. Uptime in months.' For crypto wallet users: Critical because seed phrases or private keys in memory could theoretically be swapped to disk. With encrypted swap, even if attacker accesses disk, can't read swap contents. Combined with ZSWAP: Data compressed in RAM first, only overflow goes to encrypted disk swap - maximum security with performance.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why does modern software poorly utilize available hardware resources?",
      "answer": "Calin's observation: 'imagine having 8GB RAM or 32GB RAM and programmers still finding a way to utilize those resources extremely poorly. No matter how good hardware gets, (some) programmers will figure out ways to poorly utilize those resources.' Root causes: 1) Python/JavaScript interpreted languages with garbage collection create memory overhead, 2) Library abstractions hide inefficiencies (protobuf, Qt framework), 3) Development speed prioritized over optimization, 4) Hardware becoming cheap makes optimization less valued, 5) Memory leaks from reference cycles or event handlers not cleaned up. EC specific issues: Transaction history accumulates without pruning, CashFusion state management grows, Qt widget memory not released. Shadow reports EC using 5-8GB with large wallet. Compare to Flowee Pay (C++) which Tom wrote with explicit resource management. Solutions: Periodic wallet restart, migrate to fresh wallet, developers prioritizing memory profiling. Industry trend: 'Electron' (not EC) apps bundling entire Chrome browser for simple apps exemplifies wastefulness.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What logging does systemd provide for application crashes?",
      "answer": "Tom: 'systemd will log all application crashes. It will indeed mention that it was due to the out of memory killer if applicable.' Where to check: journalctl for systemd logs, dmesg for kernel messages (OOM killer). OOM killer logs include which process was terminated and why. Important: OOM killer only logs when it actually kills process - if application crashes for other reasons (segfault, Qt bug), different log entry. Josh notes: 'I'm staunchly anti systemd haha. I use OpenRC with sysklogd' - alternative init systems have different logging. For debugging EC crashes: 1) Check journalctl/syslog for crash messages, 2) Look for OOM killer messages in dmesg, 3) Monitor memory usage over time with htop, 4) Run EC with verbose mode from terminal to capture Python tracebacks. If crash has no OOM indication, likely Qt framework bug (common with screen lock on KDE) or Python exception not caught. Shadow's tip: Even without OOM kill, having no swap can cause crashes due to failed memory allocations.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Is there an ARM64 AppImage for Raspberry Pi available?",
      "answer": "Yes! Chris Troutner built ARM64 AppImage in October 2025. Announcement: 'It took me about a week of vibe coding and a lot of trial and error, but I finally managed to build an AppImage for arm64 support. I've tested this on Raspberry Pi 4 and 5 B.' Available at github.com/christroutner/Electron-Cash (v4.2.3). Key features: 1) CashFusion works (tested by Chris), 2) Step-by-step build instructions in README, 3) Can build on Pi 5 (Pi 4 slower, may crash during build). Important caveats: Build is NOT reproducible (Ubuntu packages not version-pinned), Chris not planning to maintain it long-term, same protobuf issues as x86_64. Community response enthusiastic - Shadow: 'people can now easily run CashFusion 24/7 on their Raspberry Pis without having their main PC run 24/7.' However, Jonas notes: 'The big problem... of adding an arm64 build on every release is: Who will maintain it? Builds break, someone needs to fix it.'",
      "category": "Installation & Setup"
    },
    {
      "question": "Why doesn't Electron Cash address search find CashTokens addresses?",
      "answer": "Known bug: Address tab Ctrl+F search only finds legacy (non-token) addresses, not token addresses. Damascene reports: 'if I go to Receive tab and copy Token address then go to Address tab and hit Ctrl+F... it doesn't show.' emergent_reasons confirms: 'right. I think it's just a miss in the tokens upgrade.' Issue opened as GitHub #2641 two years prior. Workaround: Switch to legacy address format from bottom status bar, then search works for legacy addresses. Root cause: CashTokens upgrade added token-aware addresses but search functionality wasn't updated to handle new format. Low priority bug since most users access addresses directly rather than searching. Fix would require updating address_list.py search logic to normalize addresses before comparison. emergent_reasons suggests filing on GitHub issues for tracking.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Why are reproducible builds important and what makes EC's builds reproducible?",
      "answer": "Reproducible builds allow anyone to verify that distributed binary matches source code - minimizes trust in maintainers. JF: 'i really appreciate this aspect of our build process and minimizing the trust placed on the maintainers.' How EC achieves this: 1) Exact dependency versions pinned in contrib/deterministic-build/requirements.txt, 2) Build happens in Docker container with controlled environment, 3) Build paths normalized to deterministic strings, 4) All source code auditable. Recent challenge: protobuf 5.x embeds random build paths requiring special handling. Jonas' fix (PR #3120) replaces randomized paths with deterministic strings. Process: Multiple developers build same release, compare SHA256 hashes - if identical, proves no tampering. Chris Troutner's ARM64 build NOT reproducible: Ubuntu packages not version-pinned, would produce different hashes. This is why official releases require maintainer commitment to reproducibility standards.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How does EC's Docker-based build process work?",
      "answer": "EC builds happen inside Docker containers for reproducibility and isolation. Jonas explains: 'The Dockerfiles used for doing the builds is included in the EC source repo. In fact, the build scripts start off by actually building a docker image, launch a container and do the build inside that container.' Process: 1) contrib/build-linux/appimage/ contains Dockerfiles and build scripts, 2) Script builds Docker image with specific base (Ubuntu version, Python version), 3) Container launched with controlled environment, 4) Dependencies installed from pinned requirements.txt inside container, 5) EC compiled with known toolchain, 6) AppImage assembled with all dependencies bundled. Benefits: Same container on any machine produces identical output, isolates from host system variations, version-controlled entire build environment. Challenge: Maintaining Dockerfiles as upstream changes (Python EOL, package updates). EchterAgo maintains these build infrastructure components.",
      "category": "Network & Architecture"
    },
    {
      "question": "What is the EC maintainer situation and why is it challenging?",
      "answer": "EC has limited maintainers despite being critical BCH infrastructure. Jonas: 'It's not like this project is packed by maintainers.' Challenges: 1) Adding new platform support (ARM64) requires ongoing maintenance - builds break, dependencies change, 2) Volunteer developers have limited time, 3) Complex build system requires deep knowledge (Docker, Python packaging, reproducibility), 4) Security implications mean careful review of all changes, 5) No full-time paid developers. Example: Chris Troutner built ARM64 AppImage but explicitly states 'I'm not planning to maintain this code base.' JF appreciates work done but recognizes burden. EchterAgo maintains build infrastructure, Jonas works on reproducibility fixes, JF and Calin on core features. Community can contribute: Report bugs on GitHub, test releases, donate to flipstarter campaigns for specific features. Specialized tasks need experts - not something anyone can pick up casually.",
      "category": "Community & Resources"
    },
    {
      "question": "Does adding swap space fix EC crashes during screen lock?",
      "answer": "No - Josh's experiment proves RAM/swap isn't the issue. After extensive community discussion about swap benefits, Josh added swap file: 'Fine! I make a dammed swap file on a no-COW btrfs subvolume.' Result: 'Just checked, EC still crashed.' Calin confirms diagnosis: 'i really think it has nothing to do with RAM and more to do with some Qt shenanigans.' Josh realizes: 'I did notice I started having issues after a qt update from a while ago.' Root cause: Qt framework bug, likely related to screen lock events on KDE Plasma. EC bundles its own Qt version in AppImage which may have incompatibilities with system compositor. Possible solutions: 1) Run EC from source using system Qt, 2) Report specific Qt version and KDE version to help diagnose, 3) Wait for EC release with updated Qt, 4) Use different desktop environment as test. Swap is still recommended for general system stability, just doesn't fix this specific Qt-related crash.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Can EC be cross-compiled from x86_64 to ARM64?",
      "answer": "Theoretically yes, practically challenging. Shadow: 'you can cross compile to Pi, zero problem... A ready VM (or a docker container) can be easily crafted, built specifically with all the tools to cross-compile it.' However, Chris Troutner built on native ARM64 machine because: 1) PyQt5 binaries not available via pip for arm64 - had to copy from Ubuntu packages, 2) Many assumptions in build scripts about native architecture, 3) Unknown if all dependencies cross-compile correctly. Jonas notes Chris' solution: 'Download the ubuntu packages and copy them' (github link to _build_arm64.sh). Cross-compilation challenges: Different library ABIs, native build tools expect host architecture, Python wheels may not have arm64 versions. JF: 'normally we build windows releases on linux, but no idea about arm64.' Current path: Build on native arm64 (Pi 5 recommended), use Chris's modified build scripts, accept non-reproducible builds. Cross-compilation would require significant build system modifications.",
      "category": "Installation & Setup"
    },
    {
      "question": "Is there a CVE affecting EC's protobuf version and does it matter?",
      "answer": "Yes, CVE exists but likely not applicable. Jonas identifies: 'There is a CVE for the version of protobuf that we are using: github.com/advisories/GHSA-8qvm-5x2c-j2w7. But it shouldn't be applicable since we are supposedly using the compiled upd backend.' Context: Protobuf 5.x has vulnerability but EC compiles with UPD (Universal Proto Deserializer) backend that mitigates the issue. Additional security: 1) EC packages are audited daily via automated GitHub Actions, 2) Developers verify GPG signatures during builds, 3) Protobuf only used for specific features (CashFusion, BIP-70, CashShuffle), 4) Not exposed to arbitrary external input in most cases. Best practice: Keep EC updated to latest version which includes security patches. Don't use ancient EC versions. If concerned, run from source where you can review all dependencies. CVE is tracked but assessed as low risk due to compilation method. Security-conscious users should verify with official EC channels for current assessment.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What causes EC AppImage crashes when screen locks and monitor turns off?",
      "answer": "Josh identified exact trigger: 'When my monitor goes blank after locking the screen. The locking itself doesn't crash, it's when the monitor shuts off.' Error log shows Wayland-related issues (wl_ prefixes in stack trace). Key findings: 1) Not RAM/swap issue (32GB RAM, tested with swap), 2) Not memory leak (works fine during active use), 3) Specific to monitor power-off event, not screen lock itself, 4) Wayland compositor behavior when display turns off triggers crash. Shadow: 'I see wl_ in there. Sooo..... Wayland?' Andy counters: 'I run electron cash on Wayland and have had zero problems' (using AUR package, not AppImage). Possible causes: AppImage's bundled Qt version incompatible with specific Wayland compositor version, Clang/LLVM profile on Gentoo introduces incompatibility, monitor DPMS events not handled correctly by bundled Qt. Jonas suggests: 'could this possibly be an issue that could be chalked up on the fixed if we move to Qt6 list?'",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Does AppImage bundle its own libc or use system libc?",
      "answer": "AppImages use SYSTEM libc, not bundled version. Jonas confirms after Shadow states: 'It is basically like a docker container. Contains all necessary libraries inside it, except some most basic ones like libc.' Reason: libc is fundamental system interface to Linux kernel - bundling would break binary compatibility. AppImage bundles: Qt, Python, application-specific libraries. AppImage uses: System libc (glibc), kernel interfaces. Josh's investigation: 'So after ldding a few executables, it looks like most things are loading libc.so.6.' His Gentoo system uses Clang profile with libc++ (LLVM's C++ stdlib) instead of GNU libstdc++, but still uses system glibc for C standard library. Tom's debugging tip: 'In the proc filesystem, the pid of EC you can double check which path to the Qt lib it actually uses. For instance /proc/100/maps' - shows all loaded libraries for running process. This helps verify AppImage isn't picking up system Qt by mistake.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Does EC work better on Xorg or Wayland?",
      "answer": "Mixed results - some users report no issues on either, one specific case shows Wayland-related crash. Evidence: Josh's AppImage crashes when monitor blanks (Wayland stack trace in error). Andy: 'I run electron cash on Wayland and have had zero problems' (AUR package). Jonas: 'I'm using the AppImage on Wayland (or whatever is the default on Ubuntu 24.04) and haven't had this issue.' Shadow strongly prefers Xorg: 'Wayland is totally experimental and unstable, despite any claims otherwise.' Tom defends: 'one person hates wayland and is very quick to blame it.' Reality: Wayland isn't universally broken, but specific combinations (AppImage + Gentoo + Clang + KDE Plasma) may trigger issues. WT notes: 'Wayland supposedly is a guarded, walled environment for processes, so we also have to ask if Electron Cash is doing something uncanny.' Workaround if having issues: Use AUR package (Arch) which uses system Qt, or try running EC with --xorg flag if compositor supports, or use XWayland compatibility layer.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How do I check which libraries a running EC process is using on Linux?",
      "answer": "Tom's debugging technique: 'you can open the text file /proc/PID/maps to get your full list of libraries for any running process.' Steps: 1) Find EC process ID: use 'ps aux | grep electron' or htop/top, 2) Read /proc/PID/maps: 'cat /proc/12345/maps' (replace 12345 with actual PID), 3) Look for library paths - shows Qt location, Python libraries, system vs bundled. For AppImage: Should show libraries from /tmp/appimage-extracted-xxx/ paths, not system paths. If you see /usr/lib/qt5 instead, AppImage is incorrectly using system Qt. Josh's investigation: 'I can't ldd the AppImage though since it's, well, an AppImage' - but /proc/PID/maps works on running process. Additional tool: ldd shows library dependencies at load time, but /proc/PID/maps shows what's actually loaded at runtime (can differ). Look for: libQt5*.so paths (should be AppImage directory), libc.so.6 (should be system), libpython*.so.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Could using Clang/LLVM instead of GCC cause EC compatibility issues?",
      "answer": "Possibly, though unlikely root cause. Josh uses Gentoo with Clang profile: 'I use a Gentoo system with the Clang profile... uses the libcxx library rather than the GNU libc.' Shadow theorizes: 'Because perhaps CLANG/LLVM is not as well battle-tested as GCC, which is the mainstream compiler used absolutely everywhere.' Investigation results: Josh's system uses standard glibc for C library, libc++ only for C++ standard library. Both coexist on his system. Most applications including Steam work fine. Problem is more likely: 1) AppImage's bundled Qt (compiled with GCC) interacting oddly with system compiled with Clang, 2) Wayland compositor behavior (not compiler), 3) Specific KDE Plasma version + Qt5 version combination. Tom notes: Valve (Steam) uses Arch Linux (GCC-based) as foundation for SteamOS. EC AppImage built on Ubuntu 20.04 with GCC - should be compatible with any glibc-based system regardless of host compiler.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Would upgrading EC from Qt5 to Qt6 fix Wayland-related issues?",
      "answer": "Possibly yes - Qt6 has better Wayland support. Jonas suggests: 'could this possibly be an issue that could be chalked up on the fixed if we move to Qt6 list?' Background: Qt5 was designed primarily for X11 with Wayland support added later. Qt6 designed with Wayland as first-class citizen. Specific benefits: 1) Better DPMS (monitor power management) handling, 2) Improved compositor integration, 3) Modern Wayland protocol support, 4) Bug fixes accumulated over years. Challenge: Qt5 to Qt6 migration is significant effort - API changes, deprecated features, PyQt5 to PyQt6 migration. Current EC uses PyQt5 extensively. Multiple users run EC on Wayland without issues (Jonas on Ubuntu 24.04, Andy on Arch), so Qt6 may not be strictly necessary. More immediate fix: Update Qt5 version in AppImage, or use system Qt (AUR package approach). Qt6 migration is on roadmap but not imminent due to complexity and limited maintainer resources.",
      "category": "Network & Architecture"
    },
    {
      "question": "What GitHub PRs were merged for EC in October 2025?",
      "answer": "Several PRs merged during active development period: 1) PR #3120 - Jonas' protobuf reproducibility fix (build paths deterministic), 2) PR #3126 - Small nuisance fix (details not specified in chat), 3) PR #3127 - Jonas whitelisted issues in audit tool: 'Looked thru the list of issues by the audit tool and whitelisted them all.' His summary: 'It makes a red thing turn green, and since I'm the only one on earth that looks at that thing it brings peace to my mind.' Also mentioned: GitHub issue #3121 related to some endorsement matter. JF merged PRs, noting active code review happening. Dustin has pending PRs that need conflict resolution (PR #3086). Community actively maintaining codebase despite limited maintainers. Important: These fixes primarily affect build infrastructure and developer experience, not end-user features. Shows healthy maintenance culture - even 'just makes green light' PRs valued for maintaining code quality standards.",
      "category": "Community & Resources"
    },
    {
      "question": "What is the verbose flag for debugging EC AppImage crashes?",
      "answer": "Run AppImage with -v flag to capture detailed output. Josh: 'I feel dumb. Why didn't I think of this sooner? I'm running the AppImage with the -v (verbose) flag.' How to use: './Electron-Cash-4.4.2-x86_64.AppImage -v 2>&1 | tee ec_debug.log' captures all output. The verbose flag causes EC to print: 1) Library loading information, 2) Qt/GUI initialization details, 3) Network connection attempts, 4) Wallet loading progress, 5) Error messages with stack traces. When Josh ran with -v, crash output showed Wayland-specific function calls (wl_ prefixes), directly identifying display compositor as crash location. Alternative debugging: 1) Run EC from terminal (not desktop launcher) to see stdout/stderr, 2) Check ~/.local/share/Electron Cash/... for EC's own logs, 3) journalctl for systemd logs (if using systemd), 4) dmesg for kernel-level issues (OOM, segfaults). Always capture verbose output when reporting bugs to GitHub - essential for developers to diagnose issues.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is the GitHub workflow policy for EC maintainers with merge privileges?",
      "answer": "Flexible trust-based system. Jonas (newly granted merge privileges) asks: 'Are you OK with me just pushing changes to master if they don't touch the actual EC code? So changes like GitHub Actions, packaging and test cases going straight to master without any review?' JF approves: 'i think that should be fine. Calin usually makes it a point to look at all commits between releases, at least to describe what's in the release.. so the danger of something bad getting in should be minimal.' Calin's perspective: 'for bigger changes I tended to like the extra indirection where I can look at my changes 1 last time before merging... you are a very experienced software professional, Jonas, so I personally trust your judgement here.' Best practices: 1) Small infrastructure changes (CI, tests, packaging) can go directly to master, 2) PRs provide visibility even without formal review - Calin: 'i like the fact that it was a PR because I saw what is going on', 3) Core EC code changes need more scrutiny, 4) Tag maintainers in Telegram for urgent reviews. emergent_reasons: 'it's always safer to just go ahead and make a PR to look at yourself and give someone at least a small window to check it out.'",
      "category": "Community & Resources"
    },
    {
      "question": "Is StartOS suitable for running Electron Cash and BCH infrastructure?",
      "answer": "Good for dedicated BCH infrastructure, not as daily driver replacement. StartOS (formerly Start9) testing underway for BCH. Adaptive Blocksize Limit: 'We are currently testing start9 actually it's very smooth to run but bchn still has some issues... I think the experience of using BCH apps on start9 is better than normal Linux.' emergent_reasons clarifies use case: 'I don't think anybody who uses linux as their daily driver is going to switch to start9 just for bch stuff. But for people who use it for mining or whatever, that seems like a good addition to the package.' Target audience: 1) BCH miners wanting easy infrastructure, 2) Newcomers needing plug-and-play setup, 3) Users wanting dedicated backend services machine. Not for: Daily driver Linux users, developers needing flexibility. Current status: BCHN being packaged (Jordan fixing issues), Fulcrum 2.0 available. Potential future: EC packaging for 24/7 CashFusion. StartOS provides UX simplification but trades off customization typical Linux users expect.",
      "category": "Installation & Setup"
    },
    {
      "question": "Can you receive BCH with a watch-only wallet on Android EC app?",
      "answer": "Yes, but with workaround needed due to UX limitation. User Henrique: 'when I click the receive button it appears This is a watch-only wallet message.' Jonas confirms bug/limitation: 'I can confirm that it does not work to just hit the request button and the wallet will complain that it's watch only.' Workaround: 'You can however go to the Assets tab and choose Addresses with Type: Receiving and Status: Unused to get a QR code to an address.' Background: pat explains watch-only purpose: 'many automated services use this to monitor the payment addresses (associated with cold wallets for example) to credit funds or release goods to buyer.' JF warns about scam vector: 'its a likely scam, people give people a wallet' - receiving to someone else's wallet is losing funds. Key distinction: Watch-only wallets CAN receive funds (blockchain doesn't care), but you CANNOT spend without private key. Android app's Request button just has unnecessarily restrictive UX that blocks QR generation.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "How do you detect CashTokens transactions programmatically in EC?",
      "answer": "Multiple methods available. Adaptive Blocksize Limit's research: 'You can detect token transactions by checking for a tokenData field in BCHN or Fulcrum responses, or by scanning for the 0xEF prefix in raw transaction outputs.' Event handling: 'The payment_received event still fires normally because CT outputs include BCH dust, so the wallet recognizes them as valid UTXO you just need to inspect the tokenData to confirm it's a token payment.' Wallet setup: 'The standard restore_wallet_from_seed() works fine for receiving and detecting tokens, so basically you only need a build if you want to mint, send or burn CT.' BCHN RPC: 'BCHN exposes a tokenData object for every output carrying tokens' - documented at docs.bitcoincashnode.org. Key insight: CashTokens always include BCH dust (minimum sat amount), so normal UTXO detection works - you just need additional parsing for token-specific fields. This enables services like BitCartCC (payment processor) to support CashTokens.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "What gaps exist in EC's CashTokens payment request support?",
      "answer": "Payment request feature doesn't fully support CashTokens yet. ÐÐ»ÐµÐºÑÐµÐ¹ (MrNaif_bel) discovered: 'payment requests feature doesn't support cashtokens, and that's what we use for invoices feature.' Issue details: 'what I just noticed in the output is the tokenreq property, but it's a boolean which is set only by the kotlin gui, and it doesn't do anything in code (maybe only visual filtering).' Events work: 'it indeed fires new_transaction and payment_received events' - basic detection fine. Missing functionality: 1) No way to specify required token amount in payment request, 2) No automatic verification that enough tokens were sent, 3) tokenreq boolean is unused placeholder. Impact: Payment processors like BitCartCC can't easily create invoices requiring specific CashToken amounts. Next step: 'I'll need to create a PR to add cashtokens support for payment requests.' This is infrastructure gap needing community contribution - basic plumbing exists but higher-level features need implementation.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "How do you set up GitHub-to-Telegram notifications for EC repository activity?",
      "answer": "Jonas created dedicated notification channel. Announcement: 'I have fixed the GitHub notifications. To not create noise in this channel I've created a new one where interested parties can see when Issues and PRs are opened and closed: https://t.me/electroncashnotifications' Background: JF noted: 'honestly i dont always check the notifications, but if you tag me here i'll def see it.' Problem: GitHub email notifications often ignored, Telegram more immediate. Implementation: Bot forwards GitHub webhook events to dedicated channel. Benefits: 1) Main EC channel stays focused on discussion, not automated noise, 2) Interested parties opt-in to notifications, 3) PRs get visibility faster, 4) Issue tracking more transparent. Jonas' first task after getting merge privileges: 'I have, as a first order of business, closed ~100 issues (all android) as duplicates' - shows active maintenance happening. This infrastructure improvement helps maintain open source project with distributed volunteer team across timezones.",
      "category": "Community & Resources"
    },
    {
      "question": "What is best practice for merging your own PRs as a maintainer?",
      "answer": "Balance between review and velocity. Calin advises Jonas: 'You can always PR, let it sit for a few minutes then merge or skip that altogether.' For infrastructure changes: Self-merge acceptable. JF: 'for bigger changes I tended to like the extra indirection where I can look at my changes 1 last time before merging to master - sort of see them up on screen in the browser as a diff.' Benefits of PR even for self-merge: 1) CI runs before hitting production (emergent_reasons: 'It should also give the CI an opportunity to hit any CI snags before hitting production'), 2) Provides audit trail, 3) Other maintainers see activity via notifications, 4) Forces self-review in different context. Jonas' approach: Created PR #3128, waited one day, merged himself. Calin: 'you could have even pushed directly for that too tbh.. it's tests so' but 'i like the fact that it was a PR because I saw what is going on.' Trust matters: Jonas given autonomy because experienced professional, but transparency valued even when formal review not required.",
      "category": "Community & Resources"
    },
    {
      "question": "How does CashTokens detection work at the protocol level?",
      "answer": "Uses 0xEF prefix marker in transaction outputs. Adaptive Blocksize Limit explains: 'scanning for the 0xEF prefix in raw transaction outputs' identifies token transactions. Technical details: Standard BCH transaction outputs use locking script starting with standard opcodes. CashTokens prepends 0xEF byte followed by token data (category ID, fungible amount, NFT commitment). This prefix is consensus-validated - nodes recognize it as token marker. Fulcrum/BCHN parsing: 'BCHN exposes a tokenData object for every output carrying tokens' in JSON-RPC responses, containing category (token type ID, 32 bytes), amount (fungible token quantity), hasNFT (boolean), commitment (NFT data). Why BCH dust required: Every CashToken output must include at least 546 satoshis (dust limit) so it's valid UTXO. This means wallet's standard UTXO scanning finds tokens, but needs extra parsing to extract token metadata. Electron Cash 4.3+ has 'transaction parsing, and backend compatibility with Fulcrum' for full programmatic access to this data.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "How do CashTokens differ from Ethereum ERC20 tokens architecturally?",
      "answer": "Fundamentally different: UTXO-based vs account/contract model. ÐÐ»ÐµÐºÑÐµÐ¹ (MrNaif_bel) comparing while implementing BitCartCC support: 'a cashtoken transaction is a BCH transaction... with extra token metadata embedded. there's no such thing as contract methods, right?' Key differences: 1) No approve/allowance pattern - in ERC20 you approve spending before transfer, CashTokens uses direct UTXO spending, 2) No transferFrom - you can only spend UTXOs you own, 3) No gas problems - 'in eth if you receive a token to an empty address, you need to send eth there first to get it out but here because it's utxo, you can just spend it right away', 4) Metadata via BCMR registry instead of contract calls - decimals(), name() replaced by off-chain/on-chain registry lookups. Adaptive Blocksize Limit: 'its utxo VM pure utxo logic better than eth.' Simplicity benefit: 'so there is no concept of allowance? if yes, great, less complexity :D' - cleaner token model without approval vulnerabilities common in ERC20.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "How does EC resolve CashToken metadata (name, decimals, icon)?",
      "answer": "Multi-level fallback system prioritizing on-chain data. ÐÐ»ÐµÐºÑÐµÐ¹ discovered: 'somewhere deep in the code it uses paytaca indexer bcmr.paytaca.com and if not, it then tries to parse from token genesis tx or something.' Resolution order: 1) Try Paytaca BCMR indexer (centralized aggregator), 2) Fall back to on-chain BCMR embedded in genesis transaction, 3) Check DNS-based BCMR at /.well-known/bitcoin-cash-metadata-registry.json. Mathieu G clarifies: 'Most CashTokens use on-chain resolution, not DNS resolution.' On-chain embedding: Token creator can put BCMR JSON in OP_RETURN of genesis tx - fully decentralized, no external dependencies. Example registries: otr.cash/.well-known/bitcoin-cash-metadata-registry.json, meta.moria.money/m1.json (MUSD specific). For programmatic use: 'use the try_to_download_metadata function from token_meta, and save to cache' - EC provides this abstraction. 2qx notes: 'FBCH uses DNS' showing both approaches coexist.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "What core functions are needed to integrate CashTokens into a payment processor?",
      "answer": "ÐÐ»ÐµÐºÑÐµÐ¹'s implementation plan for BitCartCC identifies three essentials: 'we only need 3 things: detect payments (invoicing), get balance, send.' Detailed approach: 1) DETECT PAYMENTS: new_payment event fires for token receipts, filter by enabled tokens, parse token_data for amounts, 2) GET BALANCE: wallet.get_utxos(tokens_only=True), group by category_id, use token_meta.format_amount() for decimal handling, 3) SEND TOKENS: make_token_send_spec() to create data structure, wallet.make_token_send_tx(), wallet.sign_transaction(). Metadata handling: Create BasicTokenMeta class, call try_to_download_metadata() to get name/decimals, cache results. Storage: 'store only category id, name, decimals' - minimal footprint. Payment requests gap: tokenreq boolean exists but unused in code - needs PR to fully support requesting specific token amounts. Note: 'don't support NFT tokens' - focus on fungible tokens for payment use case makes sense.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Can CashFusion run in EC daemon mode without GUI?",
      "answer": "Not out-of-the-box, but theoretically possible with configuration. Josh asks: 'can fusions happen when running EC as a daemon?' to work around Wayland crash issues. Pierre K's assessment: 'I don't think fusing can work out of the box in daemon mode, but adding a daemon command for it is not too difficult.' His 2022 research: 'i needed to add a daemon command to the cash fusion plug-in to call the plugin's enable_autofusing method for each loaded wallet and then start tor.' JF provides workaround: 'there's a wallet level param cashfusion_autofuse' - if set to true in wallet file, might enable fusion. Dustin elaborates: 'when you leave it on in the wallet and close it, it is still on when you re-open, so maybe if you load the wallet in daemon mode it would fuse.' Key insight: Fusion state persists in wallet file, so enabling via GUI once, then running daemon might work. Pierre: 'Maybe there is a way just by hacking the config file or the wallet file prior to starting the daemon that i missed.' Community needs testing to confirm.",
      "category": "CashFusion"
    },
    {
      "question": "What is on-chain BCMR resolution vs DNS-based BCMR?",
      "answer": "Two approaches for CashToken metadata discovery. DNS-based: Token project hosts JSON at domain/.well-known/bitcoin-cash-metadata-registry.json - relies on web infrastructure, simpler to update but introduces external dependency. On-chain: BCMR JSON embedded directly in token's genesis transaction OP_RETURN - fully decentralized, immutable, no external lookups needed. Mathieu G: 'Most CashTokens use on-chain resolution, not DNS resolution.' 2qx counters: 'FBCH uses DNS. All the series weren't issued at once, but if they had been, it would have been about half the CashTokens issued.' Trade-offs: On-chain is censorship-resistant and permanent but harder to update metadata. DNS is flexible but requires maintaining web infrastructure. Practical impact: Wallets like EC query Paytaca indexer first (aggregates both), then fall back to on-chain parsing. Token explorers like tokenexplorer.cash resolve from chain. For payment processors: Can use EC's try_to_download_metadata() which handles both resolution types automatically.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Why are BCMR registries decentralized rather than having single canonical source?",
      "answer": "Intentional design choice for censorship resistance and permissionlessness. Adaptive Blocksize Limit: 'Electron Cash doesn't hardcode any BCMR registry URLs but its just by design, BCMR is fully decentralized anyone can publish one.' ÐÐ»ÐµÐºÑÐµÐ¹ initially expected central registry: 'all current stablecoins and stuff, surely they are published somewhere?' Reality: Each token project publishes own BCMR, aggregators (Paytaca indexer) collect them but aren't canonical. Examples of fragmentation: otr.cash registry doesn't include MUSD, meta.moria.money/m1.json is MUSD-specific, tokenexplorer.cash aggregates from chain. For developers: Must handle multiple sources or rely on aggregator. ÐÐ»ÐµÐºÑÐµÐ¹'s solution: 'use try_to_download_metadata function from electroncash' which tries Paytaca then falls back to on-chain parsing - abstraction handles complexity. Trade-off: More robust (no single point of failure) but requires discovery logic. Similar to how Bitcoin doesn't have 'official' explorers - decentralization means redundancy and independence.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "What's the difference between CashToken category ID and token name?",
      "answer": "Category ID is cryptographic identifier, name is human-readable metadata. Category ID: 32-byte hash (genesis transaction ID), globally unique, immutable - this is what blockchain sees. Example: b38a33f750f84c5c169a6f23cb873e6e79605021585d4f3408789689ed87f366 (MUSD). Name: Human string like 'MUSD' or 'Moria USD' - stored in BCMR metadata, can theoretically be duplicated by different tokens. ÐÐ»ÐµÐºÑÐµÐ¹'s storage model: 'store only category id, name, decimals' - category_id is the key, name is display convenience. When integrating: 'wallet.get_utxos(tokens_only=True) tokens = group by category id' - always use category_id for logic, name only for UI. Decimals crucial: Different tokens have different decimal places, BCMR provides this info. Why this matters: You might have tokens with same name but different category_ids (one could be scam), always verify by category_id. Similar to how contracts on Ethereum have address as true identifier, not name.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "How does EC's payment_received event work with CashTokens?",
      "answer": "Standard event fires because CashToken outputs include BCH dust. Adaptive Blocksize Limit explains: 'The payment_received event still fires normally because CT outputs include BCH dust, so the wallet recognizes them as valid UTXO you just need to inspect the tokenData to confirm it's a token payment.' ÐÐ»ÐµÐºÑÐµÐ¹ confirms after testing: 'it indeed fires new_transaction and payment_received events.' Why dust required: Every CashToken UTXO must include minimum 546 satoshis (BCH dust limit) - consensus rule ensures tokens are valid UTXOs. Implementation: Event handler receives standard UTXO notification, then parse token_data field to check if it's token transfer. Filtering: 'we just filter by those enabled in the daemon' - only process tokens you care about. Gap discovered: 'payment requests feature doesn't support cashtokens... but I am not sure how to make it detect if I sent just enough tokens' - verification of correct token amount needs additional logic beyond event handling. This design elegance: Reuses existing UTXO infrastructure rather than creating parallel token-specific event system.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "What are the security concerns with unknown developers submitting EC to F-Droid?",
      "answer": "Major supply chain risk. Unknown developer submitted fastlane PR (#3137) and F-Droid build without prior engagement with EC team. Calin: 'So weird.. out of nowhere some dude using Arabic script for a name does some stuff.' Mathieu G warns: 'i think there's a pretty large chance the person will try to scam people and steal their funds if they are not known.' Concerns: 1) Developer could modify source before F-Droid build, 2) GitHub Actions vulnerabilities could enable unauthorized publishing, 3) F-Droid builds aren't reproducible so can't verify binary matches source, 4) Unknown developer controls namespace. emergent_reasons strongly advises: 'If something gets posted with electron cash name by someone other than electron team, it must be called out loudly and everywhere as a likely scam.' JF acknowledges: 'its kind of weird that out of the blue someone no one knows just decided to make a build for f-droid.' Even well-intentioned contributors need vetting when handling wallet software accessing user funds.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How does F-Droid building/signing differ from Google Play Store?",
      "answer": "Both platforms re-sign apps, but with different trust models. Tom explains: 'fdroid just uses the plain repo's and builds it 100% on their own system and signs it... Notice that Play Store releases are signed by Google, NOT Jonald. He signs just to allow uploading to Google's servers, they re-sign it to publish.' Key differences: Play Store: Developer signs to upload, Google re-signs for distribution. F-Droid: Builds directly from source on their servers, signs with F-Droid key. Jonas notes: 'The Play Store releases are at least signed by Jonald, but here it seems like it's built by a f-droid backend.' Tom's recommendation: 'it would be smart to use a different ID for both, so they can be installed at the same time as distinctly different apps' - prevents compatibility errors from different signatures. Security implication: Neither platform provides reproducible builds by default, both require trusting the distribution platform. F-Droid advantage is build from source (auditable), disadvantage is no developer signature verification.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What GitHub Actions security risks should open source projects watch for?",
      "answer": "PRs adding GitHub Actions can introduce supply chain vulnerabilities. ÐÐ»ÐµÐºÑÐµÐ¹ warns: 'there are some github actions vulnerabilities where they get ability to publish if you don't restrict access to publishing scope only to some workflows.' Specific concerns with suspicious PR: Added new workflow files, uses external actions from unknown sources, could potentially gain write access to repo. Jonas explains: 'If you open a pull request it is executed on the source repo' - PR code runs with elevated privileges. Best practices: 1) Be vigilant on GHA especially 'pull_request_target' trigger (has write access), 2) Review all workflow additions carefully, 3) Restrict publishing scope to specific workflows, 4) Don't blindly trust 'copied from Electrum' claims. Calin's response: 'Idk I feel like closing this esp since it has unneeded GitHub actions.' Jonas: 'I don't see the issue with this GHA' but acknowledges: 'it's good to vigilante on GHA.' Even legitimate automation tools (fastlane) need scrutiny when added by unknown contributors.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Does EC cache CashToken metadata differently in GUI vs CLI mode?",
      "answer": "Yes, significant difference discovered. Dustin explains GUI behavior: 'EC keeps the metadata, though, at least in the GUI, you only have to download it once per token... it'll show the category ID only until you right click and fetch category metadata. Close and re-open before and after doing that, it's fetched when you hit fetch.' However, ÐÐ»ÐµÐºÑÐµÐ¹ found CLI limitation: 'in all usages of cli it doesn't save the cache back to disk :D' - metadata downloads but isn't persisted. Details: GUI stores in simple config after manual fetch, persists across sessions. CLI loads cache if exists but doesn't write new entries. ÐÐ»ÐµÐºÑÐµÐ¹: 'well if I checked correctly that's the point, it silently fetches it in background but still doesn't cache anywhere.' Dustin suggests: 'I wonder if the CLI uses the cache when it exists...' ÐÐ»ÐµÐºÑÐµÐ¹ confirms: 'it does, but if I checked correctly, in all usages of cli it doesn't save the cache back to disk.' This inconsistency affects payment processor integrations - need to implement own caching layer or fix EC's CLI caching.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Why doesn't CashFusion work in daemon mode and what's the workaround?",
      "answer": "Daemon mode lacks automatic fusion initialization. Josh tested: 'When running in daemon mode, I open another terminal and run AppImages/electron_cash.appimage daemon -C cashfusion_autofuse just to see if it'd do something but nope...just start, stop, status, load_wallet, and close_wallet.' Pierre K's research from 2022: 'i needed to add a daemon command to the cash fusion plug-in to call the plugin's enable_autofusing method for each loaded wallet and then start tor.' No existing CLI command triggers fusion. Possible workaround: JF notes wallet stores 'cashfusion_autofuse' boolean - if enabled via GUI first, might persist. Dustin: 'when you leave it on in the wallet and close it, it is still on when you re-open, so maybe if you load the wallet in daemon mode it would fuse.' Pierre: 'Maybe there is a way just by hacking the config file or the wallet file prior to starting the daemon that i missed.' Not confirmed to work. Real fix needs daemon command addition - Jonas jokes: 'Lmk when you add it to ABC so I can steal it!' Workaround for Wayland crash: Run GUI once to enable, then use daemon.",
      "category": "CashFusion"
    },
    {
      "question": "What is fastlane and why did it raise concerns in EC repo?",
      "answer": "Fastlane is mobile app automation tool for app store submissions. emergent_reasons: 'fastlane seems to be an automation setup for mobile apps.' Used for: Automating screenshots, uploading to app stores, managing metadata. PR #3137 added fastlane configuration for F-Droid submission. Concerns: 1) Unknown developer submitted it without prior discussion, 2) Includes GitHub Action that runs on PR events, 3) Contains app screenshots in repo (Jonas: 'I'm not sold on having screenshots of the app within the git repo'), 4) Copied from Electrum but not customized explanation. Dustin: 'looks like someone trying to include EC on F-Droid based to that.' Jonas investigates: 'It seems like the fastlane metadata can be used when updating on Google Play Store also, which I guess is useful.' Tom: 'IIRC f-droid allows you to have a second repo with the fdroid specific stuff.' Jonas' preference: 'any Android specific metadata should be in the android/ subdirectory' not repo root. Decision: Wait for known maintainers to review before merging anything from unknown contributor.",
      "category": "Community & Resources"
    },
    {
      "question": "Should Ledger work with EC on macOS and what causes detection failures?",
      "answer": "Should work but has known issues. User T reports: 'my ledger is never detected while ledger live works well... I tried with nano s and nano x.' Common causes: 1) Ledger Live app holding exclusive device access - close it completely before using EC, 2) macOS USB permissions - EC may not have device access, 3) Browser extension conflicts, 4) Outdated EC version incompatible with newer Ledger firmware. Troubleshooting steps: Close Ledger Live completely (check Activity Monitor), try different USB port, ensure EC has USB access in macOS System Preferences, update EC to latest version. Note: Ledger Live uses WebUSB which can conflict with EC's direct USB library (hidapi). On macOS specifically, USB device access permissions more restrictive than Linux. If still failing: Check EC verbose output for USB enumeration errors, try running EC from terminal to see connection attempts. Hardware wallet support is plugin-based in EC, ensure plugin is enabled in Tools > Plugins menu.",
      "category": "Hardware Wallets"
    },
    {
      "question": "How should CashToken amounts be represented in payment request CLI commands?",
      "answer": "Integer base units preferred for backend, formatted amounts for display. ÐÐ»ÐµÐºÑÐµÐ¹'s analysis: 'amount is integer in whatever unit it is and it works but amount (BCH) makes no sense for cashtokens.' Problem: Payment requests show 'amount (BCH)' field with formatted decimal value - meaningless for tokens with different decimals. Options: 1) Add 'token_amount' field with raw integer (no formatting), 2) Query BCMR for decimals and format as 'amount (TOKEN_NAME)', 3) Let consumers handle formatting themselves. ÐÐ»ÐµÐºÑÐµÐ¹ prefers: 'basically if I want to format the payment request I need to request it's BCMR metadata via paytaca indexer/search in blockchain, which might be an expensive operation.' His approach: Cache decimals on his side (BitCartCC), not burden EC with additional caching. Dustin suggests: 'I would leave amount (BCH) but you could add token_amount and not worry about token_amount (whatever)' - backwards compatible. Consensus: Raw amounts in smallest unit (like satoshis) internally, formatting is presentation layer concern. No standard term for CashToken's smallest unit (satoshi equivalent) yet established.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "How does F-Droid's trust model actually work for app distribution?",
      "answer": "F-Droid only trusts git repositories, not individual submitters. Tom clarifies widespread misconception: 'the f-droid project specifically does not trust any person, it only trusts a git url. It never gets the data from a person, it gets the data from one or more git repositories you publish.' Key implications: 1) Unknown person submitting PR is irrelevant - F-Droid builds from EC's official GitHub, 2) All metadata (screenshots, descriptions) must live in EC's repo under their control, 3) EC maintainers approve all changes through normal merge requests. Tom: 'the ONLY thing you need to check is if the fdroid stuff links to the trusted git repos... No trust is needed because fdroid is designed to only pull from your git repos.' Damascene confirms: 'The person who submit has no power over it. F-droid will verify and handle it so it auto build from your git.' This design provides transparency - code is auditable, build process is known. Remaining trust required: F-Droid's build infrastructure itself, hence importance of reproducible Android builds to verify their output matches source.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why is RPA wallet change address handling a privacy concern?",
      "answer": "RPA wallets lack separate change derivation, causing linkability issues. Jonas warns: 'Be careful when spending from the RPA wallet. Best thing to do is to send each and every UTXO separately to a normal wallet and fuse from there.' Dustin explains problem: 'IIUC, all change consistently goes to the same address, tying each transaction from the wallet together.' JF details implementation: 'If you're asking about sending from an RPA wallet, there's no change address, so whether you're doing a normal send or another RPA send, the change goes back to the originating UTXO.' Privacy impact: Andy: 'If you use multiple UTXOs in one transaction they're linked and chain analysis can determine who you are if you mix with exchange funds.' Recommended workflow: 1) Receive to RPA wallet (protects sender's privacy), 2) Transfer each UTXO individually to normal wallet, 3) Use CashFusion from normal wallet to break linkability. Inter-Wallet Transfer plugin automates this: github.com/KarolTrzeszczkowski/Inter-Wallet-Transfer-EC-plugin. Current RPA is privacy tool for receiving, not comprehensive privacy solution for spending.",
      "category": "Privacy & Address Management"
    },
    {
      "question": "Can you reverse or cancel an unconfirmed BCH transaction?",
      "answer": "No, once broadcast transactions cannot be reversed by anyone. User asks: 'Can someone reverse or stop a transaction?? It hasn't confirmed yet.' Blockchain fundamentals: 1) Once transaction is broadcast to network, it propagates to all nodes, 2) No central authority can cancel it, 3) Recipient controls funds once transaction is valid, 4) Even unconfirmed transactions are typically irreversible. Exception: Double-spend attempt possible but unreliable (need to broadcast conflicting transaction quickly with higher fee, most merchants wait for confirmation). BCH specific: 10-minute block times mean short wait for confirmation, 0-conf transactions considered reliable for small amounts due to first-seen-safe miner policies. Prevention better than cure: Always triple-check recipient address before sending. User resolved issue: 'Never mind all sorted out' - likely realized address was correct. This is feature not bug: Censorship resistance means no reversals, but also means no one can stop legitimate transactions.",
      "category": "Transactions & Fees"
    },
    {
      "question": "How do you limit EC to single CPU core on Linux for performance testing?",
      "answer": "Use taskset command to set CPU affinity. ErdoganTalk asks: 'is it possible to limit ElectronCash to 1 processor/thread only?' Jonny's solution: 'You can spawn the program via the taskset command that limits the process to the cpu/thread you want.' Two approaches: 1) Launch with restriction: 'taskset -c 0 electron-cash' binds to CPU 0, 2) Modify running process: 'taskset -p -c 2 PID' where PID is python3.11 process. ErdoganTalk's experience: 'I had to start ElectronCash, then change processor affinity to 2 (or any number 0-7) on the process number for python3.11.' Use cases: 1) Testing single-threaded performance, 2) Preventing EC from monopolizing resources, 3) Debugging concurrency issues, 4) Energy efficiency on laptops. Note: EC is Python application, already limited by GIL (Global Interpreter Lock), but still uses multiple threads for I/O operations. Setting affinity primarily useful for controlling resource usage rather than improving performance.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why did Google Play Store change to AAB uploads and how does it affect trust?",
      "answer": "Google now re-signs all apps, reducing developer control. Tom explains: 'It was just a couple of years ago when they switched over from apk uploads to aab uploads, which are multi-arch capable.' Key change: Developer signs AAB to upload, Google re-signs with their key for distribution. Rationale: 1) Multi-architecture support (single upload serves different devices), 2) Smaller downloads (device gets only needed code), 3) Key management - 'owner could change signing keys in the play store webapp without hurting actual installs. For instance when a company fired members that they were afraid would have a copy of the signing keys.' Security implications: Users trust Google's signature, not developer's directly. This mirrors F-Droid model where platform controls final signing. Both approaches require trusting distribution infrastructure. For cryptocurrency wallets: Neither Play Store nor F-Droid provide end-to-end verification that binary matches source. Reproducible builds solve this - allowing users to verify any build matches auditable source code. Currently EC doesn't have reproducible Android builds, making this trust necessary.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Is RPA (Reusable Payment Address) feature production-ready in EC?",
      "answer": "Yes, stable and live for over a year. Glaxweb asks: 'any update with the reusable public key project?' Shadow confirms: 'Yes, it is LIVE in latest Electron Cash, has been for a year+. You need to create a new wallet and choose RPA as the wallet type.' Stability status: 'Indeed, it is a stable feature. I don't remember any serious bugs reported [lately].' Setup: File > New Wallet > RPA Wallet type. Use case: Share one address publicly, each sender's payment goes to unique derived address - protects sender privacy and prevents address reuse. Limitations to understand: 1) Change goes back to same address when spending (breaks privacy), 2) CashFusion not available in RPA wallets directly, 3) Best practice is sweep UTXOs individually to normal wallet before spending. Future: Work ongoing to integrate RPA into normal wallets with CashFusion support. Current RPA is specialized tool for receiving payments with enhanced sender privacy, not replacement for regular HD wallets.",
      "category": "Privacy & Address Management"
    },
    {
      "question": "What DDoS protection works for BCH block explorers?",
      "answer": "Anubis proof-of-work challenge effective and easy to deploy. ichundes reports: 'i had to put ddos protection in front of my explorer because some botnet was hitting it to the point of memory exhaustion.' Solution: 'it was quite easy to set up the protection using anubis.techaro.lol.' How it works: First-time visitors solve brief proof-of-work challenge (like mini-mining), bots struggle with computational cost while humans barely notice. Attack context: 'this is likely part of some botnet c&c, but why scrape the explorer instead of just directly querying fulcrum?' ichundes theorizes: 'traffic on port 443 looks more normal and is allowed by more firewalls.' Tom notes broader pattern: 'I've noticed a lot of scraping of stupid content... I think this is all just AI training data that is being resold.' Traditional IP blocking ineffective: 'I started with an IP blockage solution, but after blocking thousands (and some subnets) they just kept coming from new ones.' Proof-of-work protection superior: Shifts cost to attacker proportionally to their scale, legitimate users unaffected. Infrastructure operators should implement before attacks, not after.",
      "category": "Network & Architecture"
    },
    {
      "question": "What is the Inter-Wallet Transfer plugin and why is it useful for RPA?",
      "answer": "Plugin automates moving UTXOs between wallets individually for privacy. Andy mentions: 'There's an inter-wallet transfer plugin that can automate it.' 2qx provides link: github.com/KarolTrzeszczkowski/Inter-Wallet-Transfer-EC-plugin. Created by Karol Trzeszczkowski. Use case: RPA wallet receives multiple payments, each to unique derived address. To maintain privacy when spending: Transfer each UTXO separately to CashFusion-enabled wallet. Manual process is tedious with many UTXOs. Plugin automates: 1) Select source wallet (RPA), 2) Select destination wallet (normal with CashFusion), 3) Configure to transfer one UTXO per transaction, 4) Plugin executes transfers automatically. Adaptive Blocksize Limit: 'This would be very helpful for me until RPA make it to normal wallets where we can use cashfusion.' Important: Without this automation, users might combine multiple RPA UTXOs in single transaction, destroying privacy benefit. Plugin is third-party, verify code before trusting with funds. Maintainer is known EC plugin developer, same person who created scheduled payments plugin.",
      "category": "Privacy & Address Management"
    },
    {
      "question": "Does Python's GIL prevent EC from using multiple CPU cores effectively?",
      "answer": "Yes, Python's Global Interpreter Lock limits concurrency. Calin explains: 'it only uses 1 thread anyway because python' and 'Python is single-core always.. it doesn't really parallelize.' When user asks about limiting EC to single CPU core, Calin notes: 'you don't even need to do this.' Technical details: GIL ensures only one Python thread executes bytecode at a time, even on multi-core systems. This prevents true parallelism for CPU-bound tasks. However, EC uses multiple threads for I/O operations (network requests to Fulcrum servers, GUI rendering via Qt), which can release GIL during blocking operations. Why matters: Memory usage is better metric than CPU core usage for EC. Memory leaks affect performance more than core availability. Workarounds exist: multiprocessing module (not used in EC), native extensions can release GIL (libsecp256k1 does this). For CashFusion, bottleneck is network I/O and cryptographic operations (mostly in C extensions), not Python bytecode execution. GIL mostly impacts batch operations like scanning entire blockchain.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why can't Fulcrum servers easily run on port 443 alongside web servers?",
      "answer": "Protocol mismatch: Fulcrum uses raw TCP, not HTTP. tula s asks: 'why are all the EC servers on 50002? wouldnt it make sense to put a few on 443?' Problem: Running behind corporate firewalls requires port 443 (HTTPS), but Fulcrum uses JSON-RPC over TCP without HTTP headers. Andy explains: 'Fulcrum needs TCP reverse proxying and the website needs HTTP... There's no headers in fulcrum requests to filter on.' Nginx reverse proxy challenge: HTTP servers identified by Host header, but raw TCP connections have no such identification. Calin confirms: 'fulcrum doesn't use http (unless you are using the websockets interface...)' and 'raw bare TCP sockets which have no headers and no way to filter.' Workaround: pat shares solution: 'I combine the self-signed 50002 classic port exposed from docker with a 443 aided by nginx + ssl configured for my domain name over a reverse proxy.' Requires different subdomain/IP for Fulcrum on 443. Fulcrum does have WebSocket endpoint (HTTP-based) which could work, but EC clients expect traditional TCP connection. Corporate firewall workaround remains challenge.",
      "category": "Network & Architecture"
    },
    {
      "question": "Does F-Droid require reproducible builds for app inclusion?",
      "answer": "Unclear but highly encouraged. Kallisti states: 'Fdroid requires reproducible builds afaik.' Jonas seeks clarification: 'Do you know if there is any verification of it done by f-droid before it's published?' Kallisti: 'They have some kind of review process I think.' Reality: F-Droid encourages reproducible builds but doesn't strictly require them. They do mandate building from source on their infrastructure. Verification approach: Shadow mentions: 'I read somewhere that F-Droid has some automation tools that verify the binary was indeed built from the provided source.' Jonas suggests workaround: 'The apk wont be reproducible, but there are scripts that will strip signatures and compare the files.' Trust implications: Without reproducibility, users trust F-Droid build infrastructure. With reproducibility, users can independently verify. Signal messenger has done significant work on reproducible Android builds. Challenge for EC: Chaquopy (Python-on-Android framework) may introduce non-deterministic elements. Needs investigation. Best practice: Aim for reproducible builds even if not strictly required.",
      "category": "Security & Best Practices"
    },
    {
      "question": "How do you configure Fulcrum on both standard and firewall-friendly ports simultaneously?",
      "answer": "Use nginx reverse proxy with different subdomains. pat demonstrates: 'I combine the self-signed 50002 classic port exposed from docker with a 443 aided by nginx + ssl configured for my domain name over a reverse proxy. so fulcrum.pat.mn:443 and fulcrum.pat.mn:50002 are available at the same time.' Setup: 1) Fulcrum binds to internal port (e.g., 50002), 2) Nginx terminates TLS on port 443 using domain certificate, 3) Nginx proxies to Fulcrum's internal port. Important: This works because Fulcrum gets its own subdomain - nginx can route based on Server Name Indication (SNI) in TLS handshake. Andy's concern: 'If you ran it on 443 you wouldn't be able to run a web server on the same IP' - true for same domain, but different subdomains work. Calin acknowledges: 'i can configure my server to offer an alternate 443 port for ssl' but federation/peering logic needs consideration. Benefit: Corporate networks that only allow 443 can now connect. WSS (WebSocket Secure) is alternative but requires client support.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why does EC fail to export P2SH input addresses in transaction data?",
      "answer": "Parsing limitation: EC's scriptSig parser doesn't handle general P2SH contracts. emergent_reasons discovers: 'if I add some debug to the export code, it sees this for p2sh inputs... address: None.' Investigation reveals: 'It even looks like the scriptsig parser just doesn't even try to parse p2sh20 or p2sh32... cannot find address in input script.' Root cause: EC's parse_scriptSig() designed for specific input types (P2PKH, multisig P2SH) but not arbitrary P2SH contracts. Bitcoin/BCH inputs contain scriptSig (unlocking script) that doesn't explicitly include address - address must be derived from script hash. For multisig: EC recognizes pattern and computes P2SH address. For general P2SH: Parser gives up, returns type='unknown', address=None. Impact: Transaction export (JSON format) missing input addresses for smart contracts like CashScript covenant transactions. Dustin: 'I noticed that a long time ago, but it isn't an issue for my use case' (uses multisig P2SH which works). emergent_reasons offers bounty for fix: 'willing to pay for a local fix.' This is technical debt from EC's P2PKH-centric design.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What PR added CashTokens support to EC payment requests?",
      "answer": "PR #3144 by ÐÐ»ÐµÐºÑÐµÐ¹ (MrNaif_bel from BitCartCC). Announcement: 'The PR for cashtokens in paymentrequests is up: github.com/Electron-Cash/Electron-Cash/pull/3144.' Implementation details: 'I didn't add amount formatting because didn't get a reply here' - uses raw integer amounts (like satoshis) rather than decimal-formatted token amounts. Decision was intentional to avoid BCMR metadata caching complexity. Additional discovery: 'Also noticed another bug I'll submit a fix for later - if to pay a payment request of let's say 1 BCH in 2 payments, first of 0.1 BCH, second of 1 BCH, initially it returns first tx hash. after paying 1 BCH it returns only the second tx hash, but not both.' Fix exists in upstream Electrum to backport. Context: BitCartCC (BCH payment processor) integrating CashTokens support, needs this EC feature for invoicing. Shows ecosystem development: Third-party services contributing back to core wallet infrastructure. Community appreciates: Shadow gives thumbs up. PR under review by maintainers.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Is Electron Cash developed by a company with paid support staff?",
      "answer": "No, EC is volunteer-driven open source project. emergent_reasons clarifies when user asks for help: 'It's not a company - just volunteers who use and support Electron Cash. If you have a question, please post here.' Important implications: 1) No paid support staff, 2) No guaranteed response times, 3) Development depends on volunteer availability and interest, 4) Funding comes from flipstarter campaigns for specific features. Community structure: Core maintainers (Calin, JF, Jonas, EchterAgo) donate time, regular contributors (Dustin, emergent_reasons, Shadow) help with support and testing. Best practices for getting help: Post questions in public Telegram channel (not DM to avoid scams), provide technical details (version, OS, wallet type), check GitHub issues first, be patient. Contribution welcome: Anyone can submit PRs, report bugs, test releases, write documentation. JF notes: 'its an open source project. in theory anyone should be able to contribute.' Warning: emergent_reasons reminds: 'Please don't post payment links' - scam vectors exist, official channel is volunteer-run community, not commercial service.",
      "category": "Community & Resources"
    },
    {
      "question": "What tools help simplify nginx reverse proxy configuration?",
      "answer": "https-portal Docker container recommended. Damascene suggests: 'Use https-portal it made my life easier.' WT complains: 'I always crash and burn when I try to configure nginx.' https-portal provides: Automatic Let's Encrypt certificate renewal, simple configuration syntax, Docker integration, reverse proxy setup without deep nginx knowledge. Alternative approaches: Direct nginx configuration (complex but flexible), Caddy (simpler config than nginx), Traefik (container-native). For Fulcrum specifically: Tom shares example: 'I recently used the idea of wrapping a http-only in nginx to make it use the https part of the bigger website. It's awesome.' Points to Flowee wallet-backup-server readme for configuration example. Key insight: Infrastructure complexity shouldn't prevent running BCH services. Tools like https-portal lower barrier to entry. Important: Still need to understand what you're proxying - nginx is just traffic routing, doesn't modify Fulcrum's protocol requirements.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why does EC's scriptSig parser fail for non-multisig P2SH inputs?",
      "answer": "Uses heuristic pattern matching that doesn't cover general P2SH. Calin explains: 'it's a heuristic matcher.. and there is no general solution.' The algorithm: 1) Do I see 1 push? â p2pk, 2) Do I see 2 pushes? â p2pkh, 3) Do I see OP_0 then more pushes? â p2sh multisig, 4) Otherwise â unknown. Problem: Non-multisig P2SH contracts (like CashScript covenants) often have different push patterns. Calin: 'As an increasing number of p2sh are NON multisig... the heuristic scanner is now being exposed for the fraud that it is!' Why unsolvable locally: 'there is no way to improve it... because the problem is unsolvable with scriptSig alone as the only thing one has to examine.' Bitcoin transactions only include unlocking script (scriptSig), not locking script (previous output). Without knowing original locking script, can't definitively determine input type. Tom reinforces: 'The issue is that if you're looking at one transaction, you have the redeem. But you would need to fetch the old transactions to get the rest of the script.' Solution: Fetch previous transaction outputs from network.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is the technical reason there's 'no such thing as a from address' in Bitcoin?",
      "answer": "Inputs reference UTXOs, not addresses - address derivation requires assumptions. Tom warns: 'just want to jump in and remind people that there is no such thing as a from address. It just happens to work in a lot of cases, but if you build software to depend on it, you will feel pain at some point.' Technical reality: Transaction inputs contain: prevout_hash (previous tx ID), prevout_n (output index), scriptSig (unlocking data). No explicit address field. To get 'from address': Must examine previous transaction's output script, parse that script to determine type (P2PKH, P2SH, etc.), hash appropriately to create address. This fails for: Complex contracts with multiple spending paths, P2S scripts (coming next year), coinbase transactions, non-standard scripts. Tom's advice: 'Adding a refund address should be part of a good payment protocol.' For accounting/UX: Address derivation is convenience feature, not protocol requirement. emergent_reasons confirms: 'I think tom is talking about refund addresses, but that's not what I need anyway' - his use case is transaction export for accounting, where addresses are needed for reporting despite protocol limitations.",
      "category": "Network & Architecture"
    },
    {
      "question": "How did Calin's PR #3145 fix the P2SH export address issue?",
      "answer": "By fetching previous transaction outputs instead of relying on heuristics. Calin explains: 'yes it fixes the problem by getting the actual spent coins because there is no way to solve this problem from the scriptSig alone.. you ultimately need the previous output (spent coin) for the txn.' Implementation: 'this PR just does that -- leverages the fetch inputs subsystem from transaction.py to go out to the network and determine spent coins for a txn.' PR link: github.com/Electron-Cash/Electron-Cash/pull/3145. Testing: emergent_reasons confirms: 'Tried it and it worked!' Benefit: Export history now includes correct input_addresses for all transaction types, not just P2PKH and multisig. Trade-off: Requires network access during export (fetches previous txs), may be slower for large histories, adds external dependency. Context: This fixes export functionality specifically, not the general-purpose transaction parser. Calin: 'there is no solution, sadly, if the only information one has to fix it is the scriptSig.. you need to go back to the previous output scriptPubKey to know for sure.' Export can use network since it's not a real-time operation.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "Why do some P2SH inputs get incorrectly identified as P2PKH?",
      "answer": "Heuristic parser looks for 2 pushes pattern. Calin details: 'the heuristic scanner will falsely think p2pkh if it sees 2 pushes and the first push is not 0. A legit p2sh (non-multisig) can match that pattern then the heuristic scanner just thinks p2pkh (wrongly).' P2PKH pattern: <signature> <pubkey> - exactly 2 pushes. P2SH with 2 pushes: <data> <redeemScript> - also 2 pushes! If P2SH contract's redeem script only needs one piece of data, scriptSig has 2 pushes total and gets misidentified. Conversely, correct P2SH detection: 'if it sees OP_0 as the first push, it thinks p2sh and then correctly matches.' OP_0 is required for standard multisig (BIP 11) due to OP_CHECKMULTISIG bug. emergent_reasons explains: 'The decoder is using a heuristic to identify each input as a p2pk, p2pkh, multisig-p2sh, or give up. The heuristic for p2pkh can catch p2sh in at least one specific case (2 pushes).' Dustin confirms: 'looking at the JSON where the addresses show up, it indicates the type is p2pkh (it's not, it's P2SH)' - false positive working by accident.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How can you derive P2SH address from redeem script if you have it?",
      "answer": "Hash the redeem script and encode appropriately. Dustin: 'I can plug both redeem scripts into my little address generation script and get the right address for both of them, but at that point, I'm not using heuristics.' Calin confirms: 'yeah if you know for SURE it's a redeemScript as your last push.. then yeah hash it and voila! correct address.' Process: 1) Extract last push from scriptSig (this is redeem script in P2SH), 2) For P2SH20: HASH160(redeemScript) â 20 bytes, 3) For P2SH32: SHA256(redeemScript) â 32 bytes, 4) Encode with Cash Address format. Challenge: 'but the general purpose transaction parser has no way of knowing that for sure... unless... it can examine the locking script of previous txn.' Can't assume last push is always redeem script - could be P2PKH signature followed by pubkey, or other patterns. Dustin: 'I can derive the address from that script (though I was wrong about using bitcash, I used cryptos).' Python libraries like cryptos or EC's own Address class can handle encoding. Key insight: If you control the script and know it's P2SH, address derivation is trivial. General-purpose parsers can't make that assumption.",
      "category": "Transactions & Fees"
    },
    {
      "question": "What is P2S and why will it change transaction parsing next year?",
      "answer": "P2S (Pay-to-Script, native script addresses) is upcoming BCH upgrade. Tom: 'Anything that isn't p2pkh or p2sh. Now, granted, today that means those transactions are not standard. But next year you'll see a lot of p2s ones.' emergent_reasons: 'ah. yeah p2s soon. fun times :D' P2S characteristics: Native script outputs (not wrapped in hash), introspection capabilities, VM limits improvements. How it differs: Current P2SH: Output contains hash of script, script revealed at spending time. P2S: Output contains actual script directly. Parsing impact: Even more complex input patterns, different scriptSig structures, new address types. Current heuristics: Won't work at all for P2S inputs. Tom earlier: 'just want to jump in and remind people that there is no such thing as a from address' - becomes more relevant as script diversity increases. Implication: EC's transaction parsing needs modernization. Current approach (heuristic matching) increasingly inadequate. emergent_reasons' export issue is preview of challenges ahead. Solution space: Full input fetching (like PR #3145), better type detection, support for explicit type hints in transaction metadata.",
      "category": "Network & Architecture"
    },
    {
      "question": "What payment request testing did BitCartCC developer contribute?",
      "answer": "ÐÐ»ÐµÐºÑÐµÐ¹ (MrNaif_bel) integrated and tested CashTokens in payment requests. JF asks: 'does anyone have time to give this a quick test?' ÐÐ»ÐµÐºÑÐµÐ¹ responds: 'I did test it with my integration with electroncash, but not many people use paymentrequests directly. Though I think it's used by the GUI in the receive tab indirectly.' Context: BitCartCC is payment processor service (similar to BTCPay Server for BTC). Integration testing: Covered daemon API usage (addrequest/getrequest commands), token detection in payment events, amount handling without decimal formatting. JF's response: 'cool. thanks for the contribution! Would be good to get one more person to test it out if anyone is around. happy to merge it.' Best practice demonstrated: Third-party service developers contributing back to wallet infrastructure. Their production use cases reveal gaps (like missing CashTokens support). Testing scope: ÐÐ»ÐµÐºÑÐµÐ¹ noted GUI testing needed since receive tab uses payment requests internally. His use case is CLI/daemon primarily. Shows healthy ecosystem: External developers finding issues, writing fixes, testing against real-world usage patterns.",
      "category": "CashTokens & NFTs"
    },
    {
      "question": "Why can't EC CLI deserialize require network access to fix P2SH parsing?",
      "answer": "Offline operation is core design requirement. Dustin: 'we don't want cli deserialize to require network, but might be able to add an option to use/require network when we know it's P2SH and want to try to fetch.' Use cases for offline deserialize: Air-gapped transaction building, offline signing workflows, security-sensitive environments, debugging without connectivity. Dustin's workflow: 'literally going into EC GUI, hitting send, pasting a P2PKH address, hitting max, hitting preview, hitting copy, going to CLI and running electron-cash deserialize' - for automated transaction processing. CLI output format: 'return self._EnsureDictNamedTuplesAreJSONSafe(tx.deserialize().copy())' - returns transaction dictionary. Trade-off: Offline operation means limited information. emergent_reasons: 'I need the export to just work' - his use case (tax reporting) can tolerate network access. Dustin suggests: 'might be able to add an option' - optional network flag would preserve backwards compatibility. Current state: Export (GUI feature) can use network (Calin's PR #3145), CLI deserialize stays offline. Different tools for different trust models.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "How did Electrum handle the scriptSig parsing problem?",
      "answer": "Electrum gave up and removed heuristic parser entirely. Calin notes: 'Interestingly, Electrum gave up, removed the heuristic parse_scriptSig function.. and just shows you some garbage there for inputs.' Their alternative: 'and i think they have some mechanism for remembering and/or retrieving previous outputs somehow to fully resolve txns but i forget how they did it i remember thinking it was not as nice UI-wise as what we do.' EC's approach: Kept heuristic matching despite limitations, added fetch_inputs capability for when accuracy matters. Trade-off: EC shows 'best guess' addresses (sometimes wrong), Electrum shows raw data (always honest but unhelpful). Calin acknowledges EC's parser inadequacy: 'so we are left with parse_scriptSig() which works 95% of the time and fails spectacularly when it doesn't.' Important context: As P2S activates in May 2026 and more custom contracts emerge, heuristic accuracy will decline further. Eventually EC may need to follow Electrum's approach or implement mandatory input fetching.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "When is the next EC release planned and what's included?",
      "answer": "Planned for approximately 2 weeks (mid-November 2025). Calin announces: 'Yes very soon I just need to approve some PRs and also do some tweaks for @moleccc.. probably in 2 week or so maybe.' Key feature: CashTokens tab enabled by default (was disabled in 4.4.2). Mathieu G: 'I know the CashTokens tab is disabled by default in the last release but would be enabled by default in the upcoming release.' Calin confirms: 'I agree that should be done.' Already merged: 'I think the PR was already merged some time back, just never got in a release afaik.' Other PRs pending merge: #3144 (CashTokens payment requests), #3145 (export history P2SH addresses fix), various infrastructure improvements. Calin: 'It's easy like 1 line change. It's in main_window.py.' Release will include all merged improvements since 4.4.2 (reproducibility fixes, audit tool whitelisting, ARM64 documentation). Shows steady development pace despite volunteer-only maintenance.",
      "category": "Community & Resources"
    },
    {
      "question": "Why can't you distinguish P2SH20 from P2SH32 addresses without previous output?",
      "answer": "Same redeem script creates different addresses based on hash algorithm chosen. Calin explains: 'there is no way to differentiate p2sh20 from p2sh32 if the only thing you are allowed to examine about the chain is the scriptSig of the input and nothing else.' Technical details: P2SH20 uses HASH160(redeemScript) â 20 bytes, P2SH32 uses SHA256(redeemScript) â 32 bytes. Same redeem script, different output types. Dustin confirms: 'I wrote a script to generate both from the same redeem script.' scriptSig contains: Unlocking data plus redeem script (for P2SH). No indication of which hash algorithm was used for the original lock. Calin's colorful explanation: 'so even IF you perfectly solved the problem of heuristic matching for p2sh due to your being a supernatural being and bending the fabric of reality... you would still be faced with the impossible problem of deciding if this thing is p2sh32 vs p2sh20.' Dustin realizes: 'My redeem script that works will always be returned as P2SH20 even if I iterate a new one with the intention of using P2SH32.' This is fundamental Bitcoin design, not EC bug.",
      "category": "Network & Architecture"
    },
    {
      "question": "What makes a P2SH address and how does it map to on-chain data?",
      "answer": "Calin teaches via Socratic method: 'what does this address instruct software to do when composing a txn paying out to that address? what happens on the lower level like on the txn output level?' Answer: P2SH address = hash of redeem script, encoded with specific prefix. Dustin correctly states: 'A P2SH or P2SH32 address is the hash of the redeem script.' Creating payment: Address decoded â hash extracted â locking script constructed (OP_HASH160 <hash> OP_EQUAL). Spending that payment: Must provide: data satisfying redeem script + redeem script itself. Verification: Node hashes provided redeem script, compares to stored hash, then executes script. Calin: 'how does an address map to... the locking script in an output (scriptPubKey as the Satoshi-derived nodes call it).' Key insight: Address is just encoding of output type + hash. When examining input (spending), you see unlocking data, not locking type. This architectural decision (minimal transaction size) means parsers can't definitively identify input types without external data.",
      "category": "Network & Architecture"
    },
    {
      "question": "Why would hashing arbitrary scriptSig pushes as P2SH addresses be dangerous?",
      "answer": "Could generate nonsense addresses that appear valid. Dustin's draft PR #3148 attempts: Hash last push as P2SH20 address. Calin identifies flaw: 'your current hack has the following properties: if the thing is actually a p2sh20, it will match p2sh20 perfectly... if the thing is anything but a p2sh20 (such as p2sh32, p2pk, p2pkh), it will incorrectly think it's p2sh20 and return a nonsense address.' Dustin's concern: 'My fear is if it's an unbroadcast transaction that is re-serialized and pays to somewhere else because the wrong address was returned during deserialization.' Calin confirms: 'yes. and you will thus get a nonsense p2sh address that doesn't correspond to what is useful to anybody.' Real danger: Software might use incorrect address for accounting, refunds, or transaction construction. Dustin accepts: 'Ok, good, my gut was right, it would be a terrible idea. Thank you for confirming.' Lesson: Better to return 'unknown' than wrong answer. Incorrect data worse than missing data for security-critical applications.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Why do Bitcoin transactions contain minimal information by design?",
      "answer": "Space efficiency and trust model. Calin explains architectural decision: 'the reason it's this way -- it's just because txns contain minimal information and require external information to be fully evaluated (such as coins being spent).. so it is what it is.' Alternative considered: 'an alternative design that wasted space would have been to include all the extraneous information in the txn itself but that would be a waste of space since the node needs to have original forms of that information ANYWAY that it trusts.' Trust model: Node must verify against its own chain state, can't trust transaction's self-reported metadata. Example: Transaction says 'I'm spending UTXO X', node must look up UTXO X to verify: Does it exist? What's its locking script? What's its value? Including that info in transaction is redundant - node validates against source-of-truth anyway. Implication for wallets: 'so we are stuck in a reality where all we see is scriptSig and we have to guess what the hell it was originally as an output that is being spent.' This is fundamental blockchain design trade-off: Compact transactions vs self-contained transactions.",
      "category": "Network & Architecture"
    },
    {
      "question": "Should CLI deserialize command fetch network data to resolve addresses?",
      "answer": "Philosophical debate on function purity vs utility. Dustin proposes: 'Still wonder why it couldn't be modified to retrieve whenever it fails if network is available, maybe even without an option.' Calin supports but clarifies: 'i am in favor of retrieving... it may slow down the RPC call a bit in some cases but I think is worth it.' However, questions scope: 'that seems like a low-level facility just to actually DESERIALIZE a transaction.' Pure deserialize: Transform bytes to data structure. Extended deserialize: Transform bytes + resolve all external references. Calin's naming concern: 'what you are alluding to is some higher level thing like DeserializePlusResolveAllExternalInfoForTxnPlsINeedKThxBye.' Potential solutions: Add optional flag (fullyResolveEverything=True), create separate command, silently fetch when network available. Dustin's use case: 'I do [use offline deserialize], that's why I assumed it's what emergent was doing.' Calin: 'do people use it in offline mode as a quick way to get fun stuff out of EC like free txn deserilization?' Question remains open for community input on best approach.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is the philosophy of good heuristic matching in parsers?",
      "answer": "Minimize false positives while maximizing coverage. Calin explains: 'the idea is to pick a set of heuristics that end up being lies like as infrequently as possible.' Current EC heuristics: Work ~95% of time (P2PKH dominant, multisig P2SH common). As usage patterns change (more CashScript contracts, more complex P2SH), accuracy decreases. Dustin's proposed change evaluation: 'i think your changes increase the lie percentage, rather than reduce it.' Why worse: Hashing arbitrary push as P2SH20 would misidentify P2PKH (signature becomes 'address'), P2SH32 (wrong hash), any non-P2SH. Calin's principle: 'probably deserialize may need to be fixed tho to not at least lie to you about p2sh... like right now deserialize may lie to you... may match p2sh when it's really not.' Honesty options: Return 'unknown' (honest uncertainty), fetch previous output (accurate), or heuristic guess (risk). Current EC approach: Guess but acknowledge in code comments it's fragile. Future direction: May need to follow Electrum and abandon heuristics entirely.",
      "category": "Debugging & Troubleshooting"
    },
    {
      "question": "What is the gap limit issue with EC payment requests and how does Electrum solve it?",
      "answer": "Addresses from expired invoices not reused, causing address exhaustion. ÐÐ»ÐµÐºÑÐµÐ¹ explains: 'Basically get_unused_address doesn't reuse addresses from expired invoices.' Problem: HD wallets generate sequential addresses. When payment request expires without payment, address marked 'used' even though never funded. Eventually hits gap limit (default 20) and no more addresses available. Concern: 'I wonder if it's bad that getrequest requestaddress will start returning the new request, and old request information is basically overwritten forever.' Electrum's solution: 'introduce request ids for payment requests, and they are used to query for them, not request address.' Request ID approach: UUID identifies payment request, address is implementation detail. Can reuse address if request expired without payment. Allows querying old request info even after address reused. EC currently uses address as primary key - changing to request IDs is breaking change. ÐÐ»ÐµÐºÑÐµÐ¹: 'Not sure how to proceed here.' Needs careful consideration of backwards compatibility and data migration.",
      "category": "Wallets & User Experience"
    },
    {
      "question": "Why does SLIP-39 lack full wallet support and what limitations exist?",
      "answer": "Specification incomplete and implementation partial. eloyesp asks: 'is there a reason it had not been added?' JF answers: 'The only real problem here is that Electrum only does partial implementation. You can restore a SLIP39 seed but you can't actually create a new wallet with one, if im remembering right.' Tom identifies deeper issues: 'But I think the slip itself is a nice but unfinished design. It lacking a derivation path, for example is interesting.' SLIP-39 defines seed splitting (Shamir's Secret Sharing), not wallet structure. Usage concern: eloyesp: 'My main doubt, is if it would make sense to use it, given the lack of support.' JF: 'its advanced and niche... so it would be low hanging fruit to do just do what electrum did.' Workaround: SeedCash hardware wallet supports SLIP-39 natively. MartÃ­: 'You can create a SLIP-39 BCH wallet using SeedCash and then export the xpub to electron cash.' Hardware generates seed, EC uses watch-only wallet from xpub. Tom's vision: NFC tags storing shares for physical seed recovery.",
      "category": "Security & Best Practices"
    },
    {
      "question": "Can CashFusion freeze coins causing problems with other wallet instances?",
      "answer": "Yes on same machine/wallet file, NO across different machines. Adaptive Blocksize Limit: 'I couldn't pledge to fundme until i went home and close my EC wallet to shutdown cashfusion... i used paytaca and Selene.' JF explains: 'CF freezes coins temporarily while doing fusions, so you might not be able to use them for a pledge... If you're talking about different machines, it doesn't make sense. one machine doesn't know what the other is doing.' Key distinction: Same wallet file access = conflict. Same seed on different machines = no conflict. Adaptive: 'Same wallet different machine, one desktop ec the other is Paytaca or selene on mobile trying to pledge.' Dustin: 'Nothing on chain knows about the cashfusion round until the tx is broadcast... Stopping EC immediately allowing it to work is going to have to do with something environmental outside of EC / blockchain.' Possible explanation: Unconfirmed CashFusion transactions spending UTXOs that mobile wallet tries to use. Mobile wallet sees UTXOs as available, tries to spend, but they're already in mempool. Workaround: Wait for CF round to complete or disable CashFusion temporarily.",
      "category": "CashFusion"
    },
    {
      "question": "What is trustless wallet operation and why is it important?",
      "answer": "Wallet verifies everything locally, doesn't depend on server honesty. When user asks about trustless, Andy explains: 'That means the wallet doesn't require you to trust any servers.' Context: Standard EC connects to Fulcrum servers for blockchain data (balance, history, broadcast). Trusts servers to give correct information. Trustless operation: Run your own Fulcrum server connected to BCHN full node, wallet only trusts your infrastructure. Benefits: 1) Server can't lie about your balance, 2) Can't hide transactions, 3) Can't refuse to broadcast, 4) Maximum privacy (no third-party sees your queries). Trade-off: Requires running full node (disk space, bandwidth, technical knowledge). Most users trust public Fulcrum servers - generally honest due to reputation. High-value users or privacy-focused should consider own infrastructure. StartOS making this easier with packaged BCHN+Fulcrum. Goal: Make trustless operation accessible to non-technical users. EC itself is open source (code trustable), but server infrastructure typically third-party.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What is SeedCash and how does it support BCH hardware wallet functionality?",
      "answer": "BCH-focused hardware wallet with SLIP-39 support. MartÃ­ introduces: 'Its architecture is used for HW control but in terms of the application, it is practically all new.' Fork of SeedSigner project, customized for BCH. Features: BIP-39 seeds (12-24 words), SLIP-39 shares (20 or 33 words), xpub/xpriv export, BCH address generation (CashAddr and Legacy formats), transaction signing (in development). Integration with EC: Generate SLIP-39 seed on device, export xpub via QR code, create watch-only wallet in EC. Private keys never leave device. Air-gapped: No network connectivity, communication via QR codes only. Use case: Cold storage with social recovery. Split seed into shares, distribute to trusted parties, any M-of-N can recover. Website: seedcash.cash with educational resources. Open source (based on SeedSigner). Fills gap that EC lacks native SLIP-39 support - external device handles seed management while EC provides wallet interface.",
      "category": "Hardware Wallets"
    },
    {
      "question": "What PR updates are happening in EC codebase for November 2025?",
      "answer": "Multiple infrastructure improvements pending. Notable PRs: #3155 - Kallisti updates desktop explorer list: 'Opened a PR to update the EC desktop explorer list.' Maintenance task - keeping external service links current. Earlier merged: #3144 (CashTokens payment requests), #3145 (P2SH export addresses), various reproducibility fixes. ÐÐ»ÐµÐºÑÐµÐ¹ (BitCartCC) continues contributing, discovering gap limit issue next. Community activity: Doramas publishes CashFusion article at bitcoiniscash.org/bitcoin-cash-privacy/, expanding learning resources. Regular 'Fusion Friday' community events continuing (Fiendish posts weekly). GitHub notifications now forwarded to t.me/electroncashnotifications. JF notes SLIP-39 as potential contribution: 'low hanging fruit to do just do what electrum did' - showing path for community members to contribute. Healthy open source dynamics: External developers (BitCartCC), community members (Kallisti, Doramas), core maintainers all contributing. Shows project sustainability despite volunteer-only model.",
      "category": "Community & Resources"
    },
    {
      "question": "Why is NFC storage of SLIP-39 shares an interesting application?",
      "answer": "Physical seed recovery without typing 20+ words. Tom's vision: 'Would like to add it to our NFC writer so you can have various NFC tags to restore a seed.' Use case: M-of-N threshold scheme where each share stored on NFC tag. Distribute tags to different locations/people. Recovery: Collect enough tags, tap each to reader, device reconstructs seed. Benefits: 1) No typing long word sequences (error-prone), 2) Physical security (tags can be hidden/secured), 3) Social recovery (give shares to family/friends), 4) Disaster recovery (geographically distributed). Challenges: NFC tag security (can be cloned if accessed), need secure reader (SeedCash device), lose M tags = lose funds. Tom's concern: 'I would love to see someone work out a user experience of storing and restoring the shards to an actual wallet. And improve the interoperable design from that.' SLIP-39 spec defines share encoding but not storage medium or recovery UX. This is frontier of BCH seed security - combining physical and cryptographic protection.",
      "category": "Security & Best Practices"
    },
    {
      "question": "What does trustless mean in cryptocurrency wallet context?",
      "answer": "Verifying information yourself rather than trusting third parties. Andy's explanation when asked: 'That means the wallet doesn't require you to trust any servers.' Levels of trust in EC: 1) SOFTWARE TRUST: EC open source, code auditable, reproducible builds - you can verify binary matches source. 2) SERVER TRUST: Most users connect to public Fulcrum servers - trust servers report correct blockchain data. 3) NETWORK TRUST: SPV (Simplified Payment Verification) trusts that longest chain is valid. Full trustless: Run BCHN full node (validates all rules), connect EC to your Fulcrum server (controls your data), verify transaction history yourself. Why matters: Servers could theoretically hide deposits, misreport balances, refuse broadcasts. Your own infrastructure can't lie to you. Most users accept server trust as reasonable (servers are public, reputational risk to lie), but high-value storage warrants own infrastructure. Progressive trust model: Start with public servers, graduate to own infrastructure as needs grow. This is core Bitcoin principle: Don't trust, verify.",
      "category": "Security & Best Practices"
    }
  ]
}
