{
  "title": "BCH Devs and Builders FAQ - Comprehensive Technical Guide",
  "description": "A comprehensive collection of technical Q&A from the BCH Devs and Builders community",
  "total_faqs": 444,
  "categories": [
    {
      "name": "Standards & Specifications",
      "description": "Protocol specifications, standards, BIPs, address formats, and technical references",
      "faqs": [
        {
          "question": "Can read-only inputs be spent in the same block as a full spend of the same UTXO?",
          "answer": "It depends on specification. If spent in the same block, it could be defined either way as long as clearly specified. Once a UTXO is spent in a previous block, it cannot be referenced read-only anymore. However, mempool and reorg complexity increases - if a block spending A is reorged, it must include A plus all dependent transactions."
        },
        {
          "question": "How does P2S address standardness issues?",
          "answer": "P2S (Pay to Script) addresses 2 of 5 standardness issues: output standardness and max script size. Doesn't touch dust, opreturn or max tx size. See bitcoincashresearch.org/t/non-standard-transactions-out-of-band-miner-submission/1257/10 for discussion."
        },
        {
          "question": "How should exchanges store BCH addresses in database?",
          "answer": "BCA: Personally would store hashes and then generate address for user UX on-the-fly, especially since you may want to support multiple types (BTC legacy, BCH cashaddress, BCH token cashaddress). Addresses work too, just moves encoding/decoding to elsewhere."
        },
        {
          "question": "How would faster block times affect exchange confirmation requirements?",
          "answer": "If BCH magically had 2min blocks before gaining respect/market share, exchanges would likely 5x the number of required confirmations (from 6 to 30). You don't get respect by changing yourself - in business you get respect by being profitable for them. Need to become bigger part of their income first."
        },
        {
          "question": "What are the key SEO factors for improving website rankings?",
          "answer": "Main SEO factors: 1) Avoid AI-generated content (can be detected and downranked). 2) Get organic backlinks, especially from high-authority sites. 3) Consistently update with fresh content (blog section, news). 4) Domain name should match target keywords (e.g., 'BCHEcosystem' vs 'minisatoshi' for 'Bitcoin Cash Ecosystem'). 5) Align metadata tags with content. 6) Distribute links across platforms (Twitter, Telegram, Reddit, Bitcoin Cash Research)."
        },
        {
          "question": "What is BCH reference spec purpose vs howtos?",
          "answer": "BCA/Tom: Reference specification just tells data formats (tx, block, network messages) and consensus & network rules. Implementing or using software that satisfies spec is not part of spec. Reference spec is to be read by implementers of software, not by end users."
        },
        {
          "question": "What is BCH specification repo structure issue?",
          "answer": "Tom: Git repo was made by some people, inherited by other people, copied by several projects to show on their own sites, then maintained by random people sometimes copying between repos. Not ideal, has structure that is in many ways flawed."
        },
        {
          "question": "Which BCH specification repos are actively maintained?",
          "answer": "Dustin: BU accepted PRs (reference.cash) and Flowee took input to update their copy (flowee.org/docs/spec/). Tom's codeberg.org/bitcoincash/specification is most consistently maintained version - tries to find changes others make and pull them in as well as make fixes."
        },
        {
          "question": "Why is assurance contract aspect critical for Flipstarter?",
          "answer": "Key aspect (along with focused window of opportunity) that gives people confidence to pledge large amounts. It all funds or not - prevents falling back to sporadic donations which historically result in very little. Reason for doing this pain in the ass novel thing (copy of lighthouse)."
        },
        {
          "question": "Why use pseudonymity for BCH development?",
          "answer": "You should not use your real name here IMHO, especially if you plan to become a dev. Anonymity or pseudonymity is very useful when doing groundbreaking controversial stuff. Government names created by state - legal fiction they can tax and regulate."
        },
        {
          "question": "How does Ethereum global state pricing work?",
          "answer": "Pat/Jonathan: Ethereum global state is huge RocksDB-based KV database. Storage reads and writes cost extra gas accounted for in tx fees. You can choose what to store and read, don't need to pay for part of global state you don't care about. Individual read/writes don't need to touch rest of it."
        },
        {
          "question": "What is \"perfect is enemy of good\" in BCH context?",
          "answer": "Response to argument that faster blocks don't solve double spend problem in exact logical maxwellian sense - like saying 'bitcoin doesn't solve the double spend problem'. Point is that improvements don't need to be perfect to be valuable. This is true in exact logical maxwellian sense."
        },
        {
          "question": "What is BCH mentorship program for developers?",
          "answer": "Bitcoin Cash University mentorship program at bitcoincashuniversity.com/mentors helps people get involved in coding on BCH. Sign up to help developers new to BCH or veterans."
        }
      ]
    },
    {
      "name": "Protocol Development & Opcodes",
      "description": "Core protocol features, opcodes, CHIPs, and consensus-level improvements including OP_EVAL, loops, VM limits, and network upgrades",
      "faqs": [
        {
          "question": "Are sidechains possible on BCH with current tools?",
          "answer": "Yes possible - SPV 2-way peg via OP_CAT (gist.github.com/A60AB5450353F40E/59eee82c5d6e3d989166bb8eaf7826e9). But nobody cares to build them. OP_CHECKSPVPROOF could simplify checking process. Industry moved to ZKPs for sidechains. Unpopular opinion: concept introduced by Core to stop on-chain innovation, always dead-on-arrival. ETH can't scale account-based architecture so L2s devouring L1. BCH doesn't need them yet - base chain power barely put to use."
        },
        {
          "question": "Big math opcodes vs native EC arithmetic for BCH?",
          "answer": "Big math may make EC primitives unnecessary, but native opcodes more efficient. Loops could emulate EC operations but very costly in time and computation. With eval, routine defined once at contract start and reused many times. Can turn loop into chain of 256 TXs with mutable NFT commitment going 255 to 0."
        },
        {
          "question": "Can BCH verify zero-knowledge proofs without a specialized ZKP verifier opcode?",
          "answer": "Yes, BCH can already verify ZKPs using existing opcodes, but it's highly impractical. You'd need to use many different contract inputs to perform the verification. Loops and optimization CHIPs (like OP_EVAL) would make it more practical. However, even with improvements, porting a zkVM's verification might cost ~10,000x typical transaction fees with limited wallet support."
        },
        {
          "question": "Can OP_DEFINE use script from neighboring input as function?",
          "answer": "Yes, BCH Functions CHIP allows defining script pushed as data in neighboring input as function and executing it in context of current script. Can use specially formed OP_RETURN-defined functions as read-only inputs, but that's not in scope - would be future extension."
        },
        {
          "question": "Can SHA256 collision in function identifier cause fork?",
          "answer": "It can cause fork if you don't specify hashing algo used. If you spec it it's fine. Hash collision just turns UTXO with 1 spending path into UTXO with 2 spending paths - whichever preimage spender uses, all nodes see same preimage and evaluate same."
        },
        {
          "question": "Can executable bit requirement be sunset later?",
          "answer": "If we change our mind: can stop caring about bit and just let eval exec whatever. Bit can be sunset. OP_PUSHSCRIPT would become NOP (or OP_PUSHDATA). Just NOP prefix to existing pushes. Once you add function tables etc, you're stuck with that. Best argument so far: if there's path to soft-fork sunset, 'cost' would just be some consumed code points."
        },
        {
          "question": "Do BCH Script opcodes need to be extended to support zero-knowledge proofs?",
          "answer": "No specialized ZKP opcode is strictly necessary. ZK proofs ultimately reduce to polynomial arithmetic which can be implemented using existing BCH Script math operations after the BigInt upgrade. However, a specialized opcode could offer performance advantages. The tradeoff is consensus layer complexity versus efficiency - building with existing opcodes first validates the use case before proposing consensus changes."
        },
        {
          "question": "Does OP_EVAL expand attack surface of BCH VM?",
          "answer": "Not adding anything new VM can't already do - just changing how you can express things. VM not supposed to be designed to protect developers from themselves. Only people who interact with VM are already highly skilled, smart enough to avoid tinkering with things they don't understand with large amounts of money. Attack surface = developers writing bugs, which they can and will do with or without OP_EVAL."
        },
        {
          "question": "Does OP_RUNSUB2 violate the principle that locking code must be known at lock time?",
          "answer": "Yes, in a sense. A P2SH redeem script containing `<0> <0> OP_RUNSUB2` doesn't know what the first input's first subroutine contains when locking funds. However, because code doesn't mix with data in the Subroutines CHIP, you're certain the executed code was present in the transaction you signed when locking the funds on-chain - it's just from a different input."
        },
        {
          "question": "Does the dust limit change with the new VM limits?",
          "answer": "No, dust limit doesn't change with the VM limits. The formula remains: dust limit = 444 + output_size * 3. Some implementations use higher values (800-1332 sats) to allow for worst-case scenarios like old school p2ms."
        },
        {
          "question": "How are BitCANN TLDs and multiple competing registries handled?",
          "answer": "One contract instance per TLD (e.g., .bch has one categoryId, .xyz another). Multiple people could launch competing instances claiming authority over the same TLD, but this is resolved off-chain through reputation. Everyone picks the instance with better reputation and it dominates/snowballs. Similar to how DNS root zones work - technical protocol allows duplicates, social consensus picks the authoritative one."
        },
        {
          "question": "How can BCH scripts have runtime-determined code?",
          "answer": "OP_INPUTINDEX OP_1ADD OP_UTXOBYTECODE OP_EQUAL - code to be ran determined after UTXO creation. Code runs on another input, but that input can spend UTXO created AFTER original input, just to provide correct bytecode in same TX context. UTXO with required locking script created after 'this' input for sole purpose of unlocking it."
        },
        {
          "question": "How can DEX micro-LPs prevent UTXO contention without consensus changes?",
          "answer": "Each micro-LP requires signature from node managing it - prevents competing transactions without requiring same server/entity/contract. Doesn't stop aggregator service combining liquidity, just ensures only valid transactions reach mempool. Can be done today with no CHIP. Pool operator gives you TX, fills in sig, makes sure doesn't sign same UTXO twice - otherwise everyone can do what they want."
        },
        {
          "question": "How can OP_EVAL enable code compression using hash verification?",
          "answer": "Pattern: `<push bytecode from stack> OP_DUP OP_HASH256 <hardcoded hash> OP_EQUALVERIFY OP_EVAL`. This compresses code to a hash in the redeem script, fetching actual bytecode from arbitrary sources (inputs, NFT commitments, etc). The code is kept off-chain until use but can be audited beforehand by revealing the code and verifying it against the hash. This is more flexible than OP_RUNSUB2's fixed subroutine tables."
        },
        {
          "question": "How can custom VMs circumvent OP_EVAL guardrails?",
          "answer": "Convoluted series of OP_IFs is custom VM just for that input, can 'execute' any data as bytecode just as Eval could. Any guardrail on op_eval circumvented by those convoluted ifs since that code wouldn't implement guardrails. Wastes blockspace on custom VM implementations when BCH VM available. Most viable: pure op_eval or nothing."
        },
        {
          "question": "How can users verify complex OP_EVAL optimized bytecode is safe?",
          "answer": "Reproducible builds solve this. If bytecode claims to be compiled from audited CashScript, you can verify: 1) audit the high-level CashScript source, 2) compile it yourself using the same compiler version, 3) compare the resulting bytecode hash to the on-chain hash. If someone provides unauditable complex bytecode - simply don't use it. The Unspent PHI vulnerability shows contracts can break regardless of OP_EVAL."
        },
        {
          "question": "How can web push notifications handle BCH recurring payments?",
          "answer": "Use browser PUSH protocol with bidirectional communication - wallet shows monthly subscription list marked green/yellow/red based on USD/EUR value match. User clicks \"Confirm and Pay All\" once verified. No oracles, NFTs, opcodes, or contracts needed. Just communication protocol + UI + send coins."
        },
        {
          "question": "How do MAST merkle proofs work for Functions CHIP?",
          "answer": "If have 20 functions in balanced tree and want to use one for define/invoke need: root hash and 4-5 additional hashes to prove leaf within tree. If redeem script using ten functions: 1 root hash and 40-50 additional hashes. Would have specific merkle root for functions your utxo uses."
        },
        {
          "question": "How do VM Limits prevent DoS attacks with OP_EVAL?",
          "answer": "VM Limits maintain an execution budget that tracks every operation executed. When the budget is depleted, the transaction becomes invalid. EVAL'd scripts are verified and evaluated the same way as normal scripts, bounded by the parent program's VM limits. This prevents scripts from running continuously or consuming excessive resources, whether they use OP_EVAL or not."
        },
        {
          "question": "How do relay rules relate to consensus in BCH?",
          "answer": "Relay rules and standardness are not technically consensus, but pseudo-consensus. Nobody can just assert what network will do, and some changes have real impact. Deserve as much thought as consensus CHIP. Can either move into consensus (like transaction version CHIP) or move out (remove rule, like P2S proposal)."
        },
        {
          "question": "How do you manually connect to a BCH node and send messages via p2p protocol?",
          "answer": "P2P handshake sequence: A sends 'version', B sends 'verack', B sends 'version', A sends 'verack'. Example version message hex: 'e3e1f3e876657273696f6e00000000005f00000020e7d3e4...'. Can use tools like nc (netcat) but requires proper message formatting. The protocol is more than just version message."
        },
        {
          "question": "How do you monitor BCH address balance changes using the Electrum protocol?",
          "answer": "Use blockchain.scripthash.subscribe to be notified about state changes (gives current state, then updates for new 0-conf payments and first confirmation). The notification doesn't include balance details, so call blockchain.scripthash.get_balance after notification. You must also understand and use server.ping to maintain the connection. See electrum-cash-protocol.readthedocs.io for Protocol Methods and Protocol Basics."
        },
        {
          "question": "How does 10^x exponentiation work in BCH Script?",
          "answer": "Jonathan/Mathieu: With loops exponentiation will get trivial! Just <10> OP_MUL then reduce counter or some such until done. BCA optimized version saves 30 bytes using binary decomposition approach. Can't believe getting so much power is only 8 months away (May 2026 upgrade)."
        },
        {
          "question": "How does BCH VM limits prevent infinite loops?",
          "answer": "Mathieu/BCA/Tom: VM limits CHIP already set hard limit to ops per input - loops can't exceed it, if they try tx will be invalid. Each byte gets 800 compute budget, different opcodes have unique opcost. Loop terminates with failure when script runs out of compute budget. Loops don't need exits, not BASIC-style GOTO."
        },
        {
          "question": "How does Electrum protocol status hash work for BCH?",
          "answer": "Used for blockchain.address.subscribe - returns status hash and emits on each update. Can cache with history + unspents to avoid refreshing each subscribe. Confirmed TXs come back with CTOR, unconfirmed sorted by height/increasing value/ascending hash. Status based on that order. State hash super expensive on server side - room for optimization if clients don't use it. Just compare to previous hash to check for update."
        },
        {
          "question": "How does executable bit add extra dimension to stack?",
          "answer": "Instead of 'OP_EVAL pops top item and executes as bytecode' you have 'OP_EVAL pops top item and executes as bytecode UNLESS top item has been result of OP_ADD, OP_SUB, OP_MOD...'. Adding extra dimension to stack - all complexity has been squared. It's just 1 bit: stack opcodes preserve it/pass it on, all other opcodes clear it. Same how OP_VERIFY cares about value of item, doesn't care HOW it got value."
        },
        {
          "question": "How does stack overflow relate to OP_EVAL safety concerns?",
          "answer": "Stack overflow bugs break code/data separation by making data executable, causing millions of security vulnerabilities historically. Critics argue OP_EVAL creates similar risks by mixing code and data. However, BCH Script already allows 'dangerous' contracts, and OP_EVAL can be implemented consensus-safely with no undefined behaviors. Individual contracts can be broken by misuse of any opcode - OP_EVAL doesn't fundamentally change this risk profile."
        },
        {
          "question": "How should OP_DEFINE and OP_INVOKE count as hashing operations?",
          "answer": "From VM Limits chip: Hashing operations add 1 + ((message_length + 8) / 64) to nHashDigestIterations, and nOpCost += 192 * iterations. Might need to salt identifier for each transaction input to avoid anyone ever finding arbitrary SHA256 collision that could cause fork."
        },
        {
          "question": "How to track BCH contract TVL and transactions like tokenaut.cash?",
          "answer": "Depends on particular contract - some have OP_RETURN markers, some have constant address, some can be tracked by NFTs that they emit. FBCH 'savings club' tracker is open source with protocols using OP_RETURNs listed at github.com/2qx/future-bitcoin-cash/blob/main/packages/lib/src/extra.ts."
        },
        {
          "question": "Is OP_DEFINE_VERIFY wasteful for saving 3 bytes?",
          "answer": "Jonas thinks wasteful to reserve opcode for saving 3 bytes for some use cases. Validating unknown code with hash is just one way of trusting external code - another might be validating specific NFT is used as input or code is signed by known pubkey."
        },
        {
          "question": "Is OP_EVAL dangerous for BCH contracts?",
          "answer": "The danger of OP_EVAL is debated. Critics cite 'mixing code and data' concerns from other contexts. Proponents argue: 1) BCH Script already allows writing dangerous contracts without OP_EVAL, 2) nobody is forced to lock funds in risky contracts, 3) OP_EVAL won't affect existing contracts that don't use it, and 4) it's analogous to subroutines in scientific calculators. Compiler complexity increases but doesn't inherently create consensus-level risk."
        },
        {
          "question": "Is the deterministic tiebreaker H(A||B) proposal a consensus change?",
          "answer": "Not a consensus change - blocks satisfy all the same consensus rules. It's like a soft fork but unusual: normally takes HF to undo SF, but here miners insisting on 1st-seen could still have blocks included if they get lucky. Following the 'wrong' policy would lose money, so miners need to know which policy everyone else follows."
        },
        {
          "question": "Should documentation.cash OP_DATA description be updated?",
          "answer": "documentation.cash/protocol/blockchain/script/op-codes/op-data-x.html says 'two's complement integer' for 1-75 byte push. Technically correct (C++ int type is 2s complement in C++20) but confusing since doesn't matter for those numbers. Should say 'unsigned int'. OP_X similar issue. Script numbers are sign-magnitude per wikipedia.org/wiki/Signed_number_representations#Sign-magnitude"
        },
        {
          "question": "What BCHD v0.21.0 updates for May 2025 upgrade?",
          "answer": "BCHD and associated tools (dnsseeder, meep, bchwallet, bchutil) updated and compatible with upgrade on 15th. Added chipnet DNS seeder at chipnet-seed.bchd.cash. meep v0.6.1 fixed Moria v1 TX inspection - just needed quick one liner fix to update flag. See github.com/gcash/bchd/releases/tag/v0.21.0"
        },
        {
          "question": "What CHIPs are planned for BCH's 2026 upgrade?",
          "answer": "The 2026 upgrade plans include Loops, OP_EVAL, and P2S CHIPs. These are still in debate stage. Jason confirmed these make ZK verification and advanced covenants smaller and way cheaper compared to current implementations. The goal is to reduce transaction fees and improve smart contract expressiveness beyond the current state."
        },
        {
          "question": "What Lokad IDs are used by Permissionless Software Foundation protocols?",
          "answer": "PSF uses several Lokad IDs: 0x00504d00 for PS008 Pin Claims (very active) and PS006 Simple Store Protocol (less active, maybe deprecated); 0x00510000 for PS010 IPFS File Pinning Protocol (very active). These protocols enable on-chain claims, data storage, and decentralized file pinning using OP_RETURN markers for protocol identification."
        },
        {
          "question": "What are MCP Servers and how do they improve LLM workflows?",
          "answer": "MCP (Model Context Protocol) Servers integrate tools like firecrawler (AI web crawler) and Brave Browser with LLMs to provide more context in requests rather than crazy chain of prompts. The MCP Server list GitHub repo (github.com/modelcontextprotocol/servers) has 20k stars and offers many integrations for dev workflows."
        },
        {
          "question": "What are alternatives to OP_DEFINE_VERIFY for code verification?",
          "answer": "Calin's take 2 and take 3 alternatives solve GP issue. Can validate external code by checking hash, verifying specific NFT used as input, or confirming code signed by known pubkey. OP_DEFINE_VERIFY is addition not replacement."
        },
        {
          "question": "What are current BCH OP_RETURN limits and restrictions?",
          "answer": "BCH moved OP_RETURN to 220 bytes. Multiple op_returns allowed in single transaction (restriction removed), but total for all must still be 220 bytes or less. See flowee.org/docs/spec/forks/multiple-op-returns-for-bitcoin-cash/"
        },
        {
          "question": "What are read-only inputs and why controversial?",
          "answer": "Read-only inputs: script reads bytecode/data from UTXO without spending it (OP_LIBRARY concept). More controversial than OP_EVAL. Peter Rizun suggested scripts could have read access to whole UTXO state (global read) while writes/modifications TX-local. Concern: write/modification could mess up all readers."
        },
        {
          "question": "What are the bytecode limits after the VM Limits CHIP?",
          "answer": "After VM Limits CHIP, bytecode and stack item length limits are no longer relevant to worst-case validation performance. Standard transactions can reach MAX_STANDARD_TX_SIZE (100,000 bytes). The increased limits on Maximum Bytecode Length and Maximum Stack Element Length apply equally to both locking and unlocking bytecode. Lower per-item limits offer no additional network safety while inconveniencing applications with larger data requirements."
        },
        {
          "question": "What are the concerns about TXv5 increasing locking bytecode limits?",
          "answer": "TXv5 proposes increasing locking bytecode from 201 bytes (P2SH limit) to 100,000 bytes. This data is stored in the UTXO set, raising concerns about UTXO bloat and node resource requirements. However, the 201-byte locking bytecode limit may not be affected - the discussion likely refers to P2SH scriptsig size standardization (10,000 bytes after P2S CHIP removes the 1,650-byte input limit)."
        },
        {
          "question": "What are the concerns with deferred TXID assignment?",
          "answer": "Kills block explorers - can't track TX before mining. 0-conf may not work without TXIDs assigned on spot. Would require consensus change and even then, not 100% sure 0-conf would work. Cannot just get rid of TXIDs and assign when miners mine them - not Nakamoto Consensus anymore."
        },
        {
          "question": "What are the ecosystem costs of consensus changes like block time?",
          "answer": "Consensus changes costly to everyone - lots of hours debugging, writing code, updating servers. Bigger upgrade = harder for companies to start building. Looming massive upgrade causes them to reconsider: 'If we can change this, what else will be changed?'"
        },
        {
          "question": "What are the focus areas for BCHD's 2025 network upgrade implementation?",
          "answer": "BCHD is implementing VM Limits and Big Int CHIPs to ensure full support and compatibility with the May 2025 network upgrade. These consensus changes expand Bitcoin Cash's smart contract capabilities by removing previous VM operation limits and enabling arbitrary-precision integer arithmetic in scripts."
        },
        {
          "question": "What are the main use cases for OP_EVAL according to BCH developers?",
          "answer": "Multiple use cases exist: 1) Jonas: optimize stack manipulation by implementing custom opcodes like OP_UNROLL, 2) MathieuG: compile CashScript functions into executable bytecode with compiler-managed calling conventions, 3) bitjson: compress bytecode by detecting repeating patterns and using CAT/SPLIT to reuse common bytes, 4) bitcoincashautist: commit hashes of code and only provide preimages when needed, saving space."
        },
        {
          "question": "What changed in BCH transaction version 2?",
          "answer": "2qx/Tom: Only change was treatment of nSequence numbers in BIP68. Version 2 was started by soft fork, didn't actually change format but changed interpretation of one field. To use opcode with sequence data in output, you were required to set version number to 2."
        },
        {
          "question": "What content strategy improves SEO for cryptocurrency websites?",
          "answer": "Combine evergreen static content with regular fresh updates. Evergreen examples: fork history maps, ecosystem links pages (get tweaked but persist). Fresh content: blog section with BCH news, commentary on developments, links to foundation/podcast content. Successful sites have both: stable resources that build authority over time, plus semi-regular new content that signals active maintenance to search engines."
        },
        {
          "question": "What documentation sources recommended for BCH developer chatbot training?",
          "answer": "CashScript docs, libauth docs, Electron-Cash protocol, SoftwareVerde bitcoin-cash-specification, BCHN announcements, documentation.cash, all CHIPs, bitcoincashresearch.org, cashtokens.org, mainnet.cash, flowee.org/docs/spec/, upgradespecs.bitcoincashnode.org, BitcoinCashPodcast.com/faqs. Mastering Bitcoin and Mastering Bitcoin Cash already added."
        },
        {
          "question": "What does 'safety' mean in the context of BCH Script contracts?",
          "answer": "Two levels exist: 1) Consensus/VM safety: code can't damage the VM (like making your computer 'go up in flames'). This is handled by VM Limits. 2) Fund safety: preventing people from spending your money without your intent. Critics argue OP_EVAL compromises fund safety by allowing runtime code generation. Both levels are important, but they address different concerns."
        },
        {
          "question": "What does emergence of AlbaVM say about BCH development?",
          "answer": "Amazing thing about BCH peacefully and consistently putting out good work: we have no visibility on continually emerging set of new things bubbling in background. Both from existing and new teams. Every specific topic in BCH has its own active channel and active community. There aren't many crypto projects with so many different channels - BCH is serious business, unlike many cryptos."
        },
        {
          "question": "What is 95% alternative to OP_EVAL proposal?",
          "answer": "Locally defined immutable OP_EVAL - can only operate on input-defined blobs, blob can't be mutated if going to get op_eval'ed. Literal op_eval but must be defined locally and can't be mutated. Going to more pro tool like eval easy moving forward, basically impossible to move back. Gray area preference."
        },
        {
          "question": "What is BCH script number encoding vs C++ encoding?",
          "answer": "Stack items use script numbers (sign+magnitude encoding). OP_X and OP_DATA_X documentation says 2s complement but numbers 1-75 work with any signing method. Numbers never put on stack - that's at different layer of script bytecode interpretation. In other places it's C++ numbers (uint/int) or custom unsigned varint encoding. C++20 requires 2s complement for signed integers."
        },
        {
          "question": "What is BitVM challenge setup for BCH ZK-rollups?",
          "answer": "BitVM provides native level of verification for commitment proofs with far less trust setup required. Challenges to commitments could come in as late as 1 week or more per Ekrem Bal's OP_Next talk. Current staking models assume there isn't an equivalent on BCH yet."
        },
        {
          "question": "What is Jerry's native elliptic curve arithmetic CHIP?",
          "answer": "Proposal for ECADD and ECMUL opcodes (bitcoincashresearch.org/t/1570). Enables native ZKP verification rather than relying on OP_CHECKDATASIG attestation. Needed for Bulletproofs, Groth16, SNARKS/BLS verification, field inversion, curve equation checks. Emulating with loops computationally expensive - must verify points lie on y2=x3+7 (mod p) secp256k1."
        },
        {
          "question": "What is OP_DEFINE_VERIFY shorthand proposal?",
          "answer": "OP_DEFINE works on any stack element no matter where it came from. Adding extra <hash> <index> OP_DEFINE_VERIFY is shorthand for OP_DUP OP_HASH256 <hash> OP_EQUALVERIFY <index> OP_DEFINE. Allows verification with hash while keeping normal OP_DEFINE for other use cases."
        },
        {
          "question": "What is OP_PUSH_EXECUTABLE proposal for static analyzability?",
          "answer": "Stack items marked executable only if pushed verbatim with OP_PUSH_EXECUTABLE. If modified (OP_ADD etc.) item loses executable bit, becomes data blob. OP_EVAL can only execute items with executable bit. Keeps static analyzability while allowing unverified code execution if script author chooses. However can be circumvented by implementing VM within VM."
        },
        {
          "question": "What is Tom's subroutines CHIP approach to OP_EVAL?",
          "answer": "Alternative to OP_EVAL using OP_RUNSUB2 and OP_DEFINESUB. Transaction creates multiple outputs that work together if spent in one transaction later - they share same prev txid. Separates code from data. Locking script requires certain unlocking script by hash - code executed in VM known at time output was mined. See bitcoincashcode.org/bitcoincash/CHIP-subroutines"
        },
        {
          "question": "What is a Turing tarpit and how does it relate to Bitcoin Script?",
          "answer": "A Turing tarpit is a system that is theoretically Turing-complete but practically useless due to extreme inefficiency. The original Bitcoin Script VM inherited by BCH was essentially a tarpit - not even Turing complete and missing basic operations like MUL, forcing repeated ADD operations instead. It's like a calculator without multiplication. BCH has been progressively escaping this tarpit with VM upgrades."
        },
        {
          "question": "What is central bank confiscation concern with OP_EVAL?",
          "answer": "Oracles today have power over funds, but only select from 2+ possible outputs pre-designed in output script when mined. Master key signature for arbitrary bytecode makes central bank style confiscation possible. If code being signed is malicious, writer has huge advantage - days to adapt to unmoving target to get script to say 'yes' for sending to themselves."
        },
        {
          "question": "What is chipnet anyone-can-spend faucet address?",
          "answer": "2qx/Kallisti: P2sh20 base58 address for <42> OP_NUMEQUAL is 2N28ZR5MgBoKq6sBceEoGvTuGs1wfZeXvFF. Kallisti mining chipnet to this address so anyone can claim coins after 100 blocks. Put coins there and took them from playground with require(answer==42) spending script."
        },
        {
          "question": "What is compromise approach with OP_EVAL and executable bit?",
          "answer": "EVAL + special push as compromise doesn't close off any future paths, still gives all nice benefits of Eval while mitigating 'we don't know what gets executed' problem. If declare some NOP as OP_PUSH_EXEC, then if one day wiser and decide to just allow Eval to run anything - can make that decision without much technical debt. Lose some benefits like cross-input compression, but if blobs all explicit then can do compression on another layer."
        },
        {
          "question": "What is covenant recursion path for AMM without consensus change?",
          "answer": "Covenant recursion could be path forward for AMM without changing consensus. Plus 2026 upgrades help even more with looping. See github.com/bastiancarmy/bitcoin-cash-trustless-defi-recursion. Needs solid peer review. Basic problem still there regarding mempool transactions pre-mine."
        },
        {
          "question": "What is debate about OP_EVAL code verification?",
          "answer": "OP_EVAL executes stack items as code. Locking script can verify with OP_DUP OP_SHA256 <hash> OP_EQUALVERIFY OP_EVAL but not required - script author's choice. Concern: allows anyone-can-spend if just OP_EVAL without verification. Counter: people can write anyone-can-sweep P2S/P2SH anyway. Separation of code/data vs primitives debate."
        },
        {
          "question": "What is locally defined immutable compression requirement?",
          "answer": "Code/data package locally defined and immutable - 'code was known at time money was locked in'. Serves local code compression use case. Tom's subroutines CHIP achieves this using P2SH principles. Prevents someone seeing locking script from writing matching code to unlock. Some argue guardrails could be circumvented (VM within VM) making them obstacles."
        },
        {
          "question": "What is master key signature pattern for OP_EVAL?",
          "answer": "Lock funds into: OP_TUCK <pubkey> OP_CHECKDATASIGVERIFY OP_EVAL. Unlock with: [...data] <sig> <bytecode> <redeem>. Executes script if signed by certain key. Change multisig logic, add oracle requirements, need script signed as master key. This type of system possible TODAY with VM limits activated. Can let admin approve alternative spending methods after UTXOs created."
        },
        {
          "question": "What is real benefit of OP_EVAL beyond bytecode compression?",
          "answer": "Not just 'less bytes on blockchain' - enables new category of applications: cryptography on stack and ZKPs in script which wouldn't be possible to express within VM limits without 100x to 1000x compression enabled by EVAL. These complex contracts simply would not be possible without compression."
        },
        {
          "question": "What is real use case for OP_EVAL modularity?",
          "answer": "Oracle multi-input contract sometimes needs checks, sometimes doesn't. If does need checks, require extra checks done by another input (authed by hash) - lot of overhead verifying other input checks same data as *this* input, plenty footguns. Way simpler if provide module as *this* input's push only when needed, easier to secure."
        },
        {
          "question": "What is relay vs consensus rules gap issue?",
          "answer": "Standardness rules (relay) vs consensus creates complexity. CashScript docs have 5 occurrences of 'standardness': max contract size, max tx size, max opreturn size, dust threshold, output standardness. Proposal: 'great standardness cleanup' - make relay limits consensus or remove gap. Risk-averse approach: make relay limits consensus. Case-by-case convergence needed."
        },
        {
          "question": "What is risk tolerance difference in OP_EVAL debate?",
          "answer": "Different risk analysis: one side says 'realistically, is this creating fresh pitfalls likely to cause large issues' = no, because most usage by experts or abstracted, time/experience helps develop templates. Other side: even with tooling, look at exploits/0-days in mature C++ ecosystem - why create additional risk when 80-90% achievable without it? Last 10% effectively free if ever comes to that."
        },
        {
          "question": "What is sharp knives argument for OP_EVAL?",
          "answer": "OP_EVAL doesn't let you do anything outside BCH VM instructions - just compression. Cryptocurrency can't avoid scams from growth. If bad dev, can always lose money through misconfiguration. Devs choosing OP_EVAL volunteer for risk. ETH blow-ups from Solidity bugs, not EVM itself. Can't prevent incompetent devs."
        },
        {
          "question": "What is sharp knives philosophy for OP_EVAL?",
          "answer": "OP_EVAL doesn't let you do anything outside BCH VM instructions - just about compressing bytes. Bad devs can always lose money through misconfiguration. Can't prevent that. Devs choosing OP_EVAL do so knowingly - if not confident, don't use it. Compilers/tools handle complexity, not humans hand-coding hex. All about byte compression, not new capabilities."
        },
        {
          "question": "What is static analyzability debate with OP_EVAL?",
          "answer": "Processing code to create 'complete' code requires execution or sophisticated analysis due to: loops, mutable code/data blobs (eval executes from stack), recursion, combinations. Nothing prevents VM implementation inside VM that reads blob and interprets as opcodes. OP_PUSH_EXECUTABLE doesn't prevent this - guardrails become obstacles if circumventable."
        },
        {
          "question": "What is the Merkle Header Commitment (MHC) CHIP?",
          "answer": "MHC CHIP (gitlab.com/0353F40E/mhc, bitcoincashresearch.org/t/chip-2025-03-merkle-header-commitment-for-enhanced-spv-scalability/1518) adds merkle commitments to block headers for enhanced SPV scalability. Computational cost is negligible: ~20 hashes per block, because leaves are added to a sorted list so only the right edge branch needs recomputing. Placement options discussed: last output for compact proofs vs OP_RETURN prefix for future extensibility."
        },
        {
          "question": "What is the OP_RETURN scanner and how does it work?",
          "answer": "The OP_RETURN scanner (opreturn-scanner.netlify.app, github.com/mr-zwets/opreturn-scanner) finds all occurrences of specific opreturn markers (lokad-ids) on-chain. For example, searching for 'BCMR' finds 3417 txids. The tool promotes using markers for on-chain protocol/smart contract apps as a great place to store contract details, enabling discoverability without centralized indexers."
        },
        {
          "question": "What is the difference between soft forks and hard forks from a practical perspective?",
          "answer": "The soft/hard fork distinction was arguably an excuse to create a nonexistent problem. In some situations, hard forks are far better - less headache, cleaner, and less complicated than soft forks. The key is ensuring everyone is aboard through a reasonable process like CHIPs, which can continuously improve through discussion. BCH has demonstrated that coordinated hard fork upgrades work well when properly managed."
        },
        {
          "question": "What is the op_1 UTXO sweeping attack vector?",
          "answer": "UTXOs at address prdpw30fk4ym6zl6rftfjuw806arpn26fv8cp7wyl3 can be spent with input script 0x81. If miners automatically swept these and ignored user TXs spending them, it gives anyone a way to set up double-spend: send to op_1 address then race miner's sweep against your own spend to victim."
        },
        {
          "question": "What is the purpose of bytecode compression with OP_EVAL?",
          "answer": "Compilers can use heuristics to detect repeating executable byte patterns and maximally compress Script when compiling from high-level languages. CAT/SPLIT operations on eval'd bytecode enable reusing common bytes and appending bytes to match non-optimized code. All eval-scripts are 'trusted' and hard-coded as data pushes in locking bytecode. The Subroutines CHIP focuses on IDE/NPM-like repositories for importing third-party bytecode."
        },
        {
          "question": "What is the relationship between nSequence and OP_CHECKSEQUENCEVERIFY (CSV)?",
          "answer": "Setting nSequence in a transaction input enforces relative locktime at consensus level - the input must age before the transaction can be mined. However, without additional restrictions, a spender can set any valid nSequence value up to the UTXO's age. CSV (or introspection) restricts what nSequence value can be used in the spending transaction, enforcing minimum locktime requirements. CSV essentially creates 'timelocked covenants' that existed before introspection opcodes."
        },
        {
          "question": "What is the timeline and adoption requirement for TXv5 on BCH?",
          "answer": "Jason stated TXv5 won't happen in 2027 and he won't push for it unless BCH becomes a Top 10 coin. At that ranking, BCH can justify forcing integrated services to upgrade rather than drop support. The CHIP will be ready if BCH reaches that position. If not, TXv5 can wait. Meanwhile, 2026 upgrade plans include Loops, OP_EVAL, and P2S CHIPs."
        },
        {
          "question": "What is user protection strategy for OP_EVAL contracts?",
          "answer": "Users protected same way as from dodgy code - by avoiding niche services, devs they don't trust, or projects that lost user money. Users second-order effect of devs (or third-order after compiler devs). Wallets can have default 'never trust OP_EVAL' or 'only if local compression' policies. Script devs downstream of compiler devs."
        },
        {
          "question": "What is vegabch daemon mode and what are MoriaV0 commands?",
          "answer": "Vegabch beta introduced daemon/server mode to improve performance by maintaining program state for minimal-delay command responses. MoriaV0 commands enable interaction with the Moria lending protocol: mint (create loans), repay (pay back loans), liquidate (close undercollateralized positions), and redeem (withdraw collateral). This CLI tool provides programmatic access to BCH DeFi protocols."
        },
        {
          "question": "What malleability did BCH fix vs what remains?",
          "answer": "BCA: We fixed 3rd party malleability when we implemented BIP-62 stuff in consensus. But 1st/2nd party malleability is still possible. Recipient can't do it - he'd be 3rd party without one of privkeys. XMR doesn't even have script multisig, so nothing to malleate."
        },
        {
          "question": "What prevents rigorous testing and formal verification with OP_EVAL?",
          "answer": "OP_EVAL allows code pushed in unlocking scripts to execute without being committed to in advance. This means: 1) code isn't known when money is locked, 2) the same contract call can execute different code based on runtime data, and 3) test cases can't exhaustively verify all possible code paths. Traditional opcodes have well-documented behavior with testable inputs/outputs. OP_EVAL breaks this model by allowing runtime code generation."
        },
        {
          "question": "What standard for BCH consensus changes regarding benefits vs risks?",
          "answer": "Benefits must be concrete, risks allowed to be hypothetical. Reverse NOT acceptable. This approach for BCH consensus where it's one-way street, changes only come on order of years, mistakes can be very costly. Very high value + very low risk = high bar for consensus changes."
        },
        {
          "question": "When did BCH get covenant capabilities and how have they evolved?",
          "answer": "BCH has had covenants since 2018, became easy to use in 2022. In 2023, CashTokens brought persistent state to covenants, enabling them to communicate with each other and provide compact proofs. The 2025 upgrade (BigInt/VM Limits) enables more advanced crypto in single inputs, with Lamport signatures as a starting point. Loops and optimization CHIPs in 2026 will make advanced cryptography more practical."
        },
        {
          "question": "Why is BCH not big enough for payment protocol adoption?",
          "answer": "If BCH made perfect protocol it would be ignored - just not big enough. Some big ones (MS/FB/Google/Coinbase) needed to sponsor these things before it happens. Unfortunate problem in today's world. Sad BCH not the one to design x402 protocol - would bring PR for Money for the Internet."
        },
        {
          "question": "Why is OP_CAT considered essential for Bitcoin VMs?",
          "answer": "CAT and SPLIT are super useful features in concatenative languages like BCH Script (a Forth dialect). A Bitcoin VM without OP_CAT is like Unix without cat command, or a farm with a mouse problem - tough to take seriously. These operations are fundamental to the concatenative programming paradigm that BCH Script is built on."
        },
        {
          "question": "Why is SLP on BTC risky despite relaxed OP_RETURN?",
          "answer": "Platform risk: BTC changed OP_RETURN limit before, killing token protocols. Not first time - used to be bigger. Most token use-cases impractical once TX fees over $0.10 USD. Better to stick with BCH for network effects (Paypal & Thorchain) and lower platform risk. See cashstack.info/docs/global-back-end/slp-indexer/why-slp"
        },
        {
          "question": "Why is cross-network compatibility limiting for BCH?",
          "answer": "Multicoin world exists but blockchain-agnostic = adapted to lowest common denominator of BTC forks. Limits using BCH-specific features. Being latecomer to BCH features means lagging knowledge when BCH takes off - fewer opportunities while others racing ahead."
        },
        {
          "question": "Why is risk model different for BCH VM than generic programming?",
          "answer": "Risk model of generic programming language vs BCH VM that handles trillions of ounces of gold in value are different at practical level. Like telecoms use Erlang - average developer doesn't use that, but reason specialists use different tools. Yes Javascript probably already handles trillions in value, but through custodial databases that get rolled back/edited all the time. Our risk context is different."
        },
        {
          "question": "Why is unhashed eval code fundamentally safe?",
          "answer": "It's all just sequence of bytes that unlocks UTXO. A script OP_ADD OP_EQUAL can already be unlocked with OP_0 OP_0 OP_0. Contract either is or isn't secure - can either be unlocked by unpredicted bytes in unintended manner or can't. Function eval changes nothing in that regard. Extreme hand holding would remove whole script system and only allow P2PKH."
        },
        {
          "question": "Why is zkVM verification currently impractical on BCH?",
          "answer": "Porting zkVM on-chain verification to 2025 BCH VM requires extensive workarounds. Even if implemented, every protocol interaction might cost ~10,000x typical BCH fees with extremely limited wallet support. Additionally, constraint differences encourage sub-optimal ZK constructions versus systems designed without program length concerns. This makes even non-workaround work potentially a technical dead end for production use."
        },
        {
          "question": "Why local-only OP_EVAL creates bugs and hurts scalability?",
          "answer": "Input local means define function inside transaction you're using it in. Creates bugs: 1) Used space against TX VM limits wish could have outsourced, 2) Might have made mistake copying it in, 3) Same data duplicated over and over is huge efficiency loss against blockchain as a whole, which hurts scalability. Compiler selecting code from library vs local contract compression - but local has major downsides."
        },
        {
          "question": "Why was OP_EVAL originally rejected in Bitcoin in 2011?",
          "answer": "Mike Hearn argued OP_EVAL invalidated security assurances and put Bitcoin 'back at square one' without clear benefits. However, this argument has weaknesses: Bitcoin had critical bugs after 2011 (duplicate TXIDs, DB migration, supply cap bug), yet later additions (P2SH, CHECKLOCKTIMEVERIFY, BCH upgrades) had no issues. Transaction compression saves bandwidth (not just disk), and infrastructure operators care about efficiency even if lightweight clients don't."
        }
      ]
    },
    {
      "name": "Smart Contracts & Covenants",
      "description": "Contract development, covenant patterns, introspection, CashScript, and contract architecture best practices",
      "faqs": [
        {
          "question": "Can BCH Script be considered Turing complete and what does that mean for ZK implementations?",
          "answer": "If a scripting language is complete, it can express any program. BCH Script can be seen as another Forth dialect. The issue with zkVM on BCH isn't whether it's possible (theoretically it is), but practicality: incredible inefficiencies in contract code requiring workarounds for input limits. Implementation without deep ZK knowledge risks subtle errors like nonce reuse in ECDSA. Simply mirroring Solidity functions isn't enough."
        },
        {
          "question": "Generic vs specific contract discovery for BCH wallets?",
          "answer": "Generic approach (works for any contract) has privacy impacts, stores more on-chain, limited by complexity. Tom's take: won't get nice UX as long as generic. Best approach: actual products appear, contract devs work with front-end devs in specific wallets. GUI and code for one/two contracts together can find TXs easily. Some systems want to be discoverable - SORTS gives standard."
        },
        {
          "question": "How can you broadcast a raw transaction directly to a BCH node?",
          "answer": "Use Bash script with p2p protocol handshake (github.com/A60AB5450353F40E/f408a7cc0df4ee2a609dd2229e14557c). Complete the version/verack handshake, then send TX message. AI tools like Grok can help generate the bulk of the script but require some tinkering to work correctly."
        },
        {
          "question": "How can you use raw transactions with CashScript ecosystem?",
          "answer": "Can manually create contract artifact (without CashScript language/compiler) to use TransactionBuilder and mocknet environment integrated with BitAuth IDE. Cashlab (github.com/hosseinzoda/cashlab) uses straight bitauth templates and has tests. See next.cashscript.org/docs/guides/optimization#overwriting-the-artifact for overwriting artifact details."
        },
        {
          "question": "How do MEV contracts work on BCH?",
          "answer": "Hundreds of users with unspent.cash perpetuity get paid monthly - contract stipulates minimum payment but leaves small gas fee for anyone to claim. Monthly installment transactions built by anyone, not authenticated with signatures, only introspection logic. Dozens of contracts like that with hundreds of permutations. bitcoincashresearch.org/t/a-cataloge-of-miner-extractable-value-mev-on-bitcoin-cash/1616"
        },
        {
          "question": "How do NFT-controlled subscription pulls address price changes?",
          "answer": "Jonas's design: NFT controls amount corpo can pull - they need approval to raise rate by requiring new NFT issuance. Individual contract per subscription also addresses this, but bag of subscriptions is less manual."
        },
        {
          "question": "How do ZK proofs prevent miners from stealing withdrawals?",
          "answer": "The recipient address is used as input into the proof generation, effectively hardcoding the withdrawal destination. When the proof, recipient address, nullifier hash, and merkle root are sent to the contract, changing any of these makes proof verification fail. The verification process uses all these inputs together with the proof, preventing address substitution."
        },
        {
          "question": "How do anyone-can-spend subscription contracts enable MEV?",
          "answer": "Anyone with phone can make little money executing regular payments from public anyone-can-spend subscription contract. Hyper-redundant non-guaranteed method works because if one of 5B+ people with phones can make few thousand sats submitting transaction, chances are good few people might try."
        },
        {
          "question": "How do pull-based BCH subscription vaults work?",
          "answer": "User locks funds in vault and issues NFTs allowing service to pull certain amount at interval. NFT revoke is like revoking debit card, insufficient vault funds like insufficient bank balance. Analogous to current subscription flow but with cryptographic controls."
        },
        {
          "question": "How do wallets find UTXOs spendable by NFTs they own?",
          "answer": "Wallets scan for hash of script bytecode using Electrum. If you have tokenid=x with commitment=y, wallet generates standard script, hashes it, queries Electrum server to find whatever is spendable with tokens in wallet. Scan for P2SH that uses that script. Same principle as querying P2PKH and P2SH multisig for bunch of HD addresses. Wallet needs code to know fingerprint and how to generate hash from key or NFT."
        },
        {
          "question": "How do you debug P2SH script failures in BitAuth IDE?",
          "answer": "For complex scripts with evaluation errors, need to cross-check against authentication-template-v0.schema.json. Naming convention and structure leads to failure. Common issue: stack evaluating to empty instead of 1 (or non-0). Can manually create contract artifact without CashScript compiler to use TransactionBuilder."
        },
        {
          "question": "How do you handle the NULLFAIL rule with OR operators in CashScript checkSig?",
          "answer": "The NULLFAIL rule (BIP-146) makes failed checkSig fail the entire script rather than returning 0. For 'require(checkSig(userSig, seller) || checkSig(userSig, refere))', the first checkSig with wrong signature errors instead of continuing. Solution: use two signature parameters - 'function release(sig sellerSig, sig userSig)' then pass '0x' for the unused sig (e.g., '0x, userSig' when user sweeps; 'sellerSig, 0x' when seller sweeps)."
        },
        {
          "question": "How does Anyhedge contract fingerprinting work?",
          "answer": "BCA: Each anyhedge contract has different address due to specific contract parameters, but they all have same fingerprint because executable part of bytecode is same for all. If Bob knows exact contract he can look it up on electrum using script hashes."
        },
        {
          "question": "How does BitCANN's domain registration system work on BCH?",
          "answer": "BitCANN implements an Unstoppable Domains/ENS-like protocol using BCH covenants. It represents one of the most complex BCH Script systems built, using nSequence, CSV, and introspection to manage decentralized domain ownership and renewals. The system enforces registration periods through relative locktimes, allowing trustless domain management without centralized control."
        },
        {
          "question": "How does executable bit proposal enable static analyzability?",
          "answer": "Explicit executable push (and inheritance rules so can't be mutated but can be shuffled/dup'd/dropped) means script author can't hide that script is more complex than it seems. Parse script, extract all executable pushes, count number of evals - that'll tell you max complexity of contract. Authors could write exotic contracts with lots of small blobs shuffled and executed in combinations, but you'd immediately know something is sus."
        },
        {
          "question": "How does function visibility work in BCH Script contracts?",
          "answer": "BCH Script has no concept of public/private functions - all functions can be called by anyone. Unlike Solidity's access modifiers, you must explicitly lock down function capabilities within the contract logic itself. Use require statements and signature checks to restrict who can execute specific contract paths. This is a fundamental difference from account-based smart contract platforms."
        },
        {
          "question": "How does nSequence enforcement work with signatures vs covenants?",
          "answer": "Three scenarios: 1) Pre-signed transactions: the signer chooses nSequence, signature covers it, recipient can't change it. 2) Full control (P2PKH): user can set any valid nSequence (0 to UTXO age), field is enforced but value isn't fixed. 3) Partial control (covenants): script enforces minimum nSequence via CSV or introspection (require(tx.inputs[N].sequenceNumber == minWaitTime)). Consensus always enforces whatever nSequence value is present; script limits what can be set."
        },
        {
          "question": "How does state management differ between BCH Script and Solidity?",
          "answer": "BCH uses UTXO architecture instead of account-based state. There's no equivalent to Solidity's receive() function that triggers on payment. Contracts don't maintain internal state like structs. Instead, state is 'sharded' using NFTs - each state element becomes a separate UTXO. To track deposits, contracts mint NFTs with user data stored in the NFT commitment field. Listen to indexers for receiving events rather than contract-internal triggers."
        },
        {
          "question": "How does the Subroutines CHIP ensure code safety compared to OP_EVAL?",
          "answer": "Subroutines separate code from data by: 1) requiring exact code to be known when transaction is mined, 2) only executing unlocking script code after formal verification by locking script (like P2SH hashes), and 3) allowing rigorous testing with defined inputs/outputs like opcodes. OP_RUNSUB2 can call code from other inputs, but because code doesn't mix with data, you're certain it's code from the transaction you signed when locking funds."
        },
        {
          "question": "How should contract safety be evaluated in BCH Script?",
          "answer": "Low-level languages (assembly, C, BCH Script) are inherently 'dangerous' in that bugs can cause fund loss. High-level languages like CashScript provide safer abstractions. Contract risk assessment should focus on: 1) specific attack vectors rather than general 'danger' claims, 2) compiler and testing rigor, and 3) recognizing users choose to lock funds in contracts. New opcodes like OP_EVAL don't inherently make safe contracts unsafe."
        },
        {
          "question": "How should introspection opcodes handle read-only inputs to maintain backward compatibility?",
          "answer": "Current introspection opcodes should be made to fail if they try to read a read-only input. A new set of opcodes would be needed to access read-only input data. Otherwise, old contracts could be fooled by unexpected read-only inputs they weren't designed to handle. This prevents security issues with existing contracts when read-only inputs are introduced."
        },
        {
          "question": "How should untested BCH contracts be shared?",
          "answer": "Write contracts as // comment, // op_code, CashScript triples for more folks to review. Easy to correct mistakes and track reasoning on BCR. If you leave mistake in contract, you'll start seeing it copied elsewhere by people and AI. Contracts are meant to find directional bearings on paths to take."
        },
        {
          "question": "How to fund CashScript contract initially?",
          "answer": "Contract.address gives address to fund. Send to that address on correct network (chipnet vs testnet4 vs mainnet). Use Contract.address will give you the address you need to fund. Note you are on chipnet so make sure sending with chipnet funds rather than mainnet. Can call contract.getBalance() and getAddressUtxos() to check."
        },
        {
          "question": "How to get MTP-corrected current time for BCH contracts?",
          "answer": "Get 13 most current headers, decode and calculate value according to spec. MTP is not meant to relate to current time - by definition it lags behind real time for ~1hr. OP_TXLOCKTIME in contract uses nLocktime set on transaction level, checked against MTP per STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE | LOCKTIME_MEDIAN_TIME_PAST."
        },
        {
          "question": "What BCH development patterns emerge from AlbaVM release?",
          "answer": "Developer had no history, joined 3 days ago, initial drop was an hour ago. Makes you wonder how long this has been in works, when it started. Love it when people come out of nowhere to just drop cool work like this. Asked at last years BLISS if CashScript could be made to create formal validation work - this provides way to do things on much more strict way."
        },
        {
          "question": "What CashScript version fixes and network issues?",
          "answer": "Use cashscript@next (npm install cashscript@next) for updated default chipnet server and ElectrumNetworkProvider fixes. Chipnet vs testnet4 confusion: chipnet for CHIP proposals, testnet4 general purpose. Use chipnet by default for less issues. ElectrumNetworkProvider certificate expired - need @next version or custom server. Contract address is hash160/hash256 of unlocking script (P2SH20/P2SH32)."
        },
        {
          "question": "What JavaScript type coercion issues should developers watch for?",
          "answer": "In JavaScript, 'for...in' constructions make the iterator variable a string until converted, which can cause dramatic performance differences. Additionally, 'string + number' can produce unexpected results - \"1\" + 0.5 might become \"10.5\" (string concatenation) instead of 1.5. These type coercion behaviors can prevent JIT compiler optimizations and cause bugs."
        },
        {
          "question": "What are Dutch Auctions and how are they implemented on BCH?",
          "answer": "Dutch Auctions start at a high price that decreases over time until someone buys. Implementation uses timelocking with token-aware contracts (bitcoincashresearch.org/t/unspent-phi-v3-timelocking-token-aware-contracts/1501/3). For cancellation, instead of a separate cancel function (which could race with sales), the seller can trivially 'buy back' many UTXOs in succession through the UI. BIP68 512s units can be used for time restrictions."
        },
        {
          "question": "What are LLM limitations for BCH contract development?",
          "answer": "LLMs really bad at stuff not done thousands of times by others. Also bad when thousands of conflicting ways exist (e.g. Android APIs changing over time). They're language models not world models - can translate ideas to code but get lost with logical structure. Need to give good info first to anchor them, and context fades from beginning."
        },
        {
          "question": "What are P2SH scriptsig size limits after the P2S CHIP?",
          "answer": "The P2S CHIP removes the 1,650-byte input limit. The standardization limit for full P2SH scriptsig becomes 10,000 bytes. This is the effective practical limit after the change. The locking bytecode length limit of 201 bytes for standard transactions remains unchanged - the increased limits apply to unlocking scripts (scriptsig), not locking scripts (scriptPubKey)."
        },
        {
          "question": "What are common mistakes when creating CashToken transaction preimages?",
          "answer": "Common error: forgetting to update 'transaction outputs hash' to include token data in outputs. The token prefix (including PREFIX_TOKEN byte) must be included before the modified locking script. Error 'mandatory-script-verify-flag-failed (Signature must be zero for failed CHECK(MULTI)SIG operation)' often means preimage construction is wrong. The 'modified locking script length' should include both token data and lockscript when present."
        },
        {
          "question": "What are concerns with read-only inputs TXv5 design?",
          "answer": "Current assumption that transaction where any NFT is spent as input and not in output is burnt no longer holds. This might cause serious issues in some current contracts. The idea is half-cooked and design is flawed."
        },
        {
          "question": "What are concerns with untrusted code injection in contracts?",
          "answer": "Introspection fetching code in unlocking transaction means code not guaranteed to come from you. If don't know unlocking code at time of locking, very likely doing it wrong - open to code injection. Locking script visible for all can be brute forced with any unlocking script to find one that unlocks it."
        },
        {
          "question": "What are contract UTXO constraint best practices?",
          "answer": "P2PKH constraint: bill must 'see' signature for hash covering TX contents, signing key hash must match hash in program. With introspection: can codify '50% to address A, 50% to address B'. But if only constrain 50% to A, remaining 50% goes wherever TX creator decides - not constrained means allowed. See bitcoincashresearch.org/t/exploit-and-solutions-for-calculated-outputs/1423"
        },
        {
          "question": "What are problems with centralized AMM serial provider approach?",
          "answer": "Contract using introspection for different input where server adds tagging input/output and client signs their own funds, then server signs after ensuring no split. Problem: central entity could simply not sign and effectively lock up users funds. Withdrawal could still conflict with trade. Not permissionless if permission in form of signature is needed."
        },
        {
          "question": "What are subscription vault funding options?",
          "answer": "Two approaches: 1) One big bag named \"subscriptions\" for all services (semi-manual, risk of corpos pulling too much), or 2) Multiple subscription bags, one per service (basically full manual). Option 1 risks mismanaging money if you don't verify amounts each period."
        },
        {
          "question": "What are the key design considerations for OP_EXEC in BCH Script?",
          "answer": "OP_EXEC should avoid stack pollution by isolating subroutine arguments. A proposed design uses: 1) OP_EXEC1 to execute scripts in the same output by index, 2) OP_EXEC2 to execute scripts from earlier outputs in the same transaction, and 3) OP_SUB_PUSH to define subroutines with argument counts. Subroutines see only their expected arguments on stack. MAST integration allows unlocking scripts to push subroutines to a temp sub-stack that locking scripts can verify and migrate."
        },
        {
          "question": "What are the security risks of mixing code and data in BCH Script?",
          "answer": "Mixing code and data enables: 1) calling functions with identical arguments yielding different results, 2) self-modifying code (exploited in viruses/malware historically), 3) impossible-to-test code paths, and 4) bypassing formal verification. With OP_EVAL, code from unlocking scripts can execute without being verified by locking script hashes (unlike P2SH). This makes contracts 'impossible to keep free from bugs or exploits' according to critics."
        },
        {
          "question": "What are the three scenarios for nSequence enforcement in Bitcoin transactions?",
          "answer": "1) Pre-signed transactions: If given a pre-signed TX with relative locktime, the chosen timelock is enforced (signature covers nSequence). 2) Full control: Using your own P2PKH, you can pick any valid relative locktime (nSequence is enforced but value isn't fixed). 3) Covenant partial control (e.g., inheritance): Script enforces minimum nSequence field. In scenario 2 you had full control so no specific timelock was enforced; in scenario 3 the script limits what you can do."
        },
        {
          "question": "What challenges exist when regex validating file paths in JavaScript?",
          "answer": "Pattern like '^([A-Za-z]:|[A-Za-z0-9_-]+(.[A-Za-z0-9_-]+)*)((\\/[A-Za-z0-9_.-]+)+)$' may validate shorter paths but fail on longer strings. Issues often relate to catastrophic backtracking or quantifier nesting. Testing with tools like regex101.com helps, but JavaScript's RegExp implementation can behave differently than other regex engines."
        },
        {
          "question": "What development tools are available for CashScript?",
          "answer": "An official VS Code extension for CashScript was released in January 2025, replacing the old unofficial extension. It supports all latest CashScript functionality including syntax highlighting, code completion, and integration with the CashScript compiler. This provides a significant productivity boost for BCH smart contract development."
        },
        {
          "question": "What is 2nd-party multisig malleability in BCH?",
          "answer": "BCA: Either of the 2 parties in multisig could re-roll their sig to change txid and disable any descendant tx that requires parent to have exact txid. With BCH covenants child won't depend on exact txid so problem is avoided. P2PKH can only be malleated by whoever has private key."
        },
        {
          "question": "What is 8-byte script number limitation in BCH?",
          "answer": "Numeric opcodes restricted to 8-byte signed 'Script Number' integers (HF-20220515). Excludes value -9223372036854775808 that fits in 8-byte 2s complement encoding but not in 8-byte Script Number (sign-magnitude) encoding. Because we use sign bit, can't represent that 1 value that can usually be represented with 8-byte 2s complement. With '25 upgrade now can operate on that value with bigger integers."
        },
        {
          "question": "What is AlbaDSL/AlbaVM for BCH contracts?",
          "answer": "Haskell-based DSL and VM for Bitcoin Cash 2025 contract programming. Developer joined BCR 3 days ago and dropped cool work. Forked haskoin-core specifically for contracts - might be first Haskell-specific contract system. Provides way to do things in much more 'strict' way. Amazing work that came out of nowhere."
        },
        {
          "question": "What is BCH contract fingerprinting approach?",
          "answer": "gitlab.com/0353F40E/smart-contract-fingerprinting - extracts executable/data segments, generates bytecode patterns, provides confidence scoring. BCHN patterns RPC addition will populate dataElements field for contract type identification. TapSwap example: fingerprint indexed, parameters in OP_RETURN, bytecodePatternAsm from RPC, contractType field available."
        },
        {
          "question": "What is BCHN P2S contract pattern tracking?",
          "answer": "BCA: BCHN merged feature to track P2S contracts. Contract 'pattern' is obtained by stripping data pushes and replacing with number of pushes, 'fingerprint' is hash of pattern. Will find all contracts between different people using same pattern but different keys - very useful to track P2S contracts."
        },
        {
          "question": "What is BitCANN and how does it use BCH smart contracts?",
          "answer": "BitCANN (github.com/BitCANN/contracts) is an Unstoppable Domains/ENS-like protocol for decentralized domain registration on BCH. It represents one of the most complex BCH Script systems built so far, using sophisticated covenant patterns with nSequence, CSV, and introspection to manage domain ownership and renewals. The system uses relative locktimes to enforce registration periods."
        },
        {
          "question": "What is CashScript Arena learning group?",
          "answer": "Telegram group for challenging each other with 'broken' or exploitable smart contracts. Complete beginners welcome - helps with questions of getting started. First challenge only requires setting up programming environment to interact with given smart contract. Experienced people welcome to help create challenges and answer newcomer questions. t.me/CashScript_Arena"
        },
        {
          "question": "What is CashScript bitauthURI method for debugging?",
          "answer": "Create contract and use bitauthURI method of Transaction builder - gives URL to paste in browser and inspect. Use latest 0.11.0-next.3 of CashScript - has scenario generation and multi contract debugging. Use private key you don't use in production."
        },
        {
          "question": "What is DEX contract anyone-can-spend risk?",
          "answer": "BCA: DEX contracts are anyone-can-spend and sometimes contentious spends can happen by accident if multiple users try to interact with same UTXO. Need to be watchful for p2sh in dependency graph when batching user withdrawals."
        },
        {
          "question": "What is OP_DEFINE_VERIFY proposal for code injection?",
          "answer": "OP_DEFINE_VERIFY is shorthand for OP_DUP OP_HASH256 <hash> OP_EQUALVERIFY <index> OP_DEFINE. Makes transition from P2SH simple: unlocking script pushes code, locking script has code-hash and OP_DEFINE_VERIFY. Prevents brute forcing unlocking script that steals funds."
        },
        {
          "question": "What is SORTS standard for BCH contract discoverability?",
          "answer": "Simple Op Return Text Standard - parsing data for Bitcann and similar contract systems. Records include profile, social, crypto, DNS. Example: contracts.anyhedge.artifacts=<url>, contracts.anyhedge.params.0=\"parameters\". Wallet uses getRecords('alice.bch') to construct contracts and show info. Optional - user chooses to attach contracts to identity."
        },
        {
          "question": "What is Tom's verified code proposal for OP_DEFINE?",
          "answer": "Provide OP_DEFINE variant to verify function matches hash - like P2SH today only executes provided code if matches hash. Unlocking script pushes [code], locking script has: push 32-bytes-hash, push index, DEFINE_VERIFY. Hash can come from anywhere as stack item. This usecase is what P2SH does in more convoluted way."
        },
        {
          "question": "What is UTXO model explained as bills analogy for BCH?",
          "answer": "UTXO is like individual cash bill - transaction destroys bill and creates new bills, amounts must add up (difference claimed by miners as fee). Each bill has locking script - codified checklist enforcing conditions to spend. Different from EVM - code encodes constraints not actions. Most important: **anything that's not constrained is allowed** - root of footguns."
        },
        {
          "question": "What is ZCE Bag covenant specification requirement?",
          "answer": "Need to specify ZCE Bag covenant - central to design but no mention of how supposed to work. Opcode for just one contract type has very bad smell. Attention is scarce resource so not priority now."
        },
        {
          "question": "What is ZK-rollup state-root updater contract structure for BCH?",
          "answer": "Contract stores oldRoot and verifier pubkey. To spend: provide signature (proofSig) over (oldRoot || batchHash || newRoot), verify with OP_CHECKDATASIG, enforce single output preserving value, ensure next UTXO locks to new contract script via P2SH32(newScriptHash). Off-chain compiles fresh contract with newRoot."
        },
        {
          "question": "What is big footgun with BCH contract UTXOs?",
          "answer": "If not constrained, all bills for contract can be spent at once, and value for one of them can satisfy constraints of ALL of them. Example: contract says 'any bill spent by anyone but 1000 sats must go to address A' - with 10 inputs only one needs to satisfy constraint for all. Bills can be spent as single input thread or highly multi-threaded input - must be considered."
        },
        {
          "question": "What is debate on OP_DEFINE_VERIFY necessity?",
          "answer": "Tom proposes as safety valve for code injection - prevents brute forcing unlocking scripts. BCA, Jonas, Jason, Calin see no problem in the issue. Debate centers on whether bytes unlocking UTXO being executed by input's VM vs parsed as data matters. Many consider it unnecessary complexity."
        },
        {
          "question": "What is immutable code argument for OP_EVAL?",
          "answer": "Want to state as fact when sending transaction to lock money, know for fact which scripts will run to unlock. Even if stupid mistake in code, ONLY thing people mess with is data. Can't provide new code to unlock. Code is locked. This is 'trusted code' or 'immutable'. How it works today via push-only rule for unlocking scripts."
        },
        {
          "question": "What is local execution context for BCH scripts?",
          "answer": "Whole TX+prevouts already is local execution context. Eval loading from stack is just loading static data from rest of TX. Script can require other script passes in another transaction, brings proof through token. Even with eval, stacks can't interact between inputs."
        },
        {
          "question": "What is main concern with enabling powerful VM for complex contracts?",
          "answer": "Main point against: Do we want BCH script so powerful that certain contracts will blow up because they were too complex? ZK-contracts will be extremely complex, only very select few would have ability to review cryptography. If ZK-contract catches on and blows up, it won't be due to specifics of any opcode or missing security guardrail."
        },
        {
          "question": "What is the challenge with multiple inputs when receiving payments in UTXO contracts?",
          "answer": "A single transaction can have 10+ inputs from different addresses, making it ambiguous which sender to record. UTXO architecture requires thinking differently than account-based systems. Rather than a single 'sender' variable, use NFTs to create separate state UTXOs per user, or implement contract patterns like Cauldron's per-user contract addresses where each depositor gets a unique contract address containing their pubkey."
        },
        {
          "question": "What is the key difference between OP_EVAL and the Subroutines CHIP?",
          "answer": "Subroutines CHIP forces designers to introduce subroutine code in the locking script via fixed subroutine tables. OP_EVAL/OP_EXEC takes executable bytecode from the stack, allowing it to come from: the locking script, unlocking script, another input/output's script (via introspection), or constructed dynamically by code. OP_EVAL provides flexibility; subroutines provide structured safety by restricting where executable code can originate."
        },
        {
          "question": "What is use case for executing functions from other UTXOs?",
          "answer": "When scripts too large for limits. With P2S binding limit 10kb vs 1650 byte standardness limit. Is 10kb enough for ZKP functions? Could see UTXO exporting specific function. Well-known script constructions integrated into BitAuth IDE and CashScript instead of copy-pasting."
        },
        {
          "question": "When should you download full blocks instead of using Fulcrum subscriptions?",
          "answer": "For monitoring >1 million script hashes, downloading full blocks and filtering locally is more efficient than subscriptions. Subscribing to 1M addresses = 50MB network traffic + 50MB local storage just for subscriptions. If behind a full node, filtering blocks is safe and cheap. Remember which blocks you've processed to catch up after downtime. Fulcrum max_subs limit (10M) is generous DoS prevention, but downloading blocks scales better."
        },
        {
          "question": "When should you use CSV vs introspection for enforcing relative locktimes?",
          "answer": "CSV is better for simple cases like `require(tx.age >= <expression>)` as it automatically enforces TX version 2. For variable age scenarios (e.g., longer staking = more rewards), use introspection: `require(tx.version == 2); int nSeqInput = tx.inputs[3].sequenceNumber; require(nSeqInput > 0);`. This allows using nSequenceInput in other calculations while still enforcing the timelock."
        },
        {
          "question": "Where to find advanced CashScript examples for BCH?",
          "answer": "0353f40e.gitlab.io/emerald-dao/ has advanced examples. awesomebitcoin.cash/#script lists published documented scripts (libauth templates and op_code fine too). youtube.com/@bitcoincashuniversity has badgers and fundme contract tutorial vids. PurelyPeer.cash uses CashScript for cashdrops (microads) and vaults (digital coupons). cashscript.org/docs/showcase for project showcase."
        },
        {
          "question": "Why do anyone-can-spend contracts need faster confirmations?",
          "answer": "Any kind of anyone-can-use UTXO contract - multiple users could accidentally try interact with same UTXO at same time, and until block is mined they won't know which user's tx will go through. If anyone-can-spend tx has conflict, rather know in 1-9 minutes than 10-90. Can't control app logic of 3rd parties to whom BCH is just another coin, only to be hit by 20-30min waits 1 in 10 times."
        },
        {
          "question": "Why does CashScript use signed magnitude not two's complement?",
          "answer": "Emergent/Mathieu: BCH VM works natively with signed magnitude, not two's complement. Therefore any tools around script and VM will also use signed magnitude. Script numbers don't use twos complement, they use signed magnitude. CashScript must follow same since it compiles to BCH VM bytecode."
        },
        {
          "question": "Why is Flipstarter not true assurance contract?",
          "answer": "Tom: While advertised as 'assurance contract' it is not actually any contract because moment money is sent, obligation on receiver drops to zero. There literally is only one thing that can be applied: social pressure. This is opposite of a contract."
        },
        {
          "question": "Why is hash validation important for executable code?",
          "answer": "Practical difference based on cryptography. Script with just OP_EQUAL not very useful. Hashes hide actual data that unlocks it, avoid brute forcing. With code you don't validate, massively easier to find script to unlock money. Locking script that uses eval without hash validation allows experimenting until unlocked."
        },
        {
          "question": "Why is zero-conf vs faster blocks a false dichotomy?",
          "answer": "Zero-conf will always be the way forward for in-person transactions and low-value payments. However, improving UX for cases where 0-conf doesn't work (high-value, untrusted parties, or p2sh ancestor chains) is also important. Faster blocks and zero-conf are complementary, not competing solutions. More TPS (enabled by both) drives price."
        }
      ]
    },
    {
      "name": "CashTokens & NFTs",
      "description": "CashTokens implementation, NFT usage, token standards, BCMR, and token-based contract patterns",
      "faqs": [
        {
          "question": "Can read-only inputs be implemented without the TXv5 transaction format?",
          "answer": "Yes. Read-only inputs could be added by including just 1 optional byte to input encoding, similar to how CashTokens were added to output encoding. This avoids requiring a full transaction format version change. However, no one is currently championing this approach separate from TXv5."
        },
        {
          "question": "How can NFT on/off switch solve AMM withdrawal conflicts?",
          "answer": "NFT can be used for withdrawal, second contract as on/off switch for LP. If LP contract requires NFT held by on/off switch contract (or <1 confirmation movement from it) for trades to occur, and withdrawal path requires NFT included with 1 confirmation, then trade transactions and withdrawal transactions should no longer have risk of conflict."
        },
        {
          "question": "How can NFTs be used to store contract state on BCH?",
          "answer": "NFTs act like mini-structs in UTXO architecture. When a user deposits into a contract, an NFT is created with the user's address and data stored in the NFT commitment field. The BCH amount is held on that same NFT UTXO. NFTs contain: satoshi amount, token category, token capability, and custom fields in the commitment (user address, flags, etc). Each NFT represents one piece of contract state, owned by the contract itself or users."
        },
        {
          "question": "How can you verify that a CashToken transaction succeeded?",
          "answer": "Check multiple sources: 1) Verify txId was returned from wallet.send(), 2) Use decodeTransaction() to inspect the raw transaction outputs, 3) Check token-aware explorers like explorer.electroncash.de or Electron Cash wallet which display tokenData in outputs. Some explorers (like melroy.org) may not show token amounts even if the transaction succeeded."
        },
        {
          "question": "How do CashTokens enable subscription payment model?",
          "answer": "BCA: Can all be done with CashTokens. Service would hold NFT which it could use to trigger pull. When you want to cancel you just burn their NFT. Could have multiple services pull from same pool of funds if they have authorization via NFTs."
        },
        {
          "question": "How do you monitor token balance changes in real-time with mainnet-js?",
          "answer": "Use wallet.watchTokenBalance() which accepts a callback that fires when balances change. Example: `const cancelWatch = wallet.watchTokenBalance(undefined, (updatedBalances) => { setTokenBalances(prevBalances => ({...prevBalances, ...updatedBalances})) });`. Get initial balances with getAllTokenBalances(). Remember to call cancelWatch() when unmounting the component to prevent memory leaks."
        },
        {
          "question": "How do you send CashTokens using mainnet-js TokenSendRequest?",
          "answer": "Use `new TokenSendRequest({ cashaddr: recipientAddress, amount: 100n, tokenId: 'your_token_id', value: 1500 })`. The `amount` is the token quantity (BigInt), `value` is the satoshi amount on that output (minimum 1000 sats for token outputs). Send via `await wallet.send([tokenRequest])`. Verify with `await Wallet.util.decodeTransaction(sendResponse.txId, true)` to see full transaction details."
        },
        {
          "question": "How does BitCANN handle domain name uniqueness without global state?",
          "answer": "BitCANN doesn't 'remember' claimed domains on-chain. Instead, the real name UTXO can terminate anyone's UTXO trying to add the same name. State management is delegated to external agents (users/services tracking existing names). The DomainOwnershipGuard uses an NFT ('ExternalAuthNFT') from the Domain contract - its mere existence proves domain ownership. Users wanting to use the incentive system penalize invalid auctions."
        },
        {
          "question": "How to use OP_DEFINE with external data from NFT commitments?",
          "answer": "Example: <0> OP_OUTPUTTOKENCOMMITMENT to get NFT commitment at Output 0, then <0> OP_DEFINE to define program from it, then <0> OP_INVOKE. Safety caveat: program has access to full stack (no stack isolation). Must ensure stack empty before invoking and returns expected items. Otherwise callback could mutate Stack items to get truthy result."
        },
        {
          "question": "How would BCMR verification work for OP_EVAL contracts?",
          "answer": "Like CashTokens where anyone can create scam tokens but BCMR verifies most used ones integrated into wallets. Same with smart contracts - BCMR of vetted bytecode locations on-chain for functions like 'quantum resistance check', 'ZKP verification'. Naive users use defaults (kiddy playground of vetted things). Audited OP_EVAL functions reach users via BCMR verified system."
        },
        {
          "question": "How would freeze/seize functionality work on BCH CashTokens?",
          "answer": "Tokens would need to be contained in smart contract rather than sent to user's wallet. Users wouldn't have exclusive ownership like with p2pkh - just privilege to transfer their part of ownership in the big contract. This privilege could be revoked with an admin key. By default, CashTokens in user's wallet cannot be seized."
        },
        {
          "question": "What BCMR API issues exist with NFT flagging?",
          "answer": "Paytaca BCMR server has 'is_nft' boolean flag that should really be changed to 'has_commitment' because that's what it means. Paytaca doesn't use this flag anymore. Can create issue at github.com/paytaca/bcmr-indexer to track change. Flag is actually object with NFT info, not just boolean."
        },
        {
          "question": "What NFTs do FundMe.cash pledgers receive?",
          "answer": "Pledging gives pledgeNFT which you keep. It records campaignID and how much BCH pledged. Can be refunded before campaign completes. Wallet tab shows pledgeNFTs for refundable pledges - could expand to show all campaigns funded and BCH amounts for tax tracking."
        },
        {
          "question": "What are current BCH BCMR registries and resources?",
          "answer": "BCMR repos: Paytaca at bcmr.paytaca.com (metadata indexer, not true token registry per BCMR spec), otr.cash, PTR at github.com/zapit-io/ptr, Flowee BCMR server (added HTML way to get BCMR details on tokens/auth-chains for human viewing, was purely JSON before). Also minisatoshi.cash/ecosystem lists all with BCMR tags."
        },
        {
          "question": "What are security footguns with NFT-owned UTXOs?",
          "answer": "NFT can't be on same input as UTXO it locks - spender specifies which input has NFT. Footgun: NFT UTXO itself needs to verify whole TX. If it doesn't (suppose NFT spent with SIGHASH_ONE), then 3rd party could just add more inputs owned by NFT and do what it wants with them. Locking script defines ownership, unlocking just satisfies predicate requesting signature or NFT."
        },
        {
          "question": "What are the Wyoming Stable Coin blockchain selection criteria?",
          "answer": "Wyoming stable token (WYST) requires 'Freeze and Seize' capabilities as a criteria. Liquid network gained qualification because AMP's APIs facilitate freeze/seize via whitelisting addresses. Blockchains without freeze/seize functionality would be disqualified. For BCH, it's technically possible to implement via covenant for a token but requires keeping tokens in smart contract rather than user's p2pkh wallet."
        },
        {
          "question": "What are the key concerns about iBCH as an additional incentive token?",
          "answer": "Main concern is circular dependency: incentive mechanism depends on DEXs existing, which rely on consensus tools, which require the token. Can't have an incentive securing the chain that's reliant on services built on the chain. Additional issues: either iBCH value is low (proposal falls apart) or has value (arguably alters 21M cap), and no other network has implemented similar scheme to observe real-world behavior."
        },
        {
          "question": "What are use cases for mutable NFT code in contracts?",
          "answer": "Vault where you can update spending paths without moving funds - new spending funds validated with tokens or pubkey/signatures. Code compression: if (program in NFT1) else (program in NFT2). Contract could keep benefactor in commitment and let current benefactor mutate state with signature to set new benefactor. Exotic but can be very useful."
        },
        {
          "question": "What evidence shows CashTokens spurring BCH project growth?",
          "answer": "CashTokens integrated into Zapit, Paytaca, Cashonize, Selene, rumored for Bitcoin.com. Projects: TapSwap, BCH Pump, Badgers, BLISS, BCH Guru FURU, AFoG token, Fiendish spaces token, Cauldron, CashTokens studio, MUSD, FundMe. Number of projects seriously rising since CashTokens added. Transaction volume not yet up but projects and infrastructure growing."
        },
        {
          "question": "What is Bitcart and what cryptocurrencies does it support?",
          "answer": "Bitcart (bitcart.ai) is an open-source, self-hosted payment processor written in Python. It supports BTC, LTC, BCH, XMR and more. BCH has been supported for 4+ years (6th birthday in March 2025). Work is ongoing for CashTokens support via Electron Cash API. It's a viable alternative to custodial payment processors for merchants wanting full control."
        },
        {
          "question": "What is BitcoinCashClient C# library for BCH integration?",
          "answer": "Nuget library to abstract away complexity from integrating BCH into C# .net application. AFoG uses it for all BCH tasks except address monitoring. Uses NBitcoin as base layer to handle bits and bytes of transaction construction. github.com/david-shattuck/BitcoinCashClient. Todo: fully remove NBitcoin dependency for total control over transaction construction for CashTokens stuff."
        },
        {
          "question": "What is Blockbook indexer and why for BCH CashTokens?",
          "answer": "Trezor's indexer for BCH - wraps node RPC, has WebSocket subscriptions. Pat's fundme.cash campaign/39 for CashTokens support aims for hardware wallet level support. Blockbook pretty much wrapping node rpc, no UTXO chain token balance support currently (only EVM, looks awkward). Fast performance."
        },
        {
          "question": "What is Thorchain CashTokens support status?",
          "answer": "Thorchain considering adding support to CashTokens but need SMEs. Tyler (9R): BCH devs interested in getting CashTokens supported by TC. BCH very important to us - only DEX that really supports BCH. thorchain.net/pool/BCH.BCH. Fees to pool depth ratio is 30% for year - very productive pool. Want to add MUSD/RUNE."
        },
        {
          "question": "What is camping lottery BCH NFT use case?",
          "answer": "Island with 6 campsites, dates May 15-Sept. Simplify lottery processing: sign up with BCH address, receive NFT with unique commitment (date + sequence), transfer NFT to camp (admission slip). Can trade NFT on marketplace in meantime. Similar to concert ticket usecase. Just assets, no smart contracts needed - send to someone else's wallet, could use poster with phone number to meet in real life."
        },
        {
          "question": "What is standard script pattern for NFT-owned UTXOs (P2NFT)?",
          "answer": "Standard script for NFT ownership: `OP_DUP OP_UTXOTOKENCATEGORY OP_SWAP OP_UTXOTOKENCOMMITMENT OP_CAT OP_HASH160 <x> OP_EQUALVERIFY` where x is hash. Compressed version: input script pushes index where NFT is placed. Wallet discovery: take what wallet has (pubkeys, NFTs) -> generate assumed UTXO locking scripts they could unlock -> query Electrum for UTXOs locked with those scripts."
        },
        {
          "question": "What is the BCH dust limit formula and what is the recommended safe amount for CashTokens?",
          "answer": "Dust limit formula is: 444 + output_size * 3. For safety after CashTokens it's best to use 1000 sats as dust amount. Electron Cash uses 800, some dapps use 1000 and others use 800. The exact calculation per UTXO is available in libauth, but using a fixed amount (800-1332) is simpler than perfect calculation."
        },
        {
          "question": "What is the computational cost for miners to add MHC commitments to coinbase?",
          "answer": "Negligible: ~20 hashes per block. Because leaves are added at the end of a sorted list, you only need to compute the right edge branch of the merkle tree. With UTXOs this wouldn't work (added/removed randomly), but for header commitments the append-only pattern makes it extremely cheap. If placed as last output, compact proofs can be created via SHA256 midstate without needing the full coinbase tx."
        },
        {
          "question": "What is the difference between token inputs showing 'tokenData: undefined' and actual token data?",
          "answer": "In mainnet-js transaction decoding, inputs from previous transactions may show 'tokenData: undefined' in the vin array even when the transaction successfully creates token outputs. The vout array is what matters for new outputs. Inputs only need enough BCH value and token authority - the tokenData in outputs determines what was actually sent."
        },
        {
          "question": "What is the original BCMR verification model vs how it's commonly used today?",
          "answer": "BCMR was designed so the payer provides the JSON to you, then you cheaply verify truth via the auth-chain (maybe 10KB total including merkle proofs). DNS-based verification via webserver files was also core to the spec. Today, most implementations use trusted indexers that provide the JSON (turning the model upside down), which works but means nobody validates ownership, IPFS is needed wallet-side, DNS-based is ignored, and a central database would work better."
        },
        {
          "question": "What is vox.cash and how does it differ from unspent.app?",
          "answer": "Vox.cash is 2025 update of unspent.app (2022) that includes integrated wallet, state and tokens - much more powerful with CashTokens. Features 10 market-making contracts including super easy Dutch Auction (26 bytes unlocking code). Each contract designed to make some kind of market in as few bytes as possible."
        },
        {
          "question": "When can you use reduced entropy for NFT category IDs?",
          "answer": "If you generate category/NFT yourself, 2^128 is fine (half of category ID via OP_SPLIT). If you're given NFT, not fine - someone could have rolled colliding pair - you'd want 2^256 there. Reduced entropy donation address: `<0> OP_UTXOTOKENCATEGORY <16> OP_SPLIT OP_DROP <half_of_NFT_categoryID> OP_EQUAL` - total input size 64 bytes, sweep 1000s of UTXOs with just 1 signature."
        },
        {
          "question": "Why do many developers and communities hate 'crypto'?",
          "answer": "The crypto space is overwhelmed by scams - furries, musicians, artists, and gamers all hate 'crypto' due to perception damage. Those trying to fulfill Bitcoin's original purpose are drowned out 1000:1 by scam tokens. The damage to crypto's perception is probably much higher than people imagine. Recruiting good C++ devs to the space is nearly impossible - asking means you're considered 'dirty'. This makes developer recruitment extremely challenging."
        },
        {
          "question": "Why do some developers avoid BCH-specific features like CashTokens?",
          "answer": "Blockchain-agnostic approach allows exit if BCH fails to be best chain. Multiple OP_RETURN and CashTokens not compatible with BCH forks (eCash, Nexa). Two main reasons to stay: network effects (Paypal, Thorchain availability) and backward compatibility maintained in recent years without breaking changes."
        },
        {
          "question": "Why do wallets use BCMR indexers instead of the original verification model?",
          "answer": "For NFTs with thousands of images, BCMR files become megabytes in size and lack core features (requiring extensions). Airdrops and DEXes don't have payment protocols to support the original model. Trusted indexers solve this by providing JSON, but it's essentially standardized data storage on someone else's computer. The tradeoff: easier implementation but centralization and loss of the trustless verification design."
        },
        {
          "question": "Why does Cashonize show 0 tokens sent when sending tokens to yourself?",
          "answer": "This is not a bug - wallet history displays the net balance change. When you send tokens from your address back to your address, the balance doesn't change (0 net change). Contract interactions require this calculation method. Use block explorers like explorer.electroncash.de or Electron Cash to see the actual token outputs and amounts in the transaction."
        },
        {
          "question": "Why don't developers calculate exact dust limits per CashToken UTXO?",
          "answer": "It's not clear how to divide up funds in a wallet (do CashToken UTXO sats count to your cash balance?). Managing UTXOs with large amounts or multiple token types is complex. Also, the amounts are too small to bother optimizing at this stage. Eventually someone will make a library/method and everyone will use that."
        },
        {
          "question": "Why is wrapped asset integration important for BCH DeFi?",
          "answer": "Need WBTC, WETH and standard derivatives for DeFi. Real killer likely stablecoin (MUSD or possibly Tether return). If BCH had wrapped CashToken versions of other UTXO projects, those ecosystems could get fast low-fee DeFi on BCH. FBCH currently largest TLV CashToken project."
        },
        {
          "question": "Why was CashToken signing serialization designed to prevent old software from creating token transactions?",
          "answer": "For transaction encoding, token data precedes the locking script. But for signature preimage, token stuff is intentionally moved 'outside' (before the script length). This design ensures unupgraded software can't generate valid token signatures and accidentally burn tokens. Old software lacking token awareness will create invalid signatures, preventing catastrophic token loss."
        }
      ]
    },
    {
      "name": "Development Libraries & Tools",
      "description": "Software libraries, SDKs, development tools, and frameworks including libauth, mainnet-js, and language-specific tooling",
      "faqs": [
        {
          "question": "How do you set up mainnet-js with React and Next.js?",
          "answer": "Mainnet-js provides a React/Next.js demo with proper configuration at github.com/mainnet-cash/mainnet-js/tree/master/demo/react-next. The key is configuring next.config.mjs correctly to handle polyfills for Node.js modules that don't exist in browser environments. Clone the demo repository and examine the configuration rather than starting from scratch to avoid common polyfill errors."
        },
        {
          "question": "How does NPM supply chain attack work?",
          "answer": "Farooq: For many packages on npm, the domains used for Email has expired. Someone else can register domain, launch mail server, then use reset password mechanism to get control of packages. Major supply chain attack vector."
        },
        {
          "question": "How does Telegram mute functionality work for community management?",
          "answer": "Telegram doesn't have per-user mute like Nostr. If could globally mute people adding noise, would be decentralized version of banning - quickly muted by anyone adding signal, unpopular to reply giving fuel, faster with mute-replies feature. Without this tool, needs willingness to not be everyone's best friend."
        },
        {
          "question": "How does vox wallet modularize DeFi protocols?",
          "answer": "Each vox module is just libauth template and page of helper functions to build transactions. Libauth doing all heavy lifting constructing/validating transactions (no cashscript sdk). When libauth library available elsewhere easier to port modules to Flowee or EC. Drip was BCA's idea, WBCH was Dagur's, BlockPoints based on Badgers."
        },
        {
          "question": "What BCH development library recommendations for different needs?",
          "answer": "mainnet-js: automatic UTXO selection, change outputs, simple sends. libauth + cashscript combo: preferred by Jerry for SDK. libauth alone: nice if don't need wallet or electrumX. mainnet-js has bloat and workarounds with webpack/bundlers per some. npm concept doesn't make sense to Tom. Python: wait for cashscript-py. Rust: rust-bitcoincash supports CashTokens. 2qx working on libauth examples."
        },
        {
          "question": "What Node.js version should be used with mainnet-js and Next.js?",
          "answer": "The mainnet-js React/Next.js demo works with Node 22.13.0. Use yarn as the package manager (the repo includes yarn.lock). While npm can work, mixing package managers causes lock file inconsistencies. The repo's next.config.mjs handles polyfills for browser environments, eliminating manual webpack configuration."
        },
        {
          "question": "What Rust libraries available for BCH development?",
          "answer": "gitlab.com/rust-bitcoincash/rust-bitcoincash/ - supports CashTokens. Rust forces write out every return type and possible state - library usually done or not done. Very common to see well written rust libraries go for years without release - they're not unmaintained, they're just done. 'electrum-client-netagnostic' crate for electrum API access. libauth-rs replacement for libauth.org would be cool."
        },
        {
          "question": "What Rust tooling exists for BCH development?",
          "answer": "Riften Labs (gitlab.com/riftenlabs) has Rust BCH tooling including a Rust indexer. rust-bitcoincash (gitlab.com/rust-bitcoincash/rust-bitcoincash) provides core Bitcoin Cash libraries. Libauth also has Rust components (compiled to WASM for hashing functions at github.com/bitauth/libauth/tree/master/wasm/hashes). Java and C++ are the most mature compiled languages for BCH, with Go standalone libraries also available."
        },
        {
          "question": "What are Vox apps built with?",
          "answer": "2qx: Every vox app is libauth template, builder function and UI page. There are 4 examples now but will be like 12 soon. Mainnet and Selene also do this. Short general audience READMEs in each app, more technical breakdowns in libauth templates."
        },
        {
          "question": "What are mainnet-js and CashScript SDK compatibility options?",
          "answer": "Kallisti: Short answer is yes. Long answer - you'll probably need to write some of your own glue code to make two libraries talk to each other. 2qx: There are three type formats for unspent outputs - each library has its own format and common format (electrum-cash) underneath."
        },
        {
          "question": "What are vegabch MoriaV1 BCH libraries release?",
          "answer": "npm packages: vegabch@0.2.0 @cashlab/common@1.0.4 @cashlab/moria@1.1.1. MoriaV1 now available in vegabch. Docs for devs: github.com/hosseinzoda/cashlab#documentation. vegabch cli readme for power users: github.com/hosseinzoda/vegabch."
        },
        {
          "question": "What frontend libraries recommended for BCH development?",
          "answer": "Libauth for working with BCH frontends - has validation for CashAddr function for typescript/javascript. mainnet-js if find libauth tricky to work with. Use tsx instead of ts-node for ESM - tsx 'just works' vs ts-node has many ESM problems. Latest LibAuth might require Node >= V22. V23 might have non-ESM with ESM mixing support but can't use top-level await which LibAuth needs for libsecp256 WASM initialization."
        },
        {
          "question": "What is NPM domain expiration password reset vulnerability?",
          "answer": "Farooq: For many packages on npm, the domains used for Email has expired. Someone else can register domain, launch mail server, then use reset password mechanism to get control of packages. This is major supply chain attack vector."
        },
        {
          "question": "What is benefit of OP_EVAL pulling functions from old transactions?",
          "answer": "Titanic efficiency and bug-reduction gain. People write needed thing once, everyone refers to it. Otherwise copy-pasting everywhere which is bug risk itself. Widely used functions get audited once, patched version released if bugs found (like npm packages). MORE bugs if everyone rewrites own or copy-pastes."
        },
        {
          "question": "What is community ownership problem with BCH documentation?",
          "answer": "Mathieu/emergent: Maintaining high quality docs is lot of work and for no personal benefit. At least code has personal benefits like github stars, npm downloads, showcase. Each copy owned by repo owner - if owner isn't committed to updates, no reasonable expectation for them to happen."
        },
        {
          "question": "What is mainnet.cash 2.7.0 update?",
          "answer": "Big update tackling many recent issues and modernizing the lib. github.com/mainnet-cash/mainnet-js/releases/tag/2.7.0. These changes will have positive impact on Cashonize and other integrations."
        },
        {
          "question": "What mainnet-js improvements for bundle size and features?",
          "answer": "Bundle size 737 kB -> 270 kB (gzip) - got lot slimmer by externalizing SBCH functionality and storage providers. Great for automatic UTXO selection and automatic change outputs - easiest solution in TS/JS for simple BCH/token sends. Example apps using different frameworks in github.com/mainnet-cash/mainnet-js/tree/master/demo. Fee handling abstracted away as feature."
        },
        {
          "question": "When should you use mainnet-js versus libauth for BCH dapp development?",
          "answer": "Mainnet-js is a high-level library best for most use cases - it's easier and internally powered by libauth. Use it if the functionality covers your needs. Libauth is low-level and provides more advanced control when you need fine-grained transaction construction or operations mainnet-js doesn't expose. Mainnet-js also allows extending the base wallet class for application-specific functionality."
        },
        {
          "question": "Why does Next.js show topLevelAwait warnings when using mainnet-js with libauth?",
          "answer": "Webpack generates warnings about async/await and topLevelAwait when Next.js doesn't fully understand the build configuration. These are usually safe to ignore if the mainnet-js demo's next.config.mjs is used correctly - the warnings don't prevent the code from working. Verify functionality by checking if wallet addresses generate correctly rather than focusing on build warnings."
        },
        {
          "question": "What are effective AI prompting strategies for deep analysis?",
          "answer": "Using deep think mode then deep search asking 'are you really sure?', then ignoring answer and presenting problem gives AI really good understanding. Second answer can be worse (overcomplicated) - by third reiteration things get out of whack. Best method: establish base with first question then provide complex details in second turn."
        },
        {
          "question": "What is Trezor Blockbook BCH naming and cosmetics approach?",
          "answer": "Implemented throughout Trezor code including coin name as 'bcash'. Attempt to change would only aggravate them. Not a hill worth dying on. Pat could apply cosmetics on top of contributed code for own deployments but would not push to upstream. Blockbook is maintained, well taken care of with no critical fixes - should be in healthier state now than 2020."
        }
      ]
    },
    {
      "name": "Wallets & User Experience",
      "description": "Wallet development, user interfaces, WalletConnect, payment UX, and end-user application integration",
      "faqs": [
        {
          "question": "How can BCH work without internet using merkle proofs?",
          "answer": "Wallets pass around merkle proofs to verify TX inputs are valid. Can't verify double spends without miners, but acceptable for small payments. TX chains get longer with no unconfirmed TX verifiability. Need regular chain sync to verify TXs actually valid. However, IMO lot of work for dwindling use-case - better solution is higher connection reliability."
        },
        {
          "question": "How do SPV wallets verify without being lied to?",
          "answer": "Tom: Any SPV wallet that wants to verify proofs needs headers - if they don't do that they're not verifying they're not being lied to. Electron Cash uses search indexers and does checks thus needs headers. Can query electrum server for checkpoint at any height N which will be root of all headers from 0 to N-1."
        },
        {
          "question": "How do you troubleshoot WalletConnect2 connection issues with BCH dapps like tapswap?",
          "answer": "If WalletConnect2 shows a persistent connection without wallet selection options, first try ending all sessions in the dapp's settings. If the disconnect button doesn't work, manually remove all localStorage items mentioning 'wc2' in your browser's developer tools. Clearing site-specific cache and data can also resolve stuck sessions between the dapp and wallet."
        },
        {
          "question": "How does BCH wallet with Nostr integration work?",
          "answer": "Web wallet generates 12-word mnemonic for user on first login. Auto-generate private key and BCH address at index 0 on 245 derivation path (standard for SLP-token aware wallets). From that private key can generate nsec and npub for Nostr account. In future, allow import of nsec from elsewhere to generate BCH address and hydrate web wallet."
        },
        {
          "question": "How does BitPay handle JSON Payment Protocol vs BIP70?",
          "answer": "Tom: While it does JSON-PP, it ALSO does protocol buffers PP. What your wallet handles depends on what your wallet asks BitPay to provide. Jim: They got Electron Cash to implement JPPv2 specifically for their service and UI uses Select Wallet dropdown now before you pay."
        },
        {
          "question": "How does SPV merkle block sync work?",
          "answer": "Tom: Wallet needs to ask any full node all merkle blocks once. If started 24 hours ago need to send 144 requests (some 40 bytes each). If ran 6 hours ago only ask 36 blocks. Benefit of merkle is network activity stable regardless size of wallet - doesn't matter if you used million addresses."
        },
        {
          "question": "How does StableHedge compare to Tether in terms of design goals?",
          "answer": "StableHedge is not designed as a Tether competitor for massive holdings. The bonus of not having millions in one entity is avoiding disproportionate threats against people (like $5 wrench attacks against team members or loved ones). No multisig helps against physical coercion. It's better to treat Paytaca team as precious people who shouldn't become big targets by holding excessive funds."
        },
        {
          "question": "How should wallet template verification work?",
          "answer": "Tom: Normal users won't be able to tell if template is going to rug them. Best approach is wallet will trust templates approved and verified by company and refuse to use any other templates. You move trust to wallet makers who have reputation."
        },
        {
          "question": "What Go libraries are available for BCH wallet development?",
          "answer": "For Go wallet development, bchwallet (github.com/gcash/bchwallet) provides the core wallet functionality. The BCHD project also includes wallet libs/utils and GRPC API. Neutrino wallet was implemented in Go with full functionality. Backends options include Fulcrum (Electrum protocol), BCHD GRPC, Chaingraph, or the BCHC indexer - all accessible from Go code."
        },
        {
          "question": "What are different wallet template security policies?",
          "answer": "Jonathan: High-security focused wallets will refuse to let users add new templates they haven't audited and signed for. High-versatility wallets let you add any template with nothing but stern warning between you and imminent loss of funds. Most wallets fall in between."
        },
        {
          "question": "What browser compatibility issues exist with WalletConnect2 on BCH?",
          "answer": "Brave browser has known issues with WalletConnect. If WalletConnect2 shows a persistent connection without wallet selection, remove all localStorage items mentioning 'wc2' via browser developer tools. Safari and Firefox have better compatibility. Edge lacks per-site cache clearing which complicates debugging connection issues."
        },
        {
          "question": "What is CashConnect vs WalletConnect for BCH?",
          "answer": "CashConnect used by BCH Guru, only implemented in one wallet. Supposed to solve for HD wallets. WalletConnect has relay servers to integrate apps and wallets. CashConnect promising but couldn't find much information or reference implementation anywhere."
        },
        {
          "question": "What is CashRPC protocol for BCH wallet-app communication?",
          "answer": "BCH Guru docs link to bitcoincashresearch.org/t/cashrpc-protocol-to-attempt-to-unify-wallet-app-comms/1201 but definitely early. CashConnect also uses WalletConnect currently as transport layer. Ideas to move to libp2p but big gap between end goal vs currently realistic."
        },
        {
          "question": "What is Flowee Pay module system for DApps?",
          "answer": "Flowee Pay mobile has modules that can be developed mostly separate from app. Gives developer power to make custom interface for specific purpose as screen in wallet. Full access to wallet and transaction builder. Great UI/UX pretty easy with Qt/QML tech. Plugin concept like Satoshi's core features."
        },
        {
          "question": "What is LibP2P for BCH wallet communication?",
          "answer": "BCA: LibP2P allows WalletConnect-like functionality - run web-accessible Fulcrum/backends from home, encrypts everything. If both app & wallet have same IP they could establish direct connection instead of sending data to centralized server only for it to come back to same machine."
        },
        {
          "question": "What is Nostr coordination layer for BCH wallets?",
          "answer": "Kallisti: Nostr as coordination layer for wallets is something very interesting to explore. Could implement wallet-app communication inside BCH client. Maybe Alice needs to tell Bob how many tokens to transfer without using centralized service like email or telegram."
        },
        {
          "question": "What is Paytaca's StableHedge stablecoin solution?",
          "answer": "StableHedge (bitcoincashresearch.org/t/stablehedge/1504) uses a centralized peg mechanism but with fully transparent treasury and permissionless minting/redemption. Treasury backing is 50% in BCH (from which anyone can 'pull' by calling the redeem function) and 50% in 2x AnyHedge shorts. Users trust Paytaca to maintain treasury correctly, but unlike centralized entities, they can't lie about the state - if they rug or lose backing, everyone will see on-chain."
        },
        {
          "question": "What is WalletConnect 2.0 complexity assessment?",
          "answer": "Shadow reviewed specs.walletconnect.com/2.0 - there are 5 types of different servers with damn high complexity! Zero chance this can be easily replicated with any generic open source replacement. Any replacement will require lot of work whether generic relay tech exists or not."
        },
        {
          "question": "What is cashaddress.org paper wallet feature request?",
          "answer": "Request for 6 paper wallets per page with about 0.11 inch margin. Would make it easier to cut and save paper. Currently generates single wallet per page."
        },
        {
          "question": "What is seedless wallet approach for BCH onboarding?",
          "answer": "Designated trusted party helps with recovery - requested quite often. May be good for heavy onboarding as stepping stone for people not comfortable with 100% self custody. Example: sideshift.ai uses random unique string (username) + another string (password) to deterministically determine deposit addresses so account can be rebuilt."
        },
        {
          "question": "What is status of WalletConnect BCH integration?",
          "answer": "Integration in limbo (github.com/WalletConnect/walletconnect-monorepo/issues/5672). Submitted but didn't know proper format. Registering chain with Explorer doesn't impact/improve wallet and dapp support ability - simply way for users to discover wallets and dapps supporting chain. Fuzzy on how integration actually works."
        },
        {
          "question": "What is template system approach for BCH dApp security?",
          "answer": "Jonathan: move complexity out from dapps into templating system. If wallet adds generalized templating system powerful enough to understand on-chain actions, dapps no longer need signatures. They ask what you want to do, you verify locally it matches, then you do it yourself. Moves trust from apps to templates."
        },
        {
          "question": "What is the WalletConnect official integration status for Bitcoin Cash?",
          "answer": "BCH was officially added to WalletConnect/Reown documentation (github.com/WalletConnect/walletconnect-monorepo/issues/5672). The correct CAIP-2 chainIDs are: 'bch:bitcoincash' for mainnet, 'bch:bchtest' for testnet, 'bch:bchreg' for regtest. This is defined in Pat's WalletConnect spec and differs from BIP122-based identifiers used for BTC."
        },
        {
          "question": "What paper wallet generators are available for BCH?",
          "answer": "Chris Troutner's latest paper wallet apps are at opensourcemetalwallet.com. The wallet.fullstack.cash can sweep BCH and SLP tokens from these paper wallets. For custom designs, generate an image and use HTML to float generated QR codes over the image. CashStamps also has best support for paper wallets with two QR codes: one to the stamps site (redirecting to app stores), another with bch-wif for claiming."
        },
        {
          "question": "What security warnings should paper wallets include to protect private keys?",
          "answer": "Paper wallets should warn users not to expose private keys to cameras, videos, or other people. The warning text should be comprehensive: 'Do not let any camera, video or person see this' rather than just 'no photos'. This protects against Google Glass, smartphones, and other recording devices. Users often don't realize that taking photos/videos stores data elsewhere with high probability of eventual third-party access."
        },
        {
          "question": "Why build separate BCH wallets instead of collaborating?",
          "answer": "Tom: biggest problem is not tech but trust and opportunity. People don't build on existing wallets, they start their own and after 2 years maybe release something years behind. Realized it's case of wanting control and maybe being unable to work together. If integrated they'd instantly gain users and profit from fees."
        },
        {
          "question": "Why do cold wallets with carved seeds have security risk?",
          "answer": "Jonathan: This kind of cold wallet moves all complexity for signing to user who commonly makes mistakes. Great for power users who are careful, bad for any user that is not. Even well-educated power users sometimes not careful when drunk, high, or under stress."
        },
        {
          "question": "Why hasn't Satoshi's SPV been more widely implemented in wallets?",
          "answer": "Implementing full cryptographically secure SPV (with all hash verification from the whitepaper) is a lot of work and not strictly necessary so far. Most light wallets check on a server, which is easier. Users have never requested \"totally cryptographically secure SPV\" - they prioritize other features. It's a global-scale \"nice to have\" rather than an essential feature for everyday end users given the massive wallet development backlog."
        },
        {
          "question": "Why use browser wallet plugin instead of WalletConnect?",
          "answer": "Tom argues WalletConnect super overkill - just want wallet in browser plugin or browser that ships with wallet. Web browser needs to add support for code 402 which is what we want. Don't want web protocols to make browser on phone talk to wallet on same phone."
        }
      ]
    },
    {
      "name": "Infrastructure & Nodes",
      "description": "Node implementations, indexers, network infrastructure, SPV, Fulcrum, Chaingraph, and backend services",
      "faqs": [
        {
          "question": "Do current BCH wallets implement SPV exactly as specified in the whitepaper?",
          "answer": "Both Electron Cash and Flowee Pay fulfill the description given in section 8 of the whitepaper regarding SPV (Simplified Payment Verification). They verify merkle proofs against headers as specified. The confusion often stems from whitepaper pruning - no node implements the pruning scheme from the whitepaper, but clients do implement SPV merkle proof verification against headers."
        },
        {
          "question": "How can Fulcrum and nginx be configured to prevent bandwidth abuse?",
          "answer": "Fulcrum has built-in rate limiting features that should be enabled. Nginx supports rate limiting via the `limit_rate` directive (e.g., `limit_rate 100k;` to limit connections to 100KB/s). For P2P bandwidth monitoring, create a cron job that checks BCHN RPC every 15 minutes to ban nodes consuming excessive data. OS-level tools typically don't track specific remote connections well."
        },
        {
          "question": "How does Chaingraph handle double spends vs Electrum?",
          "answer": "Richard/Jonathan: Electrum provides consistent view (changes mind between consistent views). Chaingraph will remember and serve double spends - if you want consistent view of chain need to write queries carefully to exclude double spends. Electrum won't give two UTXOs from conflicting transactions."
        },
        {
          "question": "How to fix LibAuth ESM compatibility issues with ts-node?",
          "answer": "LibAuth v3.0.0 has ESM compatibility issues with ts-node. Solutions: 1) Modify tsconfig.json settings, 2) Use tsx instead of ts-node - tsx 'just works' for ESM while ts-node has many problems, 3) Use Node V22 or higher (LibAuth requires >= V22), 4) Consider Deno or Bun as Node getting old architecturally. tsx is wrapper around NodeJS that runs TypeScript."
        },
        {
          "question": "What are Bloom filters and do they grow over time?",
          "answer": "Bloom filters (CBloomFilter in BCHN) are fixed-size data structures. At construction, a fixed-length bytearray is created. Inserting items toggles individual bits but doesn't change the size. They never grow - this is fundamental to how Bloom filters work as probabilistic set membership structures."
        },
        {
          "question": "What are realistic latency numbers for cross-continental block propagation?",
          "answer": "Tokyo-Paris ping shows ~593ms round-trip (300ms one-way for header delivery). However, most mining nodes have <100ms latency (US-China). Header is only ~100 bytes so bandwidth isn't relevant. Decentralization helps: miner only needs to reach 1-2 nodes quickly, those then forward the header, eliminating edge cases."
        },
        {
          "question": "What backend infrastructure should Go developers use for BCH applications?",
          "answer": "If using Go, BCHD is likely much easier to use as a backend than Fulcrum. While Fulcrum is great for Electrum protocol support, BCHD provides native Go libraries and APIs designed for Go development. The Knuth node had Go-specific features but has been obsoleted. BCHD represents the best-maintained Go-friendly BCH node implementation."
        },
        {
          "question": "What hardware and software optimizations enable fast BCH full node synchronization?",
          "answer": "BCHN can sync from 0-100% in 2-4 hours with: NVMe SSD storage, moderately fast CPU (Intel Xeon or equivalent), and fiber/1Gbit network connection. Bitcoin Verde offers a fast sync mode that can further speed up initial blockchain download. If syncing takes 24+ hours (like 24hrs for 50%), hardware bottlenecks or network issues are likely the cause."
        },
        {
          "question": "What infrastructure does chipnet.imaginary.cash run and what bandwidth challenges does it face?",
          "answer": "Chipnet runs BCHN (full node), Fulcrum (electrum indexer), and nginx (web server) exposed to the public. With a 3TB/month bandwidth allocation, normal chipnet usage is under 10GB/month. Bandwidth hogs can exhaust the monthly limit in days, requiring sophisticated OS or application-level rate limiting and IP tracking to prevent abuse."
        },
        {
          "question": "What is Electrum protocol header sync process?",
          "answer": "Tom/Kallisti/Bastian: Getting headers quite cheap and one-time thing. On p2p network any full node answers request with up to 2000 headers per request. Fulcrum has blockchain.block.headers method returning all headers between start_height and start_height+count. Header sync basically instantaneous."
        },
        {
          "question": "What is Infrastructure Blocks iBCH tail emission proposal?",
          "answer": "Possible solution to diminishing block reward problem is to use iBCH block reward when/if Infrastructure Blocks get implemented. They can have small tail emission, unlike BCH. Could be used for gigahashcoin pricing instead of BCH block reward which goes to zero."
        },
        {
          "question": "What is Python Telegram bot BCH payment integration stack?",
          "answer": "Use pybitcash (bitcash.dev well maintained by reputable person) to import/generate keys and create payment addresses with required amount. Run Fulcrum as SPV server connected to external full node. Scan mempool using blockchain.address.get_mempool for fast 0-conf detection. Fulcrum best in class indexer. Long-term: libauth may have rust implementation with python bindings."
        },
        {
          "question": "What is Schnorr signature size issue on BCH tempnet?",
          "answer": "Jonathan/Bastian: Signature is only 64 bytes but should be 65 bytes I think. Node keeps thinking it's ECDSA and rejects with 'Non-canonical DER signature' error. Working with signatures and hashes is always fun - any error turns into entirely invalid result."
        },
        {
          "question": "What is debate about increasing BCH OP_RETURN limits?",
          "answer": "Current 220 byte limit considered perfect by some. Proposed compromise for higher limits: increasing cost per byte above current limit to disincentivize but not prevent. Concern: higher limits cause chain growth with data, makes running full node harder, could crowd out money use case. Data bloat forces drastic infrastructure changes to scale (similar to EVM node challenges)."
        },
        {
          "question": "What is double-spend network topology research technique?",
          "answer": "2025 replication of 2015 CoinScope paper - send conflicting TXs to different nodes, see which gets mined, identifies influential nodes. Found 200 nodes close to 50% hashrate. mempool.space partitioned 91% of time. Uses first-seen policy: nodes respect first-seen, conflicts rejected by those who got alternative first. DSProofs would detect method for P2PKH but not P2SH. Differential measurement technique."
        },
        {
          "question": "What is the E2EE messaging web app for BCH?",
          "answer": "Message.psfoundation.info - web app that lets you send and receive E2EE encrypted messages to any BCH address. Uses Bitcoin Cash for addressing and encryption infrastructure."
        },
        {
          "question": "What is the recommended approach for implementing BCMR on-chain authchain resolution?",
          "answer": "Basing lookups on Fulcrum is super slow and creates excessive server burden. Nothing beats dedicated indexers: Chaingraph, Paytaca indexer (github.com/paytaca/bcmr-indexer), or Cauldron's rust indexer (indexer.cauldron.quest/bcmr). If using Rostrum electrum server, blockchain.utxo.get can help. Mainnet-js also has built-in BCMR support. Avoid implementing from scratch with Fulcrum."
        },
        {
          "question": "What is whitepaper pruning and why isn't it implemented?",
          "answer": "Whitepaper pruning would allow pruned nodes to serve historyless SPV wallets - keeping all transactions with UTXOs and creating SPV proofs for those transactions, while discarding spent transaction history. No node currently implements this. However, clients do implement SPV merkle proof verification against headers, which is the key security feature for light wallets."
        },
        {
          "question": "Which chipnet explorers and infrastructure are currently operational?",
          "answer": "Chipnet infrastructure status varies. loping.net (cbch.loping.net) runs its own servers and shows contract addresses correctly. bch.ninja and chaingraph.cash also run independent servers. Some explorers depended on im_uname's Fulcrum server which went down due to bandwidth abuse (3TB/month exceeded). Jason's chaingraph explorer likely has its own infrastructure since he mines chipnet blocks."
        },
        {
          "question": "Why use merkle blocks instead of indexer layers for wallets?",
          "answer": "Full nodes with merkle blocks already solve wallet sync in extremely cheap and scalable way. Problem: most wallets don't use this, instead use new layers which create new problems. Merkle blocks provide best user experience - so much more consistently fast and private updating when opening wallet. Rethinking SPV proposal moves cost from indexers to nodes, centralizing responsibility. Adding more layers possible but not optimal."
        }
      ]
    },
    {
      "name": "Payment Systems & Subscriptions",
      "description": "Payment protocols, recurring payments, subscription models, invoicing, and payment processing solutions",
      "faqs": [
        {
          "question": "Are payment channels used on BCH?",
          "answer": "Emergent/Chris/Tom: Payment channels possible on BCH since 2009. Nobody actively using standard libraries though. There is at least one party making thousands of payment channels on BCH regularly but they aren't using standard libraries. Double-spend proof feature is perfect for this use-case."
        },
        {
          "question": "How do BCH subscription payments with xpub work?",
          "answer": "Future idea: repeat payment request includes xpub instead of single address - allowing privacy friendly flow. Example: I have patreon, you're my customer. I sent you payment request. Instead of Bitcoin address I sent you xpub. You pay me every month from next address on that xpub. Without xpub you'd have to send something every month making man in middle needed."
        },
        {
          "question": "How do Mecenas-style recurring payment contracts work on BCH?",
          "answer": "Recurring payment contracts allow pre-funding a specific amount upfront - no further user actions needed. The recipient, another user, or a server can spend the pre-set amount at pre-set intervals by 'pulling' from the contract. This exists as an Electron Cash plugin (github.com/KarolTrzeszczkowski/Mecenas-recurring-payment-EC-plugin) but a WalletConnect version would enable Zapit, Paytaca, and Cashonize users to easily use it."
        },
        {
          "question": "How does x402 compare to payment channels for web browsing?",
          "answer": "When browsing website you'd pay once per page with x402. Single transaction for all pages would make more sense - Bitcoin related chains could open payment channel. Criticism: paying per page vs payment channel for whole session efficiency."
        },
        {
          "question": "How does x402 enable web payments ecosystem?",
          "answer": "Main way forward is more browser support for crypto. Ecosystem non-existent - if webserver returns 402 today browser says illegal state. Need something that works so ecosystem can start building. Wonderful to see progress for payments in webbrowsers."
        },
        {
          "question": "How does x402 protocol architecture work?",
          "answer": "Chris: Three entities - Server, Client, Facilitator. Facilitator is middleware server handling payment and settlement. Server can be normal API without blockchain-specific code. To adapt to BCH, Facilitator would have HD wallet, assign address to each user, accept batch payment and debit against it."
        },
        {
          "question": "What is ARCC and how does it relate to recurring payments?",
          "answer": "ARCC (github.com/kiok46/arcc) is an advanced recurring contract structure, more sophisticated than basic Mecenas-style contracts. Zapit was considering integrating it into their services. It would be a perfect integration for the BitCANN platform and represents more advanced smart contract patterns for recurring payments on BCH."
        },
        {
          "question": "What is Coinbase x402 protocol for crypto payments?",
          "answer": "Chain-agnostic protocol using HTTP 402 code for browser-based crypto payments. Simple scheme can build BCH economy around it. Prime example of cryptocurrency as money of the internet. Could replace dumb paywalls on websites and only be done with crypto."
        },
        {
          "question": "What is Flowee Pay serverless recurring payments approach?",
          "answer": "User doesn't manually resubmit each month. Wallet handles serverless repeated payments with auto-renewal by default unless user specifies not to renew for next period. One payment per period. Combines tech from xpub BIP47 payment codes with privacy-friendly recurring payment protocol."
        },
        {
          "question": "What is Paytaca Payment Hub and what features does it offer?",
          "answer": "Paytaca Payment Hub is a beta solution enabling online merchants to accept Bitcoin Cash payments directly without intermediaries (payment-hub.paytaca.com). Early adopters can use both manual and programmatic invoice creation. WooCommerce and other e-commerce platform plugins are currently in development."
        },
        {
          "question": "What is the authorization token approach to recurring payments without full pre-funding?",
          "answer": "Instead of pre-funding the full subscription amount, users store funds in a large pool, then issue authorization tokens with spending restrictions and hand them out as needed. The tradeoff is privacy - this model links payments through the shared pool. Implementation requires either specific wallet code to manage or a wallet that understands templates, planned for implementation with XO (CashScript execution opcodes)."
        },
        {
          "question": "What is x402 protocol for crypto payments?",
          "answer": "Chris: Coinbase developing x402 protocol - blockchain agnostic, uses HTTP 402 code for browser crypto payments. Whitepaper mentions 'batched settlements' on page 12 but just carve out for future work - nothing implemented or refined into specification yet."
        },
        {
          "question": "What is x402-bch protocol implementation?",
          "answer": "Chris: x402 protocol created by Coinbase leverages HTTP 402 'Payment Required' error. Coinbase implementation focuses on USDC on Base L2 blockchain. Created slight variation to protocol to support Bitcoin Cash - developers can implement own x402 server that accepts BCH for payments."
        },
        {
          "question": "What market demand exists for BCH-denominated subscriptions?",
          "answer": "TMU from running largest monthly recurring payment protocol 3+ years: zero market demand for coin-denominated subscription service. Never heard user say they want it. Why BCH getting dropped as option for v3 unspent annuities (subscriptions). MUSD might change this."
        },
        {
          "question": "What use cases require confirmations despite zero-conf availability?",
          "answer": "High-value transactions (house, car, >$2000) where amounts are too risky for zero-conf. Non-anonymous transactions with named invoices where instant finality isn't required (rent, monthly bills). These typically get checked after an hour or day. Zero-conf is mainly for anonymous transactions you'd do with cash today."
        },
        {
          "question": "What was CoinText and offline payment experiments?",
          "answer": "Vin Armani created CoinText - sent different cryptos via text message, tied joint-custody wallet to phone number (shut down years ago). Tobias Ruck developed be.cash offline-payment system - load RFID card with miner-confirmed UTXOs ($1, $5, $10 denominations), merchant needs internet but payer doesn't."
        },
        {
          "question": "Why do subscription services prefer pull over push payments?",
          "answer": "Pull schemes benefit from customer indifference to cancellation - significant revenue stream. Studies show customers don't cancel subscriptions they should. If user must take action each month to keep subscription, more likely to cancel than auto-renew."
        },
        {
          "question": "Why is BCH recurring payment system unique vs EVMs?",
          "answer": "No other p2p chains with introspection and no EVM with low fees as long-term plan. Can't hardcode MEV executor fee and expect to run on EVM chain long-term. Easy one-time fire-and-forget recurring payment solution running for years is unique BCH value prop. Only new BU chain might support same."
        }
      ]
    },
    {
      "name": "DeFi & DEX",
      "description": "Decentralized finance protocols, AMMs, liquidity pools, trading, and DeFi infrastructure including Cauldron, TapSwap, and derivatives",
      "faqs": [
        {
          "question": "Can L1 transactions handle high-frequency trading on DEXes?",
          "answer": "Mempool processing chained TX every 200-300ms is fine - L1 TXs aren't suitable for HFT anyway. Jay Berg claims to have solved sequencing problem with Sidepit (docs.sidepit.com). Some solutions being explored involve miners running sequencers to keep it decentralized."
        },
        {
          "question": "How do BCH trading bots work without primary DEX websites?",
          "answer": "Trading bots already exist that do NOT use primary websites. Libraries for doing DeFi that aren't using websites exist like github.com/hosseinzoda/vegabch. Having central entity needing to sign off on each transaction is catastrophe waiting to happen - entity could just not sign and lock funds."
        },
        {
          "question": "How do Cardano sequencers (batchers) work and why does BCH need them?",
          "answer": "Cardano has sequencers called 'batchers' for DeFi ordering. BCH mempool is not good enough - can only process chained transaction every 200-300ms. Sequencing job for DeFi UTXOs could be done by miners to produce extra income. Main issue is real-time synchronization - users need to know latest UTXO set state before building transaction."
        },
        {
          "question": "How do subroutines handle recursion and indexing in the Subroutines CHIP?",
          "answer": "Subroutines declare at code start, receiving an index. All calls use this index (2 bytes per call), including recursive self-calls. The compiler maps this like shortening method names to integers. Subroutines read a fixed number of stack arguments defined at declaration. For variable argument counts, use loops instead of subroutines. OP_RUNSUB calls local subroutines; OP_RUNSUB2 calls subroutines from other inputs."
        },
        {
          "question": "What BCH contracts benefit from faster block times?",
          "answer": "Faster block times improve: (1) AMM DeFi - cannot use zeroconf, need faster confirmations. unspent.cash perpetuities, Cauldron AMM, and dozens of MEV contracts use anyone-can-spend transactions. (2) PR and psychological perception as 'snappier coin' due to more confirmations in shorter timeframe. Instant transactions (zeroconf) handle all other cases."
        },
        {
          "question": "What TVL metrics show BCH DeFi growth?",
          "answer": "TVL (Total Value Locked) graphs at tokenaut.cash/defi and defillama.com/chain/Bitcoincash show growth. Cauldron, anyhedge, bchbull, Moria all showing \"up and to the right\" pattern. TVL numbers not affected by transaction count inflation (unlike TX count which can be artificially inflated on low-fee chains)."
        },
        {
          "question": "What WalletConnect dapp ideas are sought by the BCH community?",
          "answer": "Key WalletConnect app ideas include: vault management, Last-Will inheritance, Mecenas recurring payments, 'Hodl' timelock, AnyHedge integration, airdrop/dividends distribution. Also sought: AMM DEX curve visualizer/simulator, CashScript-py SDK, address analyzer for privacy leaks, double spend proof (DSP) checker website, and TypeScript BCMR indexer."
        },
        {
          "question": "What is Small Index contract and how does it help DEX discovery?",
          "answer": "Small Index (bitcoincashresearch.org/t/1471) can tag many protocols per token category. Designed for CatDex but could handle Cauldron, Tapswap, and Dutch Auctions. Solves SPV wallet pool discovery if pools advertise using this method - would increase pool volume so they have incentive to adopt."
        },
        {
          "question": "What is Squid technology and how is it used with TapSwap?",
          "answer": "Squid is a blockchain indexing/query technology integrated into TapSwap at sqd.tapswap.cash/graphql. It provides a GraphQL interface for querying blockchain data related to the DEX. The technology enables efficient data access for the TapSwap application without requiring full node queries for every operation."
        },
        {
          "question": "What is TON blockchain malleability issue?",
          "answer": "Total Commander: Recently integrated TON and malleability in UTXO coins is nothing compared to what happens there - tx hash mutates on its own upon propagation. It's total nightmare when you don't use their proprietary indexers."
        },
        {
          "question": "What is alternative to executable bit for OP_EVAL?",
          "answer": "Have OP_DEFINE, then have to have OP_RUNDEFINED, then also have OP_GETDEFINED so can get definition on stack and hash it for verification. Then have to have OP_UNDEFINE maybe. Creates whole new stack for function definitions. Executable bit approach: use same opcodes to manage function stack rather than create whole new stack for function definitions."
        },
        {
          "question": "What is the DEX UTXO contention issue on Cauldron?",
          "answer": "Mempool conflicts occur due to arb bots competing - users create valid Cauldron transactions and push simultaneously to different node sets causing split. Trade not final until no mempool conflicts exist. With faster blocks, users wait for 1 confirmation which would be much shorter (2-4min vs 10-20min). Mempool is not good enough - needs better real-time synchronization or split rules for DeFi vs non-DeFi transactions."
        },
        {
          "question": "What is the DeFi-to-commerce 0-conf transition pain point?",
          "answer": "Suppose you do DeFi actions ending with 0-conf p2sh chain, then pay merchant with p2pkh - it has 0-conf p2sh ancestors so DSP score is 0 and merchant may demand 1 conf. With 10min target only 0.5% chance DeFi chain confirms during 1min user action lag, so 17min wait in 50% cases. With 1min blocks, DeFi likely confirmed - merchant accepts 0-conf, or worst case 1-3min wait."
        },
        {
          "question": "What is the deferred TXID assignment proposal for DEX transactions?",
          "answer": "Proposal: broadcast utxo+signature (checkdatasig) enabling asynchronous TX generation. User doesn't commit to specific TX/TXID - remains undefined until miner generates and mines transaction. TXID assigned once someone mines it. Only change required is in communication so miners can build TXs with this method."
        },
        {
          "question": "What is the permissioned vs permissionless DEX tradeoff?",
          "answer": "Server can increase UX (BCMR metadata, LP statistics, faster order books, secure reorder-free TX submission) and provide APIs with stability guarantees. Not all central servers are bad - only ones that lock you in. However, third-party signing requirement means operator can comply with government regulations. Alternative: thin indexers deployable by anyone with REST APIs for getting pools - treats Cauldron as protocol not service."
        },
        {
          "question": "What vulnerability did TapSwap nearly have?",
          "answer": "Almost blew up for silly reason: checked signature against pubkey provided in input but without authenticating it via committed hash. Example of footgun that has nothing to do with OP_EVAL - demonstrates fundamental contract safety doesn't change with eval."
        },
        {
          "question": "What was Pat's tapswap contract bug and fix?",
          "answer": "Pat's tapswap had bug: had spender provide pubkey but didn't have code to auth pubkey against hash - oops, now any key can unlock it. Bug quickly fixed - he swept them all and moved to new versions using the exploit haha. Shows contracts can ask for bytes in unsafe way, whether data or code."
        },
        {
          "question": "When is 0-conf considered final enough to proceed with DEX swaps?",
          "answer": "Users need to know there are no mempool conflicts. Issue exists for DeFi users who need certainty transactions won't reverse. Common case: user has tokens A,B,C, merchant wants token Z. Wallet creates p2sh swap chain to Z then p2pkh to merchant. P2PKH not DSP compatible due to unconfirmed p2sh parent."
        },
        {
          "question": "Why can't primary market maker use AMM for instant finality?",
          "answer": "If make up random number and it gets published to blockchain in completely decentralized way or used in perfectly decentralized protocol, decentralization after the fact doesn't change that source of data was single party. Primary market maker for crypto can profit from keeping lots of markets in sync - problem is, with current AMM and blocktime, can't get instant trade finality without also mining all the blocks."
        }
      ]
    },
    {
      "name": "Oracles & External Data",
      "description": "Oracle implementations, price feeds, external data integration, and off-chain data verification",
      "faqs": [
        {
          "question": "How do fiat-denominated recurring BCH payments work with oracles?",
          "answer": "For fiat-denominated recurring payments (e.g., $30/month), payouts use a specific fungible token (FT) with an oracle message as input. The oracle provides exchange rate data so contracts can calculate the correct BCH amount. Main limitation: contracts depend on oracle availability - if the oracle ends, the contract can't determine the correct conversion amount."
        },
        {
          "question": "How to achieve decentralized oracles?",
          "answer": "Ultimate answer: computers need to scan and certify real world information in way that cannot be faked (i.e. can be verified cryptographically). In each case, there is real human that does work to collect some data and provide it. This human is the centralized element. Replace that human, and you get decentralization."
        },
        {
          "question": "Is verifiable serializing AMM with centralized entity acceptable?",
          "answer": "Argument: verifiable serializing AMM using centralized entity is no-worse than price-oracles. Not possible to get USD/EUR prices using completely decentralized system because these currencies belong to centralized entities (governments). Even for on-blockchain tokens only, still centralized entity that extracts trade fees, so completely absolutely decentralized operation is impossible anyway."
        },
        {
          "question": "What are TXv5 read-only inputs and how do they benefit oracle protocols like d3lphi?",
          "answer": "Read-only inputs allow multiple transactions to reference the same UTXO without conflicting. For oracle protocols like d3lphi, this prevents users from fighting over oracle message UTXOs. Thousands of users can spend the same oracle UTXO (UTXO_A) read-only within minutes. This saves the intermediate transaction that would otherwise create multiple copies (B, C, D, E) of the oracle data."
        },
        {
          "question": "What are best practices for LLM-assisted BCH development?",
          "answer": "Crank up context window (32K tokens), stuff as much relevant information as possible into prompt. If have ZK code or Script examples, add those. Make scope very concise, provide feedback on error logs. Feed in external documentation for AI to review. Use one AI to generate code, feed to different AI to sanity check."
        },
        {
          "question": "What is gigahashcoin stable coin oracle mechanism?",
          "answer": "Gigahashcoin is ultimate 'stable' coin - price oracle as decentralized as mining. GH/BCH = (difficulty / block reward). With ASICs already far on development s-curve, should be less inflationary than fiat, but still inflationary. Others put up BCH collateral to mint GHC at oracle price."
        },
        {
          "question": "What oracle solution recommended for BCH prediction markets?",
          "answer": "Oracle itself is trivial (week's work for backend dev). Real challenge is data - entire business in itself. Financial data providers already exist with thousands of customers. Combining existing data businesses with oracle tech makes best approach for tens of thousands of tickers and prices. See read.cash/@TomZ/oracles-7bd61bb5 for details."
        }
      ]
    },
    {
      "name": "Zero-Knowledge Proofs & Privacy",
      "description": "ZKP implementation, privacy features, CashFusion, shielded transactions, and cryptographic privacy techniques",
      "faqs": [
        {
          "question": "Can shielded addresses be implemented on BCH using ZK-STARKs?",
          "answer": "Shielded addresses that hide sender/receiver (but not amounts) are theoretically possible on BCH using existing opcodes without consensus changes. The challenge is that finding your funds requires testing every output with costly EC-mul operations. While a specialized ZK-STARK verifier opcode could improve efficiency, the polynomial arithmetic needed for zero-knowledge proofs can be implemented using current BCH Script opcodes."
        },
        {
          "question": "How do you set up DNS-over-HTTPS with Unbound and nginx?",
          "answer": "Running your own DNS-over-HTTPS resolver improves privacy and avoids ISP/government MITM. Melroy van den Berg provides config examples (gitlab.melroy.org/-/snippets/620) and blog series covering Unbound setup (blog.melroy.org/2025/dns-part-1/). This allows you to control DNS resolution instead of relying on potentially compromised public resolvers or ISP DNS."
        },
        {
          "question": "How does Tornado Cash ZKP mixer work?",
          "answer": "Fixed deposit tiers (1, 10, 100, 1000 BCH for indistinguishable amounts). On deposit get receipt. On withdraw: ZKP proves you own deposit cryptographically without revealing which specific deposit. Merkle trees track deposits. When withdrawing don't submit commitment for which you redeem - proves ownership of secret with data + keys, not specific receipt."
        },
        {
          "question": "How would ZK shielded transactions work on BCH?",
          "answer": "Users send BCH to a P2SH covenant address, receiving an NFT with random-looking 32 bytes in the commitment. To transact inside the shielded pool, provide a ZK proof as input script authorizing updates to NFT commitments. The covenant calculates/verifies encrypted balance updates according to ZK system math. To exit, provide a proof showing entitlement to BCH without revealing when you entered. All transactions look like one address transacting with itself to external observers."
        },
        {
          "question": "Is Tornado Cash possible on BCH with current tools?",
          "answer": "Yes with loops - possible to do ZKP verification. Other piece is merkle trees to track deposits. Would use OP_CHECKDATASIG for proof verification. See github.com/tornadocash/tornado-core/blob/master/contracts/Verifier.sol. Industry moved to ZKPs for sidechains, SPV 2-way peg proofs never took off."
        },
        {
          "question": "Is central signer for AMM trades comparable to CashFusion coordinator?",
          "answer": "Automated signature from centralized server that one can opt to use isn't that bad. Everything still public and has to be broadcast regardless. Attempts by service to cheat likely obvious with tx to sign not adding up if transaction(s) withheld. CashFusion has coordinator that has to be trusted to some degree - not much difference here."
        },
        {
          "question": "What are mobile background task limitations for BCH wallets?",
          "answer": "Android/iOS pedantic about conserving battery. Capacitor background runner is scheduled job running every X minutes (depends on platform, ~15min delay). Alternative: Push Notifications as 'wake up app' (requires Firebase for Google, ANS for Apple). Privacy tradeoff - backend needs to know addresses wallet monitors. Flowee Pay can run background without GUI for CashFusion when charging overnight."
        },
        {
          "question": "What are the advantages of ZK shielded pools over CashFusion?",
          "answer": "The main advantage is non-interactivity. With ZK pools, you can pay in, transact inside the shielded covenant, and pay out whenever you like without needing to wait for other participants. CashFusion requires coordination with other users to create coinjoin transactions. However, ZK proofs are large, resulting in big transactions. Optimal architecture (L1 per-user TXs vs privacy L2) remains undetermined."
        },
        {
          "question": "What are the differences between ZK-SNARKs and ZK-STARKs for BCH privacy?",
          "answer": "ZK-SNARKs require a trusted setup (potential backdoor) and use smaller proofs, while ZK-STARKs have no trusted setup, are quantum-resistant, but have larger proof sizes. The ZKP math is extremely complex - 100x harder to understand than Bitcoin's whitepaper. An average programmer with 20 years experience but no math-specific PhD won't understand ZKP whitepapers. This complexity raises concerns about implementing backdoors unintentionally."
        },
        {
          "question": "What challenges exist for BCH ZK privacy implementations?",
          "answer": "For Tornado Cash-style ZKPs, BCH needs a method to loop through all previously used nullifiers to prevent withdrawal replay/double-spends. ETH has global state and hash tables making this trivial, but BCH has no equivalent. Without this, implementations require challenge periods with bonds and merkle trees, making them less user-friendly than EVM chains. Additionally, proof sizes can't shrink without cryptographic breakthroughs."
        },
        {
          "question": "What is RPA (Reusable Payment Addresses) in Bitcoin Cash and how does it relate to privacy?",
          "answer": "RPA is a stealth address implementation on BCH that enables privacy-preserving reusable addresses. It works similarly to stealth addresses where the receiver can publish a single reusable address, but each payment goes to a unique on-chain address. Electron Cash supports RPA, though it's currently in alpha stage. RPA is more efficient and compatible than some alternatives and can work alongside CashFusion."
        },
        {
          "question": "What is Shadow's ZKAM-FMT for fiat verification?",
          "answer": "Shadow: ZKAM-FMT spec verifies browser TLS data and email data to confirm fiat payments have been made to onramp from FIAT. ZKP2P guys implemented similar idea. Can be done better - custom Firefox/Chromium variant watches for certain variables in document instead of browser plugin with proxies and TLS magic."
        },
        {
          "question": "What is Tom's advice for ZKP implementation on BCH?",
          "answer": "Doesn't make sense to want opcodes enabled on chain as first step. Instead work with team to make actual ZK script work by modifying full node privately. When it works fully and isn't hacked instantly, then look at what was needed and propose changes to main chain. Avoid wishful design behavior."
        },
        {
          "question": "What is ZKP2P hooks for BCH onramping?",
          "answer": "Luke/Shadow: ZKP2P hooks could be used with cross chain swaps like THORChain. Hook acts as robot - takes USDC from ZKP2P escrow and gives to THORChain with memo to swap for BCH and send to specific address. Could tap into zkp2p for trustless on/offramping into BCH."
        },
        {
          "question": "What is the difference between ZK-SNARKs and ZK-STARKs for BCH privacy?",
          "answer": "ZK-SNARKs require a trusted setup and use smaller proofs, while ZK-STARKs have no trusted setup, are quantum-resistant, but have larger proof sizes. For BCH, the discussion centers on using ZK-STARKs to hide sender and receiver addresses without hiding amounts. Implementation doesn't necessarily require new opcodes - existing math operations can perform the polynomial arithmetic needed."
        },
        {
          "question": "What privacy features are planned for BCH's May 2025 upgrade?",
          "answer": "Shielded transactions are being discussed as a possibility after the May 2025 network upgrade. This would complement existing privacy features like CashFusion and RPA (Reusable Payment Addresses). The shielded transaction capability would represent a significant enhancement to BCH's privacy toolkit beyond the current stealth address implementations."
        },
        {
          "question": "What wallet support exists for RPA (Reusable Payment Addresses) on BCH?",
          "answer": "Electron Cash currently supports RPA functionality. However, broader wallet adoption remains limited, with RPA still being considered an alpha product. Increased awareness and wallet provider adoption is needed before RPA becomes a mainstream privacy feature. Some wallets like Cake Wallet are being approached to add RPA and CashFusion support together."
        },
        {
          "question": "Why are advanced ZK systems currently impractical on BCH?",
          "answer": "While technically possible already, ZK verification is very impractical and expensive. Porting a zkVM's on-chain verification to 2025 BCH VM would cost ~10,000x typical BCH transaction fees with extremely limited wallet support. Most work involves workarounds rather than optimal implementations. Even building from scratch, the constraint differences encourage sub-optimal ZK constructions versus systems designed without program length concerns."
        },
        {
          "question": "Why is CashFusion trustless compared to other mixers?",
          "answer": "CashFusion requires no trust - needing to trust some parties is infinitely worse than not needing to trust any parties. This contrasts with staking-based approaches which add trust assumptions about who can replace commitments."
        }
      ]
    },
    {
      "name": "Mining & Consensus",
      "description": "Mining operations, consensus mechanisms, difficulty adjustment, block time, and miner economics",
      "faqs": [
        {
          "question": "Can PoW difficulty serve as price oracle for fee adjustments?",
          "answer": "Research shows correlation between PoW difficulty and USD price (bitcoincashresearch.org/t/1426). Could be used for minimum relay fee algorithm - favorite angle for auto-adjusting fees because doesn't rely on third-party. Has some edges to work out but promising approach."
        },
        {
          "question": "Can miners bypass nSequence relative locktime enforcement?",
          "answer": "If nSequence is set, miners cannot mine the transaction until the input ages - this is consensus-level enforcement, not miner policy. However, if nSequence is not locked by signature, CSV, or introspection, a miner could change the value and mine the modified transaction ahead of time. Locking the nSequence value (via signature/script) is critical for trustless locktime enforcement."
        },
        {
          "question": "Can miners manipulate block fees for oracle pricing?",
          "answer": "Miners could mine blocks with extra unpublished transactions creating fees going back to themselves - 100% gameable. But other miners could try steal those fees via reorg. Packing fee is akin to wash trade - market buy and instant sell + risk of reorg and other miner taking your donation. If pack 10%-20% extra could skew feed without reorg risk."
        },
        {
          "question": "Do read-only inputs create MEV or attack vectors for miners?",
          "answer": "A miner could ignore transactions referencing a read-only UTXO while including a transaction that fully spends it, invalidating the read-only transactions. However, this is not economically incentivized - miners would be throwing away fees for no good reason. It's the same as existing double-spend scenarios, nothing fundamentally new regarding miner behavior."
        },
        {
          "question": "Does BCH have mining documentation for newbies?",
          "answer": "Shadow: Does not seem like BCH has documentation allowing newbies to start mining quickly. Last week there was guy who wanted to mine here and he could not find any precise docs plus nobody could help him directly. Certainly lacking but not extremely important issue."
        },
        {
          "question": "How can Starlink bandwidth be increased for mining operations?",
          "answer": "Multiple Starlink dishes can be used to increase bandwidth (starlink-enterprise-guide.readme.io/docs/using-multiple-starlinks). Starlink provides ~50ms latency which is sufficient for mining. Combined with improving LEO satellite constellations over 10-20 years, could bring everyone close to speed-of-light limits for global connectivity."
        },
        {
          "question": "How do miners and relay fees interact with fee markets?",
          "answer": "Lowering relay fee shouldn't require consensus - some miners already only mine TXs above certain fee (saw 7sat/byte minimum). Miners can accept lower fee TXs to include as space allows, though may put them at orphan disadvantage. If demand exists, miners will lower min fee with prodding if it gets them more revenue."
        },
        {
          "question": "How does ASERT DAA adapt to block time changes?",
          "answer": "ASERT is time-based, invariant of target block time. Adjustment won't be faster, just smoother - done in smaller increments/decrements. If had enough power to halve or double difficulty after 2 days - continues to be case with shorter blocks, just done in greater number of smaller adjustments. Same with ABLA - same 2x/year annualized rate limit in smaller steps. gitlab.com/0353F40E/fablous#difficulty-adjustment-algorithm-daa"
        },
        {
          "question": "How does network topology affect 1-conf reorg experience with first-seen rule?",
          "answer": "1-conf reorgs happen with 1st-seen rule due to connection quality disparities. Miners with worse connection have higher chance of losing the race. Users close to slow miners have higher chance of witnessing TX reorgs. Header-first mitigates bandwidth but not ping - if 80% hash is on one side of planet and 20% on opposite, the 20% has ~300ms disadvantage (0.05% orphan rate at 10min, 0.5% at 1min blocks)."
        },
        {
          "question": "How does the H(A||B) deterministic tiebreaker affect block replacement difficulty?",
          "answer": "To flip a known block A with block B requires satisfying BOTH network difficulty AND winning H(A||B) comparison - making it 2x harder than just satisfying network difficulty. This is a tie-breaker only for same-height contention, not an override. One block can't replace two blocks even if tip's hash would win."
        },
        {
          "question": "What are the hardware constraints that make header-first mining attractive?",
          "answer": "Miners face hardware problem: can't turn off mining during validation without damage. Going from zero to 100 ampere in milliseconds creates massive power fluctuations causing hardware reboots. Options: (1) keep mining old block (risk orphan), or (2) mine empty block on new header until validation completes. Most choose option 2 (header-first)."
        },
        {
          "question": "What attack vector exists with deterministic block tiebreaker for high-fee blocks?",
          "answer": "If a block has extraordinarily high fees (like 3x usual), miners could be incentivized to keep mining at same height since there's 50/50 chance their block wins H(A||B) and all other miners would switch. This creates unknown unknowns where miners might continue mining at tip-1 to hurt another miner with little risk instead of mining on tip."
        },
        {
          "question": "What is Infrastructure Blocks (iBCH) and how does it relate to BCH?",
          "answer": "iBCH is a CashToken that enables experimental features BCH cannot have (10s block time, higher inflation, higher orphan rate). BCH serves as gas, so you always need BCH to use iBCH. It's supplementary, not superior - intentionally flawed (higher orphan rate, more inflation) but does things BCH cannot do like controversial features without burdening main chain."
        },
        {
          "question": "What is header-first mining and why do some pools not use it?",
          "answer": "Header-first allows miners to immediately start mining on new block using just the header (before full validation) but must mine empty block to avoid invalid UTXO spending. Most pools use it, but Foundry doesn't. Reasons: BTC's 1MB limit makes bandwidth impact insignificant, Foundry is majority so doesn't lose much from validation time, and as fees dominate subsidy header-first becomes less attractive (empty blocks lose fee revenue)."
        },
        {
          "question": "What is the FUD concern about block time change?",
          "answer": "Changing block time creates FUD opportunity: 'changing block time will mean inflation goes up by same factor.' Vast majority never hit problems this solves, so it's a tax. Chain hasn't grown much in 5 years - doing this now could drain chance of winning."
        },
        {
          "question": "What is the argument about faster block times being contentious?",
          "answer": "Block time isn't technically specified in whitepaper (only referenced as example). Despite practical benefits, changing it could be contentious due to ecosystem inertia. Some argue existing permissionless solutions should be implemented first before considering consensus changes."
        },
        {
          "question": "What is the argument for adjustable block time?",
          "answer": "Proposal: reduce time to 1min now, make it adjustable without breaking again so future can go to 30s, 20s, maybe 10s once LEO sats ubiquitous - by just changing number in code and activating. Pay most of cost now, reap benefits forever."
        },
        {
          "question": "What is the deterministic tiebreaker proposal for Bitcoin block selection?",
          "answer": "Proposed solution (bitcoincashresearch.org/t/1532) uses H(A||B) hash comparison as objective tiebreaker for same-height blocks instead of subjective 1st-seen rule. When two blocks have equal chainwork, nodes would switch to the block that wins H(A||B) test. Aims to enhance fairness and convergence, particularly relevant for faster block times (1min blocks would have 0.5% orphan rate from 300ms ping difference)."
        },
        {
          "question": "What motivated research into deterministic block selection tiebreakers?",
          "answer": "Research started from asking: 'Why are orphan rates a problem?' and 'How high could we tolerate?' Key insight: if everyone had equal orphan rates they wouldn't be a problem. Led to question: 'If we have to have some orphans, is there a way to equalize orphan rates across pools?' Goal is enabling faster blocks (10s blocks possible in 10-20 years with better connectivity)."
        },
        {
          "question": "Why do orphan rates matter less if they're equal across all pools?",
          "answer": "If everyone had equal orphan rates, impact would be like a price drop - everyone affected equally. The inequality is what's dangerous for the network. Actual orphan rate is less than one block per week. With 2min blocks maybe 1 every few days. Formula for max orphan rates is just a limit - actual doesn't grow proportionally."
        },
        {
          "question": "Why is BCH not a good timestamp server?",
          "answer": "Bitcoin is *not* a good timestamp server but could be - if future time limit was more tight and monotonic timestamps enforced (zawy12 github issue). Block time used as extended nonce bits to find valid PoW. As difficulty goes up, timestamp used more in lieu of new block template resulting in new merkle proof."
        },
        {
          "question": "Why is block time benefit curve considered non-linear?",
          "answer": "2.5 minutes isn't twice as good as 5 minutes - it still sucks if waiting for confirmation. Real benefits seen at sub-10s where user can watch screen and take action if TX not confirmed. But sub-10s not reasonable with today's tech."
        },
        {
          "question": "Why is dust limit necessary and how should it work?",
          "answer": "Controls state bloat - critical for scaling. Should be enforced on UTXO creation but NOT on spending. No reason to prevent cleaning up 0 or 1 sat outputs - want easy state removal. Proposal: halve every 4 years conditional on difficulty at least doubling (difficulty = proxy for coin value growth vs real world)."
        },
        {
          "question": "Why is orphan rate inequality more problematic than the absolute orphan rate?",
          "answer": "If everyone had equal orphan rates, it would have the same impact as a price drop - everyone affected equally. The inequality is what's dangerous for the network. BCH's actual orphan rate is less than one block per week. The formula for max orphan rates is simply a limit, not the actual rate."
        }
      ]
    },
    {
      "name": "Networking & P2P",
      "description": "Peer-to-peer networking, protocol messages, mempool behavior, block propagation, and network topology",
      "faqs": [
        {
          "question": "Can HTTP-based p2p networks form true mesh?",
          "answer": "Tom/BCA: VAST majority of http users are behind NAT and short-lived. Yes you can replicate Satoshi's design - clients connect and share IPs of other clients etc. But individual users very unlikely to actually be part of real mesh due to NAT and connection constraints."
        },
        {
          "question": "How common are double spends on BCH?",
          "answer": "Richard/Emergent: Double spends are normal and happen more often than one might think. Easy to accidentally create them in automated/procedural systems that aren't mature yet. Network rejects double spends and over electrum you'll always see consistent view of chain."
        },
        {
          "question": "How did BCA learn BCH p2p layer?",
          "answer": "Shadow: You sent TX manually using Linux console tools? You must have been really bored. BCA: I wanted to learn how p2p layer stuff works, it was good opportunity. Like I did this just by reading the spec - sent transaction manually via console."
        },
        {
          "question": "How do block size and latency relate to propagation bottlenecks?",
          "answer": "The smaller the blocks, the more weight latency has. The larger the blocks, the more weight bandwidth has. With small blocks (like BTC's 1MB), bandwidth's impact on propagation time is insignificant - latency dominates. For larger blocks, bandwidth becomes the bottleneck."
        },
        {
          "question": "How does 0-conf p2sh ancestor affect p2pkh safety?",
          "answer": "0-conf p2sh ancestor makes p2pkh 0-conf much less reliable. Problem can spread to other non-DeFi transactions. Either needs split in rules or better real-time synchronization. If propagation meets where conflicts exist, it stops and DSP is generated instead of propagating conflict."
        },
        {
          "question": "How does Nostr achieve censorship resistance?",
          "answer": "Kallisti: Nostr is a hydra. Censorship-resistant property comes from simplicity of protocol - spinning up relay is super simple. Even if you got banned from all popular relays or all maxi clients block your relay, you and your friends/followers can still use your relay/client or some neutral relay/client."
        },
        {
          "question": "How does Nostr relay architecture work?",
          "answer": "Kallisti: Nostr relays don't sync with each other. It's just client-server where client connects to many independent servers and client does what it will with whatever data those servers serve. All glued together by pubkey crypto."
        },
        {
          "question": "How does mintxfee parameter work in BCHN?",
          "answer": "Mintxfee setting (fees in BCH/kB smaller than this considered zero fee for transaction creation, default: 0.00001). Can be set lower than 1 sat/byte using fractional BCH/kB values. Creation != relay so that setting might not make transactions propagate without corresponding relay setting."
        },
        {
          "question": "How does nakamoto-cash handle MerkleBlock fetching?",
          "answer": "Uses concurrent approach mapping new peer after every 25k block range. May receive higher height blocks before lower ones. Can tweak rescan and BloomManager for different strategy. Added get MerkleBlocks button with sliders to adjust start/stop ranges in examples/ dir. 25k is 6 months of blocks - may be bit much."
        },
        {
          "question": "What factors affect network latency besides distance?",
          "answer": "Speed of light varies by medium (faster through air than glass). Total factors: routing overheads (number of hops), total distance, interference, and medium. Fiber has less interference and fewer hops but slower light speed than air. Starlink has ~50ms latency - terrible vs fiber, great vs many less-wired countries."
        },
        {
          "question": "What is LibP2P exploration for BCH WalletConnect alternative?",
          "answer": "Jim exploring LibP2P as generalized solution. Allows WC-like functionality plus perks: run web-accessible Fulcrum/Chaingraph/backends from home, run web-accessible BCH-P2P subnet on LibP2P (encrypts everything, effective against deep-packet inspection). Still have hesitations on LibP2P libs stability."
        },
        {
          "question": "What is Starlink's satellite-to-satellite low latency capability?",
          "answer": "Normal Starlink has ~50ms latency bouncing land uplink off nearest sat. They also have capability to offer very low bandwidth ultra low latency beaming between sats on their global sat-to-sat network links. Sats are redundant and disposable - 'just make them cheap and let them fall' approach to LEO orbit loss."
        },
        {
          "question": "What is Yggdrasil mesh networking?",
          "answer": "Tom: Yggdrasil is mesh networking tech that replaces tcp/ip layer. Excellent concept, needs to be used more. Reminds of power where app and wallet on same local network can communicate directly without centralized server."
        },
        {
          "question": "What is concern about DeFi vs peer-to-peer cash focus?",
          "answer": "Goal is peer to peer cash - without healthy growth there, chain will die. DeFi/tokens filling blocks only marginally better than ordinals on BTC. Use them as advertising for real game, but never lose sight of native token being real product. Need stability - currencies stabilized with sound derivatives."
        },
        {
          "question": "What is network effect strategy for BCH development?",
          "answer": "Focus on BCH first - don't prioritize retaining builders with foot out door or maintaining compatibility with other chains. Network effect comes from unique features others want to copy. Thriving BCH motivates others to integrate. Catering to integrators gets neither BCH improvements nor integration. Weighted network nodes (100% BCH focused) exponentially more impactful."
        },
        {
          "question": "What is the Rust nakamoto package p2p client example?",
          "answer": "A light p2p client example app (github.com/samrock5000/p2p-client/tree/master/examples) using rust nakamoto package. Toy app lets you update bloom filter from input form and send 'loadfilter' message to peers. Detects BCH addresses and hex encoded data. Future plans include merkleblock fetching and inclusion proof validation. Builds on Linux and macOS."
        },
        {
          "question": "What is the history of FindBitcoin.cash / GeoDrop.cash?",
          "answer": "FindBitcoin.cash (later GeoDrop.cash) was a proof-of-concept built during a hackathon by Chris Troutner, Daniel Humgon, Lightswarm, and architect/erik (devpost.com/software/purelypeer). It used SLP and was maintained by Chris afterward. The idea evolved to PurelyPeer.cash with a new team. It was a webapp inherently prone to geospoofing; PurelyPeer mobile-only execution helps prevent geospoofing."
        },
        {
          "question": "Why doesn't DSProof catch all double-spends?",
          "answer": "DSP won't catch nuked parent p2sh. Requirements: transaction must contain all P2PKH, must either spend only from confirmed UTXOs OR all mempool ancestors must also be all-P2PKH transactions. All inputs and mempool ancestor chain must be SIGHASH_ALL without ANYONECANPAY. P2sh ancestor means DSP score of 0 - NOT COVERED by DSPs."
        },
        {
          "question": "Why introduce sub-satoshi (millisat) precision and how does it affect miners?",
          "answer": "At $100M/BCH, 1 sat/byte fees would be $219 USD per transaction - too high for BCH's low-fee goal. Millisats allow 1 msat/byte ($0.219 USD) fees. The minrelayfee exists for network health (UTXO set size, economic value), not miner compensation. It doesn't change with subsats unless needed. Miners already control fee acceptance - they can mine empty blocks or accept below-minrelay fees via direct submission."
        }
      ]
    },
    {
      "name": "Scalability & Performance",
      "description": "Scaling solutions, transaction throughput, UTXO management, optimization techniques, and performance considerations",
      "faqs": [
        {
          "question": "How are UTXOs stored and managed?",
          "answer": "UTXO stored on disk, only loaded to memory when spending. Optimization of keeping old UTXOs on disk vs memory already implemented. Taking UTXOs not moved in years and keeping on disk reduces cost significantly, slightly more costly to load when needed (plus IBD with UTXO commitments)."
        },
        {
          "question": "How can multiple users use same DEX UTXOs without conflicts?",
          "answer": "Core question: multiple users want to use same set of UTXOs at same time - how without leading to ignored transactions? Could use blind limit orders so miners/platforms match them. Opens MEV opportunities but from user POV pays with MEV for execution success. Risk: user makes trades thinking profit only to have it removed."
        },
        {
          "question": "How to get UTXO composition info with mainnet-js?",
          "answer": "await wallet.getAddressUtxos() to see UTXO info directly. Fee handling abstracted away - this is feature. Depending on whether balance is 5 $100 bills or 100 $5 bills, bitcoin fee will be different. Need to know what fee to pay to know if have enough. JS library and REST service should have identical API to extent possible. Frontend supports watch wallets."
        },
        {
          "question": "Is UTXO contention a problem for BCH?",
          "answer": "Emergent/Tom: UTXO contention is real issue BCH going to need to face. Not clear yet exactly what tradeoffs are in various solutions. Wallet or app can create more UTXOs for nearly free. Worst case is regular mempool divergences, best case nothing burger."
        },
        {
          "question": "What are read-only UTXOs from TXv5 proposal?",
          "answer": "Jason's TXv5 idea: input that doesn't get spent. Any input can be marked as RO in transaction which causes UTXO to not be removed from UTXO set. Neat idea but many details to iron out before feasible."
        },
        {
          "question": "What mempool management challenges do read-only inputs create?",
          "answer": "Nodes must keep spent UTXOs in memory until mined because new valid transactions might reference them read-only. Example: UTXO_A has thousands of read-only spends plus one non-read-only spend creating UTXO_B (new oracle message). Before mining, miners are incentivized to accept more transactions spending UTXO_A since they don't conflict and all pay fees. This complicates mempool eviction and resource management."
        },
        {
          "question": "Why can't read-only UTXOs work with global state?",
          "answer": "Read-only UTXOs would be special: indestructible and non-contentious (many txs can spend same one). But it's hacky way to get global function table. Without ownership they can't be burnt, leading to UTXO set pollution. Can't make well-scaling coin with global state."
        }
      ]
    },
    {
      "name": "Security & Best Practices",
      "description": "Security considerations, common vulnerabilities, footguns, auditing, and contract safety patterns",
      "faqs": [
        {
          "question": "What are the security tradeoffs of StableHedge's centralized treasury?",
          "answer": "A rug is possible with multisig treasury control, and hack/loss of controlling keys is also a risk. Improvements could include partial withdrawal with renewed timelocks (e.g., max 10% every 10 days) to slow down potential rugs. The risk is mostly taken by hedgers. Paytaca is expected to limit funds to what's needed for merchant onboarding, avoiding disproportionate $5 wrench attack risks to team members."
        },
        {
          "question": "What is Distrust chain of trust concept?",
          "answer": "Farooq reviews codebase and declares it good. Then Benjamin trusts Farooq and any code Farooq marked as reviewed, Benjamin also considers good. So if Simon trusts Benjamin, he automatically trusts Farooq too. Hierarchical web of trust for supply chain security."
        },
        {
          "question": "What was Kaspa state bloat attack and solution?",
          "answer": "Kaspa attacked by intentional state bloat. KIP-0009 introduced transaction mass function to limit state bloat. Previously had compute cost, added storage cost. BCH has generic per-byte fee (friction). See github.com/kaspanet/kips/blob/master/kip-0009.md"
        },
        {
          "question": "Why is not having OP_EVAL worse for security?",
          "answer": "People wanting eval functionality will emulate in convoluted ways harder to analyze than plain eval, with more footgunning opportunities. Same exotic uses already possible with introspection. Safety guardrails require convoluted methods to achieve simple things."
        },
        {
          "question": "Why was BCH targeted in npm supply chain attack?",
          "answer": "Scammers perceive BCH as big and important enough to attack. Good news in a way - no BCH wallets or services affected AFAIR. Jim: phishing mails comp'd so many projects past months becoming big problem. Sticky even patch versions of dev libraries now and run dev envs using docker-compose containers."
        }
      ]
    },
    {
      "name": "Testing & Debugging",
      "description": "Testing strategies, debugging tools, chipnet, testnet, and development workflows",
      "faqs": [
        {
          "question": "How do you run the mainnet-js REST API server?",
          "answer": "The mainnet-js REST API server setup is documented at mainnet.cash/tutorial/running-rest.html. By default it tries to use regtest, which requires running a local node. To use a public node instead for initial testing, you need to configure the network settings. For production, you should learn how to run a node and connect it to regtest or mainnet."
        },
        {
          "question": "How does testnet usage relate to formal proposal analysis?",
          "answer": "Have perfectly good testnet environment for formal analysis. With crowdfunding, wouldn't be hard to present findings in more academic way than chatting. Arguments better presented when accompanied by peer-reviewable hard data - sandbox testing feasible for proposals evaluation."
        },
        {
          "question": "How to use Electron Cash on chipnet?",
          "answer": "Start from command line with --chipnet flag. Example: electron-cash --chipnet. No GUI option - must use command line. Chipnet vs testnet4: chipnet for CHIP testing, testnet4 general purpose, chipnet upgrades 6mo before mainnet. Use chipnet by default for less issues with CashScript and other tools."
        },
        {
          "question": "What Blockbook fundraising proposal controversy?",
          "answer": "10 BCH for research codebase/database/build/test - Jeremy questioned if 15 minutes with Cursor. 5 BCH for QA - debate if bugs should fall under feature cost. Counter: understanding codebase can take week to build mental model, answering 'how to best architect this' takes time. AI iterations still needed."
        },
        {
          "question": "What are CashScript v0.11.0 major features?",
          "answer": "Debugging capabilities for new transaction builder - allows transaction builder to work with local testing/debugging using mocknet and inside Bitauth IDE. Half year in works with multiple pre-releases to iron out edge cases. Migration notes on docs website help deal with breaking changes."
        },
        {
          "question": "What is txvulcano and when is it useful?",
          "answer": "txvulcano (ships with Flowee) is tool for generating transactions - useful for new chains/regtest chains. Not as useful for newer chains since included wallet is too simplistic. Can fill blockchain with test transactions."
        },
        {
          "question": "What network should BCH contracts testing use?",
          "answer": "Use chipnet by default for less issues. Chipnet upgrades 6mo before mainnet. For time-based contracts use --regtest - can mine blocks in batches to regression test scripts in time automatically. mainnet-js, unspent.app, futurebitcoin.cash all use same docker-compose setup. Tom tests on mainnet or testnet4. Electron Cash: start with --chipnet flag."
        }
      ]
    },
    {
      "name": "Integration & Interoperability",
      "description": "Cross-platform integration, Nostr, other blockchain bridges, and external service connections",
      "faqs": [
        {
          "question": "How can BCH addresses be derived from Nostr pubkeys for tipping services?",
          "answer": "A server-side approach combines the Nostr pubkey with a secret to auto-generate a master BCH private key per pubkey. This master node then generates additional key pairs on demand for tracking content and tippers. This allows tracking UTXOs tied to each receiver's content, creating 'top lists' based on tips received, and posting signed Nostr reply messages showing the tip."
        },
        {
          "question": "How can BCH receive addresses be added to Nostr profile metadata?",
          "answer": "Nostr metadata already supports custom fields that can store BCH addresses. Add a 'bchAddr' or 'bitcoincash' tag to the profile's event 0 metadata JSON containing the BCH address. The infrastructure exists, but broad adoption requires Nostr clients to display and allow editing these fields. A coin-agnostic NIP using a 'tips' field with comma-separated addresses would enable multi-chain support."
        },
        {
          "question": "How to convert Nostr npub to BCH address?",
          "answer": "Nostr nsec are compatible with any secp256k1 chain. Draft NIP allows conversion of npub (addresses identifying Nostr users) to BCH address - enables direct payments and tipping between Nostr users with BCH. Example code: github.com/christroutner/nostr-sandbox/blob/master/16-npub-to-BCH-addr/npub-to-bch.js. Long term: wallets like Cashonize could add Nostr feature to social media directly and receive value on chain."
        },
        {
          "question": "How to generate BCH address from Nostr npub?",
          "answer": "Figured out how to generate BCH address directly from Nostr npub. Don't even need user to add BCH address to Kind 0 post. Can derive directly from npub and know they can spend using private key (nsec) used to generate npub. github.com/christroutner/nostr-sandbox/blob/master/16-npub-to-BCH-addr/npub-to-bch.js"
        },
        {
          "question": "Is Nostr protocol permissionless for BCH usage?",
          "answer": "Kallisti: You're not dependent on any BTC infrastructure at all and doesn't matter if they don't accept your NIPs. Just steal an event ID and do whatever you want lol it's just software. Nostr is permissionless."
        },
        {
          "question": "What are the adoption challenges for BCH integration in Nostr clients?",
          "answer": "Most native Android and iOS Nostr clients are managed by BTC maximalists unlikely to adopt BCH solutions. Beyond technical implementation, there are significant political and community hurdles. Building initial proof-of-concept custodial solutions that work across all clients can help demonstrate use cases before tackling the harder problem of convincing individual client developers to add wallet functionality."
        },
        {
          "question": "What are the challenges of integrating BCH wallets into Nostr clients?",
          "answer": "The main challenges are: 1) convincing Nostr client developers to add wallet library features when full wallet integration is a much larger project than typical clients, 2) receivers need to configure BCH addresses in advance before receiving funds, and 3) achieving adoption across multiple popular clients. A simpler approach uses custodial third-party services requiring minimal client-side integration work, similar to Lightning's model in Nostr."
        },
        {
          "question": "What are the tradeoffs between custodial and non-custodial BCH tipping on Nostr?",
          "answer": "Custodial solutions are simpler to implement and work out-of-the-box with all existing Nostr clients with minimal integration (just adding a link per note). Non-custodial solutions require extensive work integrating wallet functionality and node connectivity into multiple Nostr clients. While custodial approaches sacrifice trustlessness, they enable testing use cases and building userbase before tackling complex non-custodial implementations."
        },
        {
          "question": "What is Nostr Pumps and how does it integrate BCH with Nostr?",
          "answer": "Nostr Pumps (pump.coinmachin.es and pumpstr.coinmachin.es) is the first Nostr client with BCH tipping embedded, including a developer's guide for integration. It supports nsec/secret key login for mobile phones (iOS/Android) until better Nostr plugins are available. The client enables BCH-based 'pumps' (tips) tied to Nostr notes, testing BCH adoption within the Nostr community."
        },
        {
          "question": "What is SLP DEX Nostr integration roadmap?",
          "answer": "SLP DEX (dex.psfoundation.info) is BCH wallet with Nostr integrated. Has basic social media functions, recently added Likes. Figured out how to 'Like' SLP tokens and working on integrating that. Next will let people post directly on tokens - nice merging of BCH, Tokens, and Nostr technology."
        },
        {
          "question": "Why can't Nostr keypairs be used directly with BCH transactions?",
          "answer": "Nostr uses BIP-340 BTC-style Schnorr signatures while BCH uses a different keypair scheme. The same private key generates different public keys in each system. If you send BCH to a Nostr pubkey address, the recipient cannot spend it using their Nostr private key because the keypair derivation is incompatible between the two systems."
        }
      ]
    },
    {
      "name": "Use Cases & Applications",
      "description": "Real-world applications, use case examples, domain names (BitCANN), fundraising, and practical implementations",
      "faqs": [
        {
          "question": "How do time-locked vaults protect users from mistakes?",
          "answer": "Jonathan: Smart educated people sometimes make mistakes, but if they set up time-locked vault when in good state of mind and have time to be careful, it protects them in future when they are of poor state of mind, under stress or other influences."
        },
        {
          "question": "How do transaction dependency graphs work with read-only inputs?",
          "answer": "Dependencies remain a DAG (Directed Acyclic Graph). Spending output A to create B, C, D, E, then spending those is equivalent to referencing A four times read-only to create the same outputs. In either case, if A gets removed (e.g., reorg), the entire descendant graph must be removed. Read-only inputs save the intermediate transaction creating copies but maintain the same dependency invalidation semantics."
        },
        {
          "question": "What are common JSX syntax restrictions that cause React errors?",
          "answer": "HTML nesting rules apply in JSX. A common error is placing block elements like <ul> inside inline elements like <p> - this is invalid HTML and React will throw 'Hydration failed' errors. Replace <p> with <div> when nesting lists, or remove the <p> wrapper entirely. JSX enforces stricter HTML validity than browsers which may render invalid markup."
        },
        {
          "question": "What domain registration issues affect BCH ecosystem?",
          "answer": "Bitcoinfees.cash expired on namecheap (though renewed later). Domain squatters use services like sedo.com with high minimum bids. Dot .io domains aren't awesome due to colonial history (British Indian Ocean Territory). Need to track critical ecosystem domains to prevent loss."
        },
        {
          "question": "What is Ethereum blind signing problem?",
          "answer": "J Master Pig: In Ethereum, users can't really see exact functions being executed, they are blind signing and just trusting address and domain unless they do serious deep dive. Signing is last line of defense, but if not structurally clear what they're signing, hard to catch malicious logic."
        },
        {
          "question": "What is current state of NIP process?",
          "answer": "Tom/Chris: Fiatjaf posted about changing NIP process because it's basically frozen and dead. Whole NIP process moving to 'everything is a draft, nothing is official'. NIP28 gets hate, most mirrors don't include it, but it works and people built software around it."
        },
        {
          "question": "What is the 80/20 rule in software development?",
          "answer": "The Pareto Principle in software states that 80% of a program can be written in 20% of the allocated time. The remaining 20% of features and bug fixes consume 80% of development time. This explains why initial implementations are fast but polish and edge cases take disproportionately longer. It's why 'don't let perfect be the enemy of good' is a common engineering philosophy."
        },
        {
          "question": "What is the counter-argument favoring faster blocks now?",
          "answer": "Having more robust futureproofed template encourages devs. Chain with less issues used by more people is encouraging. This is great time to do it - before/while people build, not after massive ecosystems exist. Fixed time spent, reap benefits forever - infinite ROI."
        }
      ]
    },
    {
      "name": "Documentation & Learning",
      "description": "Educational resources, documentation, tutorials, community learning, and developer onboarding",
      "faqs": [
        {
          "question": "How should documentation be formatted for LLM RAG databases?",
          "answer": "Ideal size is 2-3 paragraphs for documents in RAG database. Can't just add single large document or code base - must break up into small chunks so LLM can retrieve 'reminder snippets'. Use AI to break large docs into multiple markdown docs as pre-processing step. See github.com/christroutner/ben-training-data for examples."
        },
        {
          "question": "What are the BCH Devs & Builders chat ground rules?",
          "answer": "High signal low noise chat focused on BCH development. Constructive criticism welcome. When discussion gets long, consider if hundreds want to read it - take elsewhere or agree to disagree. No beating dead horses. Learn to DNE (Do Not Engage) if someone engages in bad faith."
        },
        {
          "question": "What are the benefits and risks of using AI tools like Grok for technical documentation?",
          "answer": "Grok can be useful for polishing documentation and enabling shared context through conversation links - anyone can continue from an already-set-up context. However, you must check everything the AI produces, as LLMs hallucinate when they don't know something. The new Grok 3 generation is reportedly more impressive, but complete removal of hallucinations is impossible since LLMs cannot be debugged like normal code."
        },
        {
          "question": "Why is decentralized educational content better than one centralized hub?",
          "answer": "Multiple educational sites provide redundancy and reach more people. BTC and ETH don't have single giant educational websites - large communities naturally produce several perspectives on the same topics. A group of interlinked sites allows exploration as the web was designed. Also, starting with 'educational website' is an easy entry point that often leads developers to more complex projects."
        }
      ]
    },
    {
      "name": "Community & Governance",
      "description": "Community processes, funding mechanisms, Flipstarter, governance, and ecosystem coordination",
      "faqs": [
        {
          "question": "How does community DAO funding work with BCH?",
          "answer": "BCA: Main problem with DAOs was they invite intermediaries but there's a way to hold dao accountable. Everyone's payment into dao is tracked, when dao pays out it takes same % from everyone's original payment. If not happy with what dao funds anymore - can pull out remainder of your money. Prevents money trapping."
        },
        {
          "question": "What alternative approaches exist for managing chat quality?",
          "answer": "Could require BCH bond in suitable/escalating amount which gets forfeit to community if continue to receive pushback (via regular vote). Could add cap of number/length of posts/words per time unit for people unable to observe social norms or obsessive about trivial nonsense."
        },
        {
          "question": "What are OpenCashDAO npm packages?",
          "answer": "Initial unstable versions: @opencashdao/contracts (github.com/OpenCashDAO/opencashdao-contracts) and @opencashdao/core (github.com/OpenCashDAO/opencashdao-core). Available on npm. Repos open for contributions. Telegram: t.me/opencashdao"
        },
        {
          "question": "What are tax implications of Flipstarter vs NFT fundraising?",
          "answer": "Flipstarter contributions are gifts (tax hassle, gift tax rules apply in US). Data analysis companies don't identify Flipstarter TXs automatically. Buying NFT for 5-10 BCH much less hassle than Flipstarter. UK example: can only gift 3000/year before affecting inheritance. Buying NFT for 10k doesn't trigger this - if sell for 5 it's cap gains loss."
        },
        {
          "question": "What is OpenCashDAO and what features does it provide?",
          "answer": "OpenCashDAO (bitcoincashresearch.org/t/opencashdao/1521, github.com/OpenCashDAO/contracts) is a DAO template with voting, proposals, and upgradable contract system. The base design pattern enables many applications like BitCANN. It demonstrates advanced covenant patterns for decentralized governance on BCH. Discussion group: t.me/opencashdao."
        },
        {
          "question": "What legal issues affect token distribution in crowdfunding?",
          "answer": "Creating tokens as part of campaign's claim TX easily done - on list for new cashstarter contract after bliss. However, putting limiter on collecting funding (target goal) might still classify as crowdfund bringing legal issues. Canada has crowdfunding-specific laws assuming custodial control. Worst-case: same regulation requirements as major bank."
        },
        {
          "question": "Why is concern trolling problematic in development chats?",
          "answer": "Concern trollers prolific in low moderation groups. 1 poorly adjusted person can cause grief for 10,000 others. Community must decide: change global reserve currency, or protect feelings of every socially maladjusted person. Exceptional cases must be treated exceptionally."
        },
        {
          "question": "What is the moderation philosophy for technical communities?",
          "answer": "Prefer not to heavily police chat - self-regulate and move off-topic discussions elsewhere. However, repeat offenders who drag chat down will be muted/banned. Generally had great signal-to-noise ratio with people keeping things professional and focused."
        }
      ]
    }
  ]
}